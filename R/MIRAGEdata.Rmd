---
title: "MIRAGEdata"   
purpose: To load, merge, explore, and plot lipidomics data and look for correlations with cardiometabolic endpoints the MIRAGE dataset.
output:
html_notebook: default
author: Ole Emil Andersen
date created: March 2024
editor_options: 
chunk_output_type: console
---

**Packages**

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(readxl) # reads Excel files
library(dplyr) # to manipulate data
library(tidyr) # facilitates tidy data transformation.
library(purrr) # enhances programming capabilities
library(tibble) # to make columns into row-names
library(janitor) # to clean column names
library(ggplot2) # for plots
library(ggbreak) # to break axis in ggplot 
library(grid) # to draw and annotate outside plots in figures
library(GGally) # makes pairwise plots
library(patchwork) # to make ggplot subplots
library(lme4) # for mixed models
library(emmeans) # for p-values and confidence intervals
library(lmerTest) # p-values for mixed models
library(correlation) # to analyse data for correlations
library(ComplexHeatmap); library(circlize) # to make complex heatmaps
library(ggrepel) # to avoid overlapping labels
library(table1)# library(labelled) # to create a table 1 
library(preprocessCore) # for q-normalization
```

# Project settings

Cut offs and values to be used throughout the analysis

```{r message=TRUE, warning=FALSE}
# Number of points above 0 needed for an analysis to take place. The number is the number of id's within class across all intervention groups.
analysis_cutoff <- 12

# Outlier threshold: The factor to multiply by the IQR to define outliers to remove.
# Default in many software is 1.5
outlier_IQR_factor <- 4

# Factor above LLOQ to discard a value NB currently not used
LLOQ_discard_factor <- 2

# Set too TRUE to remove outliers. Set to anything else to not remove outliers
outlier_remove <- FALSE
```

vgn# Load and prepare data

## Lipidomics data

Load data into long format and clean the data by replacing \<0 with 0 and N/A with 0.

```{r message=FALSE}
# Define the path to the Excel file
file_path <- paste0( getwd(), "/data-raw/2022Mar Goodpaster Results With Name Spaces.xlsx")

# List sheet names to load from excel file
sheet_names <- c("SPM SPH AC", "PG", "PI", "PS", "PA", "PE", "PC", "1,3-DAGs", "1,2-DAGs", "Cer dHCer GluCer LacCer GalCer", "TAG")

load_sheets_in_long_format <- function(file_path, sheet_names) {
  map_df(sheet_names, ~ {
    # Read the measurement names from the first row
    measurement_names <- read_excel(file_path, sheet = .x, n_max = 1) %>%
      colnames()
    
    # Read the data, skipping the first two rows
    data <- read_excel(file_path, sheet = .x, skip = 2, col_names = FALSE)
    
    # Limit the data to match the number of columns in the column names
    num_cols_in_names <- length(measurement_names)
    data_trimmed <- data[, 1:num_cols_in_names]
    
    # Assign column names to the data
    colnames(data_trimmed) <- c("Sample Name", measurement_names[-1])
    
    # Adjusting the replacement for "< 0" with 0 (as numeric) and "N/A" with NA
    data_cleaned <- data_trimmed %>%
      mutate(across(everything(), ~ case_when(
        .x == "< 0" ~ "0", # Replace "< 0" with "0"
        .x == "N/A" ~ "0", # Replace "N/A" with "0"
        TRUE ~ as.character(.x) # Keep other values as-is, converting to character to ensure type consistency
      ))) %>%
      type.convert(as.is = TRUE) # Convert back to original type where possible
    
    # Rename "Sample Name" to "sampleNumber"
    colnames(data_cleaned)[1] <- "sampleNumber"
    
    # Transform to long format
    data_long <- pivot_longer(data_cleaned, -sampleNumber, names_to = "measurement", values_to = "pmol")
    
    # Split the measurement into class and structure based on space
    data_long <- data_long %>%
      separate(measurement, into = c("lipidComposition", "lipidClass"), sep = " ", extra = "merge")
    
    return(data_long)
  }, .id = "sheet")
}

# Load all specified sheets into a single data frame in long format
lipidomicsDF <- load_sheets_in_long_format(file_path, sheet_names)

# Remove sheet column
lipidomicsDF <- select(lipidomicsDF, -sheet)
```

### Identifiers, samples and PBIS

**Load identifiers and sample weights** and merge with the data frame and split the pid into pre/post and id.

```{r}
# path to file
filePathIdentifiers <- paste0( getwd(), "/data-raw/Lipidomics Key and Weights Goodpaster KZB_identifiable.xlsx")

# load file
identifiersDF <- read_excel(filePathIdentifiers)

# clean names to rename columns to be R friendly
identifiersDF <- clean_names(identifiersDF)

# Make tube_id character
identifiersDF$tube_id <- as.character(identifiersDF$tube_id)

# Combine identifiers with data
lipidomicsDF <- left_join(lipidomicsDF, identifiersDF, by = c("sampleNumber" = "tube_id"))

# Split pid column into an id and a time column
lipidomicsDF <- separate(lipidomicsDF, pid, into = c("id", "time"), sep = " ", extra = "merge")

# Make time, lipidClass, id and group categorical variables
lipidomicsDF$time <- factor(lipidomicsDF$time, levels = c("Pre", "Post")) # sort by pre and post
lipidomicsDF$lipidClass <- factor(lipidomicsDF$lipidClass)
lipidomicsDF$id <- factor(lipidomicsDF$id)
lipidomicsDF$group <- factor(lipidomicsDF$group)
lipidomicsDF$lipidComposition <- factor(lipidomicsDF$lipidComposition)

# Remove PBIS rows
lipidomicsDF <- lipidomicsDF %>%
  filter(id != "PBIS")
```

### Quantification limits

Values are copied from the lipidomics Excel file, "2022Mar Goodpaster Results.xlsx"

```{r}
detection_limits <- data.frame(
  lipidclasses = c("SPH", "AC", "SPM", "PG", "LPG", "PI", "LPI", "PS", "LPS", "PA", "PE", "LPE", "PC", "LPC", "1,3-DG", "1,2-DG", "Cer", "dhCer", "GluCer", "LacCer", "GalCer", "TAG"),
  LLOQ = c(0.08, 0.16, 1.2, 0.6, 0.03, 2.5, 1, 2.5, 0.05, 0.1, 2.5, 1, 7, 3, 0.34, 0.68, 0.25, 0.05, 0.1, 0.2, 0.1, 10),
  ULOQ = c(320, 640, 4800, 2400, 100, 10000, 4000, 10000, 200, 400, 10000, 4000, 28000, 12000, 1360, 2720, 1000, 200, 400, 800, 400, 40000)
)
```

Make column to denote if measurement is within (0), below LLOQ (1), above ULOQ (2) or above ULOQ \* the defined discard factor (3). Values that are discarded are made Na.

```{r}
limitFunction <- function(lipidomicsDF, detection_limits){
  # Initialize the 'within_threshold' column
  lipidomicsDF$within_threshold <- NA
  
  # Loop through each row in lipidomicsDF
  for (i in 1:nrow(lipidomicsDF)) {
    # Retrieve the current lipidClass and pmol value
    current_lipidClass <- lipidomicsDF$lipidClass[i]
    current_pmol <- lipidomicsDF$pmol[i]
    
    # Find matching LLOQ and ULOQ values from detection_limits
    current_LLOQ <- detection_limits$LLOQ[detection_limits$lipidclasses == current_lipidClass]
    current_ULOQ <- detection_limits$ULOQ[detection_limits$lipidclasses == current_lipidClass]
    
    # Check the pmol value against LLOQ and ULOQ and assign the 'within_threshold'
    if (is.na(current_pmol) | length(current_LLOQ) == 0 | length(current_ULOQ) == 0) {
      lipidomicsDF$within_threshold[i] <- NA # Assign NA if there's an NA value in pmol or LLOQ/ULOQ cannot be found
    } else if (current_pmol < current_LLOQ) {
      lipidomicsDF$within_threshold[i] <- 1 # Below LLOQ
    } else if (current_pmol > (current_ULOQ * LLOQ_discard_factor)) { # Above value to be discarded
      lipidomicsDF$within_threshold[i] <- 2
      # lipidomicsDF$pmol[i] <- NA 
    } else if (current_pmol > current_ULOQ) {
      lipidomicsDF$within_threshold[i] <- 2 # Above ULOQ
    } else {
      lipidomicsDF$within_threshold[i] <- 0 # Within the threshold
    }
  }
  return (lipidomicsDF)
}

lipidomicsDF <- limitFunction(lipidomicsDF, detection_limits)
```

### Weight normalization

**Weight normalization**

```{r}
lipidomicsDF$pmol_mg <- lipidomicsDF$pmol / lipidomicsDF$equiv_weight_extracted
```

### Outlier handling

Outliers are defined based on two criteria: 1) Outside "outlier_IQR_factor" x the IQR for all *non-zero* measurements for a lipidcomposition within a lipidclass. 2) Outside "outlier_IQR_factor" x the IQR for the post - pre change for all measurements within lipidcomposition and lipidclass.

A new column called "... \_imp" is created, where outlier values are replaced with the median for all values within lipidcomposition and class.

```{r}
define_outliers <- function(df, value_col, outlier_col_name){
  
  # Make a outlier col name for change and for composition
  composition_outlier_name <- paste0(outlier_col_name, "_composition")
  change_outlier_name <- paste0(outlier_col_name, "_change")
  
  # Make dynamic column name for difference
  dyn_difference_name <- paste0(value_col, "_abs_delta")
  
  # Make column name for imputed data
  dyn_imputed_name <- paste0(value_col, "_imp")
  
  
  # Calculate the abseloute differences to treat an increase and a decrease similarily
  difference_df <- lipidomicsDF %>%
    select(id, lipidClass, lipidComposition, time, !!sym(value_col)) %>%
    group_by(id, lipidClass, lipidComposition) %>%
    spread(key = time, value = !!sym(value_col)) %>%
    mutate(!!dyn_difference_name := abs(Post - Pre)) %>%
    # Select only the necessary columns for the join
    select(id, lipidClass, lipidComposition, !!sym(dyn_difference_name)) %>% 
    ungroup()
  
  
  # Join the differences back to the original dataframe
  df <- lipidomicsDF %>%
    left_join(difference_df, by = c("id", "lipidClass", "lipidComposition"))
  
  # Create NA columns
  df[[outlier_col_name]] <- NA
  df[[change_outlier_name]] <- NA
  df[[composition_outlier_name]] <- NA
  
  # Loop through each unique class and composition
  for (class in unique(df$lipidClass)){
    for (comp in unique(df$lipidComposition[df$lipidClass == class])){
      
      
      # Used as an imputation for outlier
      median_value <- median(df[[value_col]][df$lipidClass == class & df$lipidComposition == comp & df$pmol_mg > 0],na.rm = TRUE)
      
      # Identify indices for current class and composition
      indices <- which(df$lipidClass == class & df$lipidComposition == comp)
      
      # To not double count the same values for change pre to post, only pre is used
      indices_change <- which(df$lipidClass == class & df$lipidComposition == comp & df$time == "Pre")
      
      # Calculate the Q1, Q3, and IQR for the current subgroup
      subset_values <- df[[value_col]][indices]
      positive_values <- subset_values[subset_values > 0]
      
      Q1 <- quantile(positive_values, 0.25, na.rm = TRUE)
      Q3 <- quantile(positive_values, 0.75, na.rm = TRUE)
      IQR <- Q3 - Q1
      
      Q1_change <- quantile(df[[dyn_difference_name]][indices_change], 0.25, na.rm = TRUE)
      Q3_change <- quantile(df[[dyn_difference_name]][indices_change], 0.75, na.rm = TRUE)
      IQR_change <- Q3_change - Q1_change
      
      
      # Define upper bounds
      upper_bound <- Q3 + (outlier_IQR_factor * IQR)
      upper_bound_change <- Q3_change + (outlier_IQR_factor * IQR_change)
      
      # Update the 'outlier' column based on calculated bounds based on outlier toggle found in project settings
      if (outlier_remove == TRUE){
        df[[composition_outlier_name]][indices] <- df[[value_col]][indices] > upper_bound
        df[[change_outlier_name]][indices] <- df[[dyn_difference_name]][indices] > upper_bound_change
      }else{
        df[[composition_outlier_name]][indices] <- FALSE
        df[[change_outlier_name]][indices] <- FALSE
      }
      
      # Add a outlier column with TRUE values if both of the above outlier cols are TRUE
      for (ind in indices){
        
        df[[outlier_col_name]][ind] <- df[[composition_outlier_name]][ind] & df[[change_outlier_name]][ind]
        
        # Add col with imputed values to fill in outliers
        
        ifelse(df[[outlier_col_name]][ind] == TRUE,
               df[[dyn_imputed_name]][ind] <- median_value,
               df[[dyn_imputed_name]][ind] <- df[[value_col]][ind])
      }
    }
  }
  
  # Only make highest value within each composition and class stay TRUE as an outlier
  df <- df %>%
    filter(sampleNumber != 66) %>% # Filter out sample 66, as it is removed
    group_by(lipidComposition, lipidClass) %>%
    mutate(
      max_value = max(.data[[value_col]], na.rm = TRUE),
      outlier = if_else(.data[[value_col]] == max_value, outlier, FALSE)
    ) %>%
    select(-max_value) %>% 
    ungroup()
  
  
  return(df)
}

## Run function

lipidomicsDF <- define_outliers(df = lipidomicsDF,
                                value_col = "pmol_mg",
                                outlier_col_name = "outlier")

# # On log adjusted
#  lipidomicsDF <- define_outliers(df = lipidomicsDF,
#                                  value_col = "pmol_mg_log",
#                                  outlier_col_name = "outlier_log")


```

### Sample removal

```{r}
##### Manual removal #####

# Subject MG034 POST (Tube 66)
# Reason: The post value is removed as as TAG values are unnaturally high strongly suggesting IMAT contamination in the sample. As other lipids either directly or through the weight normalization would be affected, the post-measurement point is removed.

lipidomicsDF <- lipidomicsDF[!lipidomicsDF$sampleNumber == 66,]

# MG034 PRE (Tube 65) is removed too for the same individual
lipidomicsDF <- lipidomicsDF[!lipidomicsDF$sampleNumber == 65,]
```



### Ratios and saturation

Make saturation columns, where first column is defined by the number of double bonds in the first lipid, and the second column is defined by the number of double bonds in the second lipid. Also make a column to define ether bonds in the lipidcomposition.

```{r}
# Make saturation columns and ether bond column
lipidomicsDF <- lipidomicsDF %>%
  
  # Convert factors to character if not already
  mutate(lipidComposition = as.character(lipidComposition)) %>%
  # Create new columns for sat_level_1, sat_level_2, and count of 'e'
  mutate(
    sat_level_1 = sapply(regmatches(lipidComposition, gregexpr("(?<=:)(\\d+)", lipidComposition, perl = TRUE)), `[`, 1),
    sat_level_2 = sapply(regmatches(lipidComposition, gregexpr("(?<=:)(\\d+)", lipidComposition, perl = TRUE)), `[`, 2),
    ether_bond = sapply(lipidComposition, function(x) sum(gregexpr("e", x)[[1]] > 0))  # Correctly count occurrences of 'e'
  ) %>%
  # Handle cases where "di" is present in lipidComposition
  mutate(
    sat_level_2 = ifelse(grepl("di", lipidComposition) & is.na(sat_level_2), sat_level_1, sat_level_2)
  ) %>%
  # Ensure sat_level_2 is NA where there is no second match and no "di"
  mutate(sat_level_2 = ifelse(is.na(sat_level_2), NA, sat_level_2))

# Summarize saturation levels by id and lipidClass for each level of saturation.
summarized_saturations <- lipidomicsDF %>%
  group_by(id, time, lipidClass) %>%
  summarize(
    class_sat_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 0 & (sat_level_2 == 0 | is.na(sat_level_2))], na.rm = TRUE),
    class_unsat1_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 1 & (sat_level_2 <= 1 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 == 0 & sat_level_2 == 1], na.rm = TRUE),
    class_unsat2_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 2 & (sat_level_2 <= 2 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 2 & sat_level_2 == 2], na.rm = TRUE),
    class_unsat3_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 3 & (sat_level_2 <= 3 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 3 & sat_level_2 == 3], na.rm = TRUE),
    class_unsat4_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 4 & (sat_level_2 <= 4 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 4 & sat_level_2 == 4], na.rm = TRUE),
    class_unsat5_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 5 & (sat_level_2 <= 5 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 5 & sat_level_2 == 5], na.rm = TRUE),
    class_unsat6_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 6 & (sat_level_2 <= 6 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 6 & sat_level_2 == 6], na.rm = TRUE),
    
    class_no_ether_pmol_mg = sum(pmol_mg_imp[ether_bond == 0], na.rm = TRUE),
    class_ether_pmol_mg = sum(pmol_mg_imp[ether_bond == 1], na.rm = TRUE),
    
    .groups = 'drop'
  ) %>% 
  ungroup()

# Prepare the main data for joining
lipidomicsDF_saturation <- lipidomicsDF %>%
  select(id, time, lipidClass, group) %>%
  left_join(summarized_saturations, by = c("id", "time", "lipidClass")) %>% 
  distinct(id, time, lipidClass, group, class_sat_pmol_mg, class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, class_no_ether_pmol_mg, class_ether_pmol_mg)

# Calculate ratios
lipidomicsDF_saturation <- lipidomicsDF_saturation %>%
  rowwise() %>% 
  mutate(
    unsat_proportion = sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, na.rm = TRUE) / sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg,class_sat_pmol_mg, na.rm = TRUE),
    
    sat_proportion = sum(class_sat_pmol_mg, na.rm = TRUE) / sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, class_sat_pmol_mg, na.rm = TRUE),
    
    unsat_mono_proportion = sum(class_unsat1_pmol_mg, na.rm = TRUE) / sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, class_sat_pmol_mg, na.rm = TRUE),
    
    unsat_poly_proportion = sum(class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, na.rm = TRUE) / sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, class_sat_pmol_mg, na.rm = TRUE),
    
    
    ether_bond_proportion = sum(class_ether_pmol_mg, rm.na = TRUE) / sum(class_no_ether_pmol_mg, class_ether_pmol_mg, na.rm = TRUE)
  )


# Check sum of pmol_mg
lipidomicsDF_saturation_sum <- lipidomicsDF_saturation %>%
  rowwise() %>%
  mutate(sum_pmol_mg = sum(c(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg,
                             class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg,
                             class_sat_pmol_mg), na.rm = TRUE)) %>%
  ungroup()

```

**Add PC/PE ratio** Outliers are handled by calculating from imputed values as the PE and PC classes are summed. As they are analysed on a lipid class level, Outlier status is therefore set to FALSE.

```{r}
add_ratio_lipidomics <- function (lipidomicsDF)
{
  
  # Filter for PE and PC lipid classes and summarize their pmol values
  sums_df <- lipidomicsDF %>%
    filter(lipidClass %in% c("PE", "PC")) %>%
    group_by(id, time, sampleNumber, group, wet_weight, lyphilized_weight, volume_of_homogenate_ul, equiv_weight_extracted, lipidClass) %>%
    summarise(
      sum_pmol_mg = sum(pmol_mg_imp),
      .groups = "drop"
    )
  
  # Pivot the data to wide format after summarization
  sums_wide <- sums_df %>%
    pivot_wider(names_from = lipidClass, values_from = sum_pmol_mg)
  
  # Calculate the PC/PE ratio
  ratios_df <- sums_wide %>%
    mutate(lipidClass = "PC.PE",
           lipidComposition = "ratio",
           pmol = NA_real_,
           pmol_mg = PC / PE,
           within_threshold = NA) %>%
    select(-PE, -PC)# Remove intermediate PE and PC columns
  
  # Ensure matching column structure with the original dataframe
  # For columns not included in ratios_df, add them as NAs
  missing_cols <- setdiff(names(lipidomicsDF), names(ratios_df))
  for(col in missing_cols) {
    ratios_df[[col]] <- NA
  }
  
  # Reorder columns to match the original dataframe exactly
  ratios_df <- ratios_df[names(lipidomicsDF)]
  
  # Fill in the imputed column
  ratios_df$pmol_mg_imp <- ratios_df$pmol_mg
  
  # Set outlier status to FALSE as calculated from non-outliers
  ratios_df$outlier <- FALSE
  
  # Bind the rows to include PE:PC ratio ratios in the original dataframe
  lipidomicsDF <- bind_rows(lipidomicsDF, ratios_df)
  
  return(lipidomicsDF)
}

lipidomicsDF <- add_ratio_lipidomics(lipidomicsDF = lipidomicsDF)
```

**Add Cer 16:0 / Cer 24:0 ratio** Outliers are handled by filtering out outlier data in the function below

```{r}
add_ratio_lipidomics <- function (lipidomicsDF)
{
  workingDF <- lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),] %>%
    filter(lipidClass %in% c("Cer") & lipidComposition %in% c("16:0", "24:0"))
  
  # Set irrelevant columns to NA before pivoting
  #workingDF <- workingDF %>%
  #  mutate(pmol = NA_real_,
  #         pmol_mg_PrePost_delta = NA_real_,
  #         pmol_mg_imp = NA_real_)
  
  # Update the outlier information within the workingDF without summarizing
  workingDF <- workingDF %>%
    group_by(id, time, group) %>%
    mutate(
      outlier = any(outlier, na.rm = TRUE),
      outlier_change = any(outlier_change, na.rm = TRUE),
      outlier_composition = any(outlier_composition, na.rm = TRUE),
      outlier_log = any(outlier, na.rm = TRUE),
      outlier_change_log = any(outlier_change, na.rm = TRUE),
      outlier_composition_log = any(outlier_composition, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    select(outlier, outlier_change, outlier_composition, outlier_log, outlier_change_log, 
           outlier_composition_log, pmol_mg, group, time, id, sampleNumber, 
           lipidClass, lipidComposition)
  
  
  # Pivot the data to wide format
  wideDF <- workingDF %>%
    group_by(id, time, group, lipidComposition) %>%
    pivot_wider(
      names_from = lipidComposition,
      values_from = pmol_mg,
      values_fill = list(pmol_mg = NA)  # Fills missing data
    )
  
  # Calculate the ratio
  ratios_df <- wideDF %>%
    mutate(lipidClass = "Cer ratio",
           lipidComposition = "16:0 24:0",
           pmol = NA_real_,
           pmol_mg = `16:0` / `24:0`,
           within_threshold = NA) %>%
    select(sampleNumber, lipidComposition, lipidClass, id, time, group, pmol_mg, outlier_composition, outlier_change, outlier)# Remove intermediate PE and PC columns
  
  # Ensure matching column structure with the original dataframe
  # For columns not included in ratios_df, add them as NAs
  missing_cols <- setdiff(names(lipidomicsDF), names(ratios_df))
  for(col in missing_cols) {
    ratios_df[[col]] <- NA
  }
  
  # Reorder columns to match the original dataframe exactly
  ratios_df <- ratios_df[names(lipidomicsDF)]
  
  # Fill out imputed col (no outliers exist, as input data is cleaned)
  ratios_df$pmol_mg_imp <- ratios_df$pmol_mg
  
  # Bind the rows to the end of the lipidomicsDF
  lipidomicsDF <- bind_rows(lipidomicsDF, ratios_df)
  
  return(lipidomicsDF)
}
# Run function; nb. only non-outlier values are used
lipidomicsDF <- add_ratio_lipidomics(lipidomicsDF = lipidomicsDF)
```

**Sort data**

```{r}
# Sort the dataframe by 'id' and 'time'
lipidomicsDF <- lipidomicsDF %>%
  arrange(id, time)

### Correct sorting of AC
# Function to add leading zeros to single-digit numbers
add_leading_zero <- function(lipid) {
  gsub("\\b(\\d):", "0\\1:", lipid)
}

# Function to remove leading zeros from numbers
remove_leading_zero <- function(lipid) {
  gsub("\\b0(\\d):", "\\1:", lipid)
}

# Add leading zeros only for lipidClass "AC"
lipidomicsDF$lipidComposition <- ifelse(
  lipidomicsDF$lipidClass == "AC", 
  add_leading_zero(lipidomicsDF$lipidComposition), 
  lipidomicsDF$lipidComposition
)

# Find and sort all lipidClass-lipidComposition
unique_combinations <- lipidomicsDF %>%
  distinct(lipidClass, lipidComposition) %>%
  arrange(lipidClass, lipidComposition)

# Remove leading zeros only for lipidClass "AC"
unique_combinations$lipidComposition <- ifelse(
  unique_combinations$lipidClass == "AC", 
  remove_leading_zero(unique_combinations$lipidComposition), 
  unique_combinations$lipidComposition
)

lipidomicsDF$lipidComposition <- ifelse(
  lipidomicsDF$lipidClass == "AC", 
  remove_leading_zero(lipidomicsDF$lipidComposition), 
  lipidomicsDF$lipidComposition
)
```

**Define unique lipid classes**

```{r}
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
```

### Log transform
**Log transform** Log transform the weight normalized lipidomics data. 0.00001 is added to all values to avoid zores

```{r}
# Transform and add a small constant (+1) to avoid log(0)
lipidomicsDF <- lipidomicsDF %>%
  mutate(pmol_mg_log = log(pmol_mg + 0.00001))
```

## Mirage data

**Load from "FINAL MIRAGE DATASET.xlsx"**

!!! DUPLICATE IDS: "MG023" and "MG019" both are duplicates that appear with same group as in id from Pittsburg and TRI. Assumption: All samples are from TRI if not specified otherwise. Therefore, the Excel file "FINAL MIRAGE DATASET.xlsx", sheet "Not Imputed-Clean" was changed to make the merge work. All changes are marked with red text.

```{r}
# path to file
file_path_endpoints <- paste0( getwd(), "/data-raw/FINAL MIRAGE DATASET.xlsx")

# load file
mirage_data <- read_excel(file_path_endpoints, sheet = "Not Imputed-Clean")

# clean names
mirage_data <- clean_names(mirage_data)

# separate pid into id and site
mirage_data <- separate(mirage_data, pid, into = c("id", "site"), sep = "-", extra = "merge")

# Remove redundant columns
mirage_data <- select(mirage_data, -study_center)


# Adjust column names, and move pre and post to the end of the name
# Loop through each column name in mirage_data
new_col_names <- sapply(names(mirage_data), function(col_name) {
  # Check if "_pre" is in the column name
  if (grepl("_pre", col_name)) {
    col_name <- gsub("_pre", "", col_name) # Remove "_pre"
    col_name <- paste0(col_name, "_pre") # Add "_pre" to the end
  }
  # Check if "_post" is in the column name
  if (grepl("_post", col_name)) {
    col_name <- gsub("_post", "", col_name) # Remove "_post"
    col_name <- paste0(col_name, "_post") # Add "_post" to the end
  }
  return(col_name)
})

# Update the column names of mirage_data
names(mirage_data) <- new_col_names
```

**Load physical activity data from "MIRAGE_PA_Ole.xlsx" recived from Elvis Alvarez on May 15th**
```{r}
# Path to file
load_path <- paste0( getwd(), "/data-raw/MIRAGE_PA_Ole.xlsx")

# Load xlsx file
mirage_pa <- read_excel(load_path)

# Create an id column based on characters before last "_"
mirage_pa$id <- sub("_[^_]*$", "", mirage_pa$PID...1)

# Rename cols
names(mirage_pa)[names(mirage_pa) == "TDPA_PRE"] <- "tdpa_pre"
names(mirage_pa)[names(mirage_pa) == "TDPA_POST"] <- "tdpa_post"

# Make lower case
names(mirage_pa) <- tolower(names(mirage_pa))

# Merge the data frames based on the 'id' column, selecting only the necessary columns from mirage_pa
mirage_data <- merge(mirage_data, mirage_pa[, c("id", "tdpa_pre", "tdpa_post")], by = "id", all.x = TRUE)

# Remove mirage_pa
rm(mirage_pa)
```


**Adjust units in some columuns**
```{r}
# Cholesterol from mg/dl to mmol/l
mirage_data$cholesterol_pre <- mirage_data$cholesterol_pre / 38.67
mirage_data$cholesterol_post <- mirage_data$cholesterol_post / 38.67
mirage_data$cholesterol_abs_ch <- mirage_data$cholesterol_abs_ch / 38.67

mirage_data$hdl_pre <- mirage_data$hdl_pre / 38.67
mirage_data$hdl_post <- mirage_data$hdl_post / 38.67
mirage_data$hdl_abs_ch <- mirage_data$hdl_abs_ch / 38.67

mirage_data$ldl_pre <- mirage_data$ldl_pre / 38.67
mirage_data$ldl_post <- mirage_data$ldl_post / 38.67
mirage_data$ldl_abs_ch <- mirage_data$ldl_abs_ch / 38.67

# Triglycerides
mirage_data$triglycerides_pre <- mirage_data$triglycerides_pre / 88.57
mirage_data$triglycerides_post <- mirage_data$triglycerides_post / 88.57
mirage_data$triglycerides_abs_ch <- mirage_data$triglycerides_abs_ch / 88.57

```



**Calculate additional rows**

```{r}
mirage_data$tdee_kcal_24hr_ffm_pre <- mirage_data$tdee_kcal_24hr_pre / mirage_data$lean_mass_dxa_pre

# Asses moderate to vigorous physical activity by combining minutes in moderate (mpa) with vigerous activity (vpa) 
mirage_data$mvpa_mins_day_pre <- mirage_data$mpa_mins_day_pre + mirage_data$vpa_mins_day_pre
mirage_data$mvpa_mins_day_post <- mirage_data$mpa_mins_day_post + mirage_data$vpa_mins_day_post

```


### Select variables & long format

**pre-post variables** Define variables of interest for pre-post delta correlations against lipids.

```{r}
# List with pre-post variables of interest
glycemicControl <- list(
  #c("rd_ss1kg_ffm_insulin_pre", "rd_ss1kg_ffm_insulin_post", "Glucose RD per FFM and insulin (?)"),
  c("rd_ss2kg_ffm_insulin_pre", "rd_ss2kg_ffm_insulin_post", "Glucose RD per kgFFM per insulin"),
  c("hgb_a1c_pre", "hgb_a1c_post", "HbA1c (mmol / mol?)"),
  c("homair_pre", "homair_post", "HOMAIR (abr unit)")
  #c("egp0kg_ffm_pre", "egp0kg_ffm_post", "Endogenous glucose production (?)"),
  #c("egpss1kg_ffm_pre", "egpss1kg_ffm_post", "Endogenous glucose production (?)"),
  #c("egpss2kg_ffm_pre", "egpss2kg_ffm_post", "Endogenous glucose production (?)")
)

mitochondria <- list(
  #c("at_pmax_p_mrs_pre", "at_pmax_p_mrs_post", "ATP max (?)"),
  c("pcr_p_mrs_pre", "pcr_p_mrs_post", "PCR recovery? (?)"),
  c("max_oxphos_pre", "max_oxphos_post", "Max oxidative phosphorylation (?)")
  #c("max_ets_pre", "max_ets_post", "Max ETS? (?)"),
  #c("le_pre", "le_post", "Leak? (?)"),
  # c("pe_pre", "pe_post", "PE? (?)")
)

bodycomposition <- list( # SHOULD FFM ETC. WEIGHTs BE NORMALISED TO TOTAL WEIGHT?
  c("weight_pre", "weight_post", "Body mass (kg)" ),
  #c("leg_lean_mass_pre", "leg_lean_mass_post", "Leg lean mass (kg?)" ),
  c("fat_mass_dxa_pre", "fat_mass_dxa_post", "Fat mass (kg?)"),
  c("lean_mass_dxa_pre", "lean_mass_dxa_post", "Lean body mass (kg?)"),
  #c("ffm_dxa_pre", "ffm_dxa_post", "Fat free mass (kg?)"),
  #c("thigh_sat_g_pre", "thigh_sat_g_post", "Thigh SAT, (g)"),
  #c("thigh_imat_g_pre", "thigh_imat_g_post", "Thigh IMAT (g)"),
  c("percent_imat_pre", "percent_imat_post", "Thigh IMAT fraction (%)")
  #c("thigh_muscle_g_pre", "thigh_muscle_g_post", "Thigh muscle (g)")
  #c("abdomen_vat_g_pre", "abdomen_vat_g_post", "Adbominal VAT (g)"),
  #c("type_iia_iix_pre", "type_iia_iix_post", "Fibertype? (?)")
)

blood <-  list(
  c("vldl_pre", "vldl_post", "VLDL (mmol / l)"),
  c("ldl_pre", "ldl_post", "LDL (mmol / l"),
  c("hdl_pre", "hdl_post", "HDL (mmol / l)"),
  c("cholesterol_pre", "cholesterol_post", "Total cholesterol (mmol / l)"),
  c("triglycerides_pre", "triglycerides_post", "Triglycerides (mmol / l)"),
  c("plasma_ffabg_pre", "plasma_ffabg_post", "FFA (mmol / l)")
)

physicalActivity <- list(
  #c("daily_steps_steps_24hr_pre", "daily_steps_steps_24hr_post", "Activity (steps / day)"),
  c("tdpa_pre", "tdpa_post", "Time per day (min / day)"),
  #c("vo2abs_pre", "vo2abs_post", "Oxygen uptake (l / min)"),
  c("vo2kg_ffm_pre", "vo2kg_ffm_post", "Oxygen~uptake~(l %.% min^{-1} %.% kgFFM^{-1})"),
  #c("x4m_walk_pre", "x4m_walk_post", "Time? (s)"),
  #c("step_test_pre", "step_test_post", "Steps? (?)"),
  #c("x1rm_pre", "x1rm_post", "Stength (?)"),
  #c("peak_torque120_pre", "peak_torque120_post", "Torque (Nm?)"),
  c("age_pre", "age_post", "Age (years)")
)


mirage_ch_vars <- list(
  glycemicControl = glycemicControl,
  mitochondria = mitochondria,
  bodycomposition = bodycomposition,
  #blood = blood,
  physicalActivity = physicalActivity
)


```

**Cross-sectional variables** Define variables of interest to compare between all individuals at pre

Post values are added to also make correlations on the post part of things.
```{r}
# Glycemic Control
glycemicControl <- c("rd_ss2kg_ffm_insulin_pre", "hgb_a1c_pre", "rd_ss2kg_ffm_insulin_post", "hgb_a1c_post")

# Mitochondria
mitochondria <- c("pcr_p_mrs_pre", "max_oxphos_pre", "pcr_p_mrs_post", "max_oxphos_post")

bodycomposition <- c("bmi_pre", "percent_imat_pre", "bmi_post", "percent_imat_post", "percent_fat_mass_pre", "percent_fat_mass_post")

# Blood
blood <- c("vldl_pre", "ldl_pre", "hdl_pre", "cholesterol_pre", "triglycerides_pre", "plasma_ffabg_pre")

# Physical activity + Age
physicalActivity <- c("tdpa_pre", "vo2kg_ffm_pre", "age_pre", "tdpa_post", "vo2kg_ffm_post") #, "vo2abs_pre", "vo2kg_ffm_pre", "age_pre")


# Combining all the "_pre" variables into a single list for mirage_crossSectional_vars, excluding "age_pre" from all but the physicalActivity list
mirage_crossSectional_vars <- list(
  glycemicControl = glycemicControl,
  mitochondria = mitochondria,
  bodycomposition = bodycomposition,
  # blood = blood,
  physicalActivity = physicalActivity
)
```

**Mirage long format** Convert Mirage dataset with selected variables into long format with selected Pre \ Post varibles

```{r}
# Flatten the lists into a single vector
columns_to_merge <- mirage_ch_vars_flat <- unlist(unlist(lapply(mirage_ch_vars, function(category) {
  lapply(category, function(item) item[1:2])
}), recursive = FALSE), use.names = FALSE)


# Select columns from 'mirage_data' including the 'id' column
mirage_data_subset <- mirage_data[c("id", columns_to_merge)]

# Filter out the ids based on the ids in lipidomicsDF
mirage_data_subset <- mirage_data_subset %>%
  filter(id %in% lipidomicsDF$id)

# Transform 'mirage_data_subset' to long format
mirage_data_long_ch <- pivot_longer(
  mirage_data_subset,
  cols = -id, # Exclude 'id' from the pivoting
  names_to = c(".value", "time"), # Separate original column name into variable name and time
  names_pattern = "(.+)_(pre|post)" # Pattern to split the variable names and time
)

# Adjust the 'time' column in 'mirage_data_long_ch' to match 'Pre' and 'Post'
mirage_data_long_ch <- mirage_data_long_ch %>%
  mutate(time = case_when(
    time == "pre" ~ "Pre",
    time == "post" ~ "Post",
    TRUE ~ time # Keeps the original value if it's neither 'pre' nor 'post'
  ))

# Remove rows where all measurements are NA
mirage_data_long_ch <- mirage_data_long_ch %>%
  group_by(id, time) %>%
  filter(!all(is.na(age)))
```

# Saturation analysis
## Pre-post

### Mixed model

Should be identical to how statistics are calculated for lipidclass. Data must be condensed to not include lipidComp, as this will give duplicates

```{r}
# Set the max number of observations that the emmeans package will handle. Lower number shorter computation times, larger number, more precise CI and p-value estimates
emm_options(pbkrtest.limit = 6000) # change to 5000 after code works

mixedmodel_pre_post_sat <- function(dataset, response_var, lipidclass, lipidcomposition = NULL) {
  
  print( paste0("Analysing ", lipidclass, "..."))
  
  # Filter dataset
  data_to_model <- filter(dataset, lipidClass == lipidclass)
  
  # Check number of non-zero rows
  non_zero_rows <- data_to_model %>% 
    filter(!!sym(response_var) > 0) %>% 
    nrow()
  
  # only proceed if number of non zero rows is above cutoff
  if (non_zero_rows < analysis_cutoff){
    results_list <- list(
      lipidClass = as.character(lipidclass),
      lipidComposition = as.character(lipidcomposition),
      slope_results = NA_real_,
      prepost_results = NA_real_)
    
    results_list <- setNames(list(results_list), lipidclass)
    
    return(results_list)
  } else {
    
    
    # Prepare factors
    data_to_model$group <- factor(data_to_model$group, levels = c("HED", "DIWL", "WLEX"))
    data_to_model$time <- factor(data_to_model$time, levels = c("Pre", "Post"))
    
    # Make forumula
    model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id)"))
    
    # Try-catch block for model fitting
    tryCatch(
      {
        model <- lmer(model_formula,
                      data = data_to_model,
                      na.action = na.exclude)
        # Estimated marginal of means to get out slope and between groups statistics
        emm <- emmeans(model, ~ time * group)
        
        # Contrasts for differences in slopes between groups
        model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")
        
        model.slope.contrasts.results <- summary(model.slope.contrasts)
        
        # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
        model.slope.contrasts.results <- model.slope.contrasts.results %>%
          mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
          select(contrast, estimate, SE, df, t.ratio, p.value)
        
        # Pre, Post between group comparisons
        prepost.contrasts <- pairs(emm, adjust = "none")
        
        # Get results
        prepost.contrasts.results <- summary(prepost.contrasts)
        
        # Create results list
        results_list <- list(
          lipidClass = as.character(lipidclass),
          lipidComposition = as.character(lipidcomposition),
          slope_results = model.slope.contrasts.results,
          prepost_results = prepost.contrasts.results)
        
        # Name results list
        results_list <- setNames(list(results_list), lipidclass)
        
        return(results_list)
      },
      error = function(e) {
        results_list <- list(
          lipidClass = as.character(lipidclass),
          lipidComposition = as.character(lipidcomposition),
          slope_results = NA_real_,
          prepost_results = NA_real_)
        
        results_list <- setNames(list(results_list), lipidclass)
        
        return(results_list)
      }
    )
  }
}
# RUN FUNCTION
# Use map to iterate over lipid classes

unique_lipid_classes.noRatios <- unique_lipid_classes[!unique_lipid_classes == c("PC.PE", "Cer ratio")]

# Saturated
result.lipid.pre_post_sat <- map(unique_lipid_classes.noRatios, ~ mixedmodel_pre_post_sat(lipidomicsDF_saturation, "sat_proportion", .x))
# Unsaturated
result.lipid.pre_post_unsat <- map(unique_lipid_classes.noRatios, ~ mixedmodel_pre_post_sat(lipidomicsDF_saturation, "unsat_proportion", .x))
# Mono unsaturated
result.lipid.pre_post_mono_unsat <- map(unique_lipid_classes.noRatios, ~ mixedmodel_pre_post_sat(lipidomicsDF_saturation, "unsat_mono_proportion", .x))
# Poly unsaturated
result.lipid.pre_post_poly_unsat <- map(unique_lipid_classes.noRatios, ~ mixedmodel_pre_post_sat(lipidomicsDF_saturation, "unsat_poly_proportion", .x))

# Flatten list to make list appear with class names
result.lipid.pre_post_sat <- flatten(result.lipid.pre_post_sat)
result.lipid.pre_post_unsat <- flatten(result.lipid.pre_post_unsat)
result.lipid.pre_post_mono_unsat <- flatten(result.lipid.pre_post_mono_unsat)
result.lipid.pre_post_poly_unsat <- flatten(result.lipid.pre_post_poly_unsat)




####### Make data ready for plotting


prepare_sat_data_for_plotting <- function(result_data) {
  pvals_df <- data.frame()
  est_df <- data.frame()
  
  contrasts_prepost <- c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX")
  contrasts_slope <- c("Pre - Post : HED - DIWL", "Pre - Post : HED - WLEX", "Pre - Post : DIWL - WLEX")
  
  for (test_name in names(result_data)) {
    # Check if prepost_results and slope_results are not NA
    if (!is.na(result_data[[test_name]]$prepost_results[[1]][1])) {
      prepost_results <- result_data[[test_name]]$prepost_results
    } else {
      prepost_results <- data.frame(contrast = character(), p.value = numeric())
    }
    
    if (!is.na(result_data[[test_name]]$slope_results[[1]][1])) {
      slope_results <- result_data[[test_name]]$slope_results
    } else {
      slope_results <- data.frame(contrast = character(), p.value = numeric())
    }
    
    # Proceed with extraction
    prepost_pvals <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)
    
    slope_pvals <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)
    
    prepost_est <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    slope_est <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    
    # Combine values into single data
    # p-values
    combined_pvals <- c(prepost_pvals, slope_pvals)
    combined_pvals <- setNames(combined_pvals, c(contrasts_prepost, contrasts_slope))
    pvals_df <- rbind(pvals_df, cbind(lipid = test_name, t(as.data.frame(list(combined_pvals)))))
    
    # Estimates
    combined_est <- c(prepost_est, slope_est)
    combined_est <- setNames(combined_est, c(contrasts_prepost, contrasts_slope))
    est_df <- rbind(est_df, cbind(lipid = test_name, t(as.data.frame(list(combined_est)))))
  }
  
  # Select all columns after the first one to exclude lipid column
  corrected_cols <- names(pvals_df)[-1]
  
  # Remove rows where every column from the second column onwards contains NA
  pvals_df <- pvals_df[rowSums(is.na(pvals_df[, -1])) < (ncol(pvals_df) - 1), ]
  
  # Apply Benjamini-Hochberg correction and create new columns with the suffix "_BH_corrected"
  for (col in corrected_cols) {
    pvals_df[[paste0(col, " (corrected)")]] <- p.adjust(pvals_df[[col]], method = "BH")
  }
  
  # Reset row names to simple sequential numbers
  rownames(pvals_df) <- NULL
  rownames(est_df) <- NULL
  
  # Only keep rows in est_df where the lipid values match those in pvals_df
  est_df <- est_df[est_df$lipid %in% pvals_df$lipid, ]
  
  # Convert the columns to numeric
  # p-vals
  for (i in 2:ncol(pvals_df)) {
    if (!is.numeric(pvals_df[[i]])) {
      pvals_df[[i]] <- as.numeric(pvals_df[[i]])
    }
  }
  # estimates 
  for (i in 2:ncol(est_df)) {
    if (!is.numeric(est_df[[i]])) {
      est_df[[i]] <- as.numeric(est_df[[i]])
    }
  }
  
  # Combine the est and pvals dataframes into a list to be returned
  est_and_pvals <- list(p.vals = pvals_df, estimates = est_df)
  return(est_and_pvals)
}

# Prepare data for plotting lipid classes
est_and_p_sat <- prepare_sat_data_for_plotting(result.lipid.pre_post_sat)
est_and_p_unsat <- prepare_sat_data_for_plotting(result.lipid.pre_post_unsat)
est_and_p_mono_unsat <- prepare_sat_data_for_plotting(result.lipid.pre_post_mono_unsat)
est_and_p_poly_unsat <- prepare_sat_data_for_plotting(result.lipid.pre_post_poly_unsat)

```

### Scatter

```{r}
plot_pre_post_sat <- function(lipidomicsDF_saturation, lipid_class, p_val_df, y_label, save_folder, col_name) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF_saturation %>%
    filter(lipidClass == lipid_class & !is.na(time))
  
  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]
  
  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )
  
  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
  mean_data_class <- filtered_data %>%
    group_by(group, time) %>%
    summarise(mean_proportion = mean(!!sym(col_name), na.rm = TRUE), .groups = 'drop')
  
  # Set label height
  
  label_height <- max(filtered_data[[col_name]])*1
  
  # Create the plot
  plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
               levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = !!sym(col_name), group = interaction(id, group)
  )) +
    geom_line(aes(group = interaction(id, group), color = id), alpha = 0.9, linewidth = 0.1, position = position_nudge(x = 0.03)) +
    geom_point(aes(color = id), alpha = 0.5, position = position_nudge(x = 0.03)) +
    
    geom_boxplot(aes(group = interaction(group, time)),
                 width = 0.3, alpha = 0.2, outlier.shape = NA,
                 position = position_dodge(width = 0.75), color = "black"
    ) +
    geom_line(data = mean_data_class, aes(x = interaction(group, time, sep = " "), y = mean_proportion, group = group),color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
    scale_color_manual(values = rainbow(length(unique(filtered_data$id)))) +
    labs(title = lipid_class, 
         subtitle = annotation_pvals_slope, 
         y = y_label,
         x = "") +
    annotate("text", x = c(1.5, 3.5, 5.5), y = label_height, label = annotation_pvals_pre_post, size = 2) +
    theme_minimal() +
    theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
          legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
          legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
          plot.subtitle = element_text(size = 5, hjust = 0.5))
  
  # Define the filename and save the plot
  filename <- paste0(
    getwd() ,"/outputs/saturation/pre-post/scatter/",
    save_folder, "/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)
  
  cat("Plot saved as:", filename, "\n")
}

# RUN FUNCTION
# Loop to call the plotting function for each lipid class
unique_lipid_classes.noRatios <- unique_lipid_classes[!unique_lipid_classes == c("PC.PE", "Cer ratio")]

for (lipid_class in unique_lipid_classes.noRatios) {
  # Saturated
  plot_pre_post_sat(lipidomicsDF_saturation = lipidomicsDF_saturation, lipid_class = lipid_class, p_val_df = est_and_p_sat$p.vals, y_label = "Proportion of saturated lipids", save_folder = "saturated", col_name = "sat_proportion")
  # Unsaturated
  plot_pre_post_sat(lipidomicsDF_saturation = lipidomicsDF_saturation, lipid_class = lipid_class, p_val_df = est_and_p_unsat$p.vals, y_label = "Proportion of unsaturated lipids", save_folder = "unsaturated", col_name = "unsat_proportion")
  # Monounsaturated
  plot_pre_post_sat(lipidomicsDF_saturation = lipidomicsDF_saturation, lipid_class = lipid_class, p_val_df = est_and_p_mono_unsat$p.vals, y_label = "Proportion of mono unsaturated lipids", save_folder = "unsaturated_mono", col_name = "unsat_mono_proportion")
  # polyunsaturated
  plot_pre_post_sat(lipidomicsDF_saturation = lipidomicsDF_saturation, lipid_class = lipid_class, p_val_df = est_and_p_poly_unsat$p.vals, y_label = "Proportion of poly unsaturated lipids", save_folder = "unsaturated_poly", col_name = "unsat_poly_proportion")
}

```

### Heatmap

```{r}
heatmap_pre_post_sat <- function(result_data, overall_title){
  
  pvals_df <- result_data$p.vals
  estimates_df <- result_data$estimates
  
  # Select the specified columns for hm_data.p-vals matrix
  pvals_df <- pvals_df[ , c("lipid", "Pre HED - Post HED (corrected)", "Pre DIWL - Post DIWL (corrected)", 
                            "Pre WLEX - Post WLEX (corrected)", "Pre - Post : HED - DIWL (corrected)",
                            "Pre - Post : HED - WLEX (corrected)", "Pre - Post : DIWL - WLEX (corrected)")]
  
  # Set 'lipid' as row names
  rownames(pvals_df) <- pvals_df$lipid
  rownames(estimates_df) <- estimates_df$lipid
  
  # Remove the 'lipid' column
  pvals_df <- pvals_df[ , !(names(pvals_df) %in% c("lipid"))]
  estimates_df <- estimates_df[ , !(names(estimates_df) %in% c("lipid"))]
  
  # Rename columns by removing " (corrected)" from all column names in pvals_df
  colnames(pvals_df) <- gsub(" \\(corrected\\)", "", colnames(pvals_df))
  
  # Sort column names
  common_cols <- intersect(colnames(estimates_df), colnames(pvals_df))
  estimates_df <- estimates_df[, common_cols, drop = FALSE]
  pvals_df <- pvals_df[, common_cols, drop = FALSE]
  
  ### Divide dataframe based on lipid groups
  # Define lipid groups
  lipids_groups <- list(
    gr_all = c("TAG", "1,2-DG", "1,3-DG", "AC", "PC", "PC.PE ratio", "PE", "SPM", "SPH", "Cer", "dhCer", "GluCer", "LacCer", "GalCer", "LPC", "LPE", "LPG", "LPI", "LPS", "PA", "PS", "PG", "PI")
  )
  
  ### Divide dataframe based on lipid groups with lipid as row name
  filter_lipid_group_row <- function(data_frame, lipid_group) {
    
    # Create the pattern for matching lipid groups
    pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
    
    # Convert row names to a temporary column for sorting and filtering
    data_frame_with_lipid <- tibble::rownames_to_column(data_frame, var = "lipid")
    
    # Sort the dataframe by the temporary lipid column
    sorted_data_frame_with_lipid <- data_frame_with_lipid[order(data_frame_with_lipid$lipid), ]
    
    # Filter based on the pattern
    sorted_filtered_data_frame_with_lipid <- sorted_data_frame_with_lipid[grepl(pattern, sorted_data_frame_with_lipid$lipid), ]
    
    # Drop the temporary lipid column and return to original format
    rownames(sorted_filtered_data_frame_with_lipid) <- sorted_filtered_data_frame_with_lipid$lipid
    sorted_filtered_data_frame <- sorted_filtered_data_frame_with_lipid[ , !colnames(sorted_filtered_data_frame_with_lipid) %in% 'lipid', drop = FALSE]
    return(sorted_filtered_data_frame)
  }
  
  
  # Apply the filter function to each group and store the results in a lists
  # p-values
  pvals_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = pvals_df)
  
  # estimates
  estimates_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = estimates_df)
  
  # Convert all dataframes to matrices
  matrices_pvals <- lapply(pvals_gr_list, function(x) as.matrix(x))
  matrices_estimates <- lapply(estimates_gr_list, function(x) as.matrix(x))
  
  
  generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims, hm_title, hm_unit) {
    # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
    
    # Extract test_against by removing the first part (treatment group) and the first underscore
    # This joins back the remaining parts to form the full 'test_against' label
    colTitles <- c("Slope", "Pre vs Post")
    
    Heatmap(hm_matrix,
            name = hm_unit, # Sets the name of the color scale
            
            col = colorMap, # Use provided color map
            rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
            row_names_side = "left", # Position of row labels
            row_names_gp = gpar(fontsize = 7.5 ), # Change font size of row labels
            
            #column_split = rep(1:(ncol(hm_matrix) / 3), each = 3), # Splits the columns and names them
            column_title = hm_title,
            column_names_rot = 45, # Rotate column names for better readability
            column_names_gp = gpar(fontsize = 8, fontface = "bold"),
            column_title_side = "top", # Placement of the column titles
            column_title_gp = gpar(fontsize = 10, fontface = "bold"),
            #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
            
            border = TRUE, # Set border around the splits
            cluster_rows = FALSE, # Don't make clusters
            cluster_columns = FALSE, # Don't make clusters
            
            cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                if (p_val_matrix[i, j] < pLims$p1) {
                  grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                } else if (p_val_matrix[i, j] < pLims$p2) {
                  grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                } else if (p_val_matrix[i, j] < pLims$p3) {
                  grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                }
              }
            })
  }
  
  # Define color map for heatmap
  color_mapping_slope <- colorRamp2(c(-50, 0, 50), c("blue", "white", "red"))
  color_mapping_pre_post <- colorRamp2(c(-50, 0, 50), c("darkgreen", "white", "orange"))
  
  # Set p-value limits
  p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
  # Create a list for the heatmaps
  hm <- list()
  
  # Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
  for (i in 1:length(lipids_groups)) {
    # Generate slope and pre/post hm
    
    hm_slope <- generate_heatmap(matrices_estimates[[i]][,4:6]*100, matrices_pvals[[i]][,4:6], color_mapping_slope, p_value_limits, hm_title = "Slope ", hm_unit = "pp")
    hm_pre_post <- generate_heatmap(matrices_estimates[[i]][,1:3]*100, matrices_pvals[[i]][,1:3], color_mapping_pre_post, p_value_limits, hm_title = "Pre vs Post", hm_unit = "pp ")
    
    # Combine heat maps and store in list
    hm[[i]] <- hm_slope + hm_pre_post
    # Generate heatmap and store it in the list
  }
  
  # Define the path and name of your PDF file
  pdf_path <- paste0( getwd(), "/outputs/saturation/pre-post/heatmap/", overall_title, ".pdf")
  
  # Open a PDF device
  pdf(pdf_path, width = 8, height = 10)
  
  # Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
  for (i in 1:length (hm)){
    draw(hm[[i]], padding = unit(c(0, 0, 10, 0), "mm"))
  }
  
  # Add a common title
  grid.text(overall_title, x = unit(0.5, "npc"), y = unit(0.98, "npc"), 
            gp = gpar(fontsize = 14, fontface = "bold"))
  
  # Don't forget to close the device
  dev.off()
}

# Run function
heatmap_pre_post_sat (result_data = est_and_p_sat, overall_title = "Saturated")
heatmap_pre_post_sat (result_data = est_and_p_unsat, overall_title = "Unsaturated")
heatmap_pre_post_sat (result_data = est_and_p_mono_unsat, overall_title = "Mono unsaturated")
heatmap_pre_post_sat (result_data = est_and_p_poly_unsat, overall_title = "Poly unsaturated")
```

## Change correlations

```{r}
# Function to prepare data
prepare_and_combine_data <- function(lipidomicsData, pre_post_cols, mirageData, lipidclass, saturation_col) {
  
  # Filter lipidomics data
  lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, all_of(saturation_col))
  
  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = all_of(saturation_col), names_prefix = "proportion_of_") %>%
    relocate(id, .before = everything()) # Moves id to front
  
  # Calculate delta value
  lipidomics_wide$pp_change <- (lipidomics_wide$proportion_of_Post - lipidomics_wide$proportion_of_Pre) * 100
  
  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")
  
  # Loop through all lists
  for (j in 1:length(pre_post_cols)){
    for (g in 1:length (pre_post_cols[[j]])){
      pre_col <- pre_post_cols[[j]][[g]][1]
      post_col <- pre_post_cols[[j]][[g]][2]
      delta_col_name <- paste0(sub("_pre", "", pre_col), "_ch")
      
      # Calculate deltas
      combined_df <- combined_df %>%
        mutate(!!sym(delta_col_name) := as.numeric(.[[post_col]]) - as.numeric(.[[pre_col]]))
    }
  }
  # }
  # Convert specified columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))
  
  return(combined_df)
}

################### STATISTICS

# Define a function to compute correlations of change
correlation_of_change <- function(correlation_df, lipidomicsData, mirage_data_long_ch, mirage_variables_of_interest, lipidclass, saturation_type) {
  
  # Define lipidname
  lipidName <- lipidclass
  
  # Define lipid unit
  lipid_unit <- "pp_change"
  
  # Only run code if correlation df is not NA.
  # If, Na, assign NA values to all correlation results
  if (sum( !is.na(correlation_df[[lipid_unit]])) < analysis_cutoff){
    
    # Assign NA to all results
    correlation_results <- data.frame(
      lipid = lipidName,
      test_against = NA,
      pearson_r_all = NA,
      pearson_p_all = NA,
      spearman_rho_all = NA,
      spearman_p_all = NA,
      mixed_cor_all = NA,
      mixed_p_all = NA,
      pearson_r_HED = NA,
      pearson_p_HED = NA,
      spearman_rho_HED = NA,
      spearman_p_HED = NA,
      pearson_r_DIWL = NA,
      pearson_p_DIWL = NA,
      spearman_rho_DIWL = NA,
      spearman_p_DIWL = NA,
      pearson_r_WLEX = NA,
      pearson_p_WLEX = NA,
      spearman_rho_WLEX = NA,
      spearman_p_WLEX = NA
    )
  } else {
    
    # Initialize an empty data frame to store correlation results
    correlation_results <- data.frame(
      lipid = character(),
      test_against = character(),
      pearson_r_all = numeric(),
      pearson_p_all = numeric(),
      spearman_rho_all = numeric(),
      spearman_p_all = numeric(),
      mixed_cor_all = numeric(),
      mixed_p_all = numeric(),
      pearson_r_HED = numeric(),
      pearson_p_HED = numeric(),
      spearman_rho_HED = numeric(),
      spearman_p_HED = numeric(),
      pearson_r_DIWL = numeric(),
      pearson_p_DIWL = numeric(),
      spearman_rho_DIWL = numeric(),
      spearman_p_DIWL = numeric(),
      pearson_r_WLEX = numeric(),
      pearson_p_WLEX = numeric(),
      spearman_rho_WLEX = numeric(),
      spearman_p_WLEX = numeric()
    )
    
    # Loop over every mirage variables of interest
    for (j in 1:length(mirage_variables_of_interest)){
      for (g in 1:length (mirage_variables_of_interest[[j]])){
        test_against_name <- mirage_variables_of_interest[[j]][[g]][[1]]
        test_against_name_clean <- sub("_pre$", "", test_against_name)
        test_against_name <- sub("pre$", "ch", test_against_name)
        
        
        # Add new row to output df
        correlation_results <- add_row(correlation_results)
        
        # Identify the index of the current row
        current_row_index <- nrow(correlation_results)
        
        # Assign lipid name and test against to last row
        correlation_results$lipid[current_row_index] <- lipidName
        correlation_results$test_against[current_row_index] <- test_against_name
        
        # Perform Pearson and Spearman correlations for all data
        result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
        result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
        
        # Assign results the the results df
        correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
        correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
        correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
        correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p
        
        # Calculate correlations for each group
        for (current_group in unique(correlation_df$group)) {
          # Filter the dataframe for the current group
          correlation_df_group <- filter(correlation_df, group == current_group)
          
          # Perform Pearson and Spearman correlations for the current group
          result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
          result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
          
          # Dynamic assignment of results based on the current group
          pearson_r_col <- paste0("pearson_r_", current_group)
          pearson_p_col <- paste0("pearson_p_", current_group)
          spearman_rho_col <- paste0("spearman_rho_", current_group)
          spearman_p_col <- paste0("spearman_p_", current_group)
          
          correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
          correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
          correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
          correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
        }
        
        ### Below transformation to mixed model compatible format. Model is not run, as it does not work as intended, but structure may be relevant for future analysis.
        # Merge this transformed subset with 'lipidomicsData' based on 'id' and 'time'
        merged_data <- left_join(lipidomicsData, mirage_data_long_ch, by = c("id", "time"))
        
        # Prepare lipidomics data
        merged_data_filtered <- filter(merged_data, lipidClass == lipidclass)
        
        # Ensure 'time' and 'group' are factors
        merged_data_filtered$time <- as.factor(merged_data_filtered$time)
        merged_data_filtered$group <- as.factor(merged_data_filtered$group)
        
        # Re-level 'time' so 'Pre' is the reference level
        merged_data_filtered$time <- relevel(merged_data_filtered$time, ref = "Pre")
        
        # Relevel 'group' so 'HED' is the reference level
        merged_data_filtered$group <- relevel(merged_data_filtered$group, ref = "HED")
        
        correlation_results$mixed_cor_all[current_row_index] <- NA
        correlation_results$mixed_p_all[current_row_index] <- NA
        
      }
    }
  }
  
  return(correlation_results)
}


#################### Scatter plot
correlation_change_plot <- function(correlation_df, mirage_ch_vars, correlation_results, lipidclass, saturation_type) {
  
  # Make lipid name
  lipidName <- lipidclass
  
  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pp_change))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_ch_vars, function(category) {
      lapply(category, function(item) sub("_pre", "_ch", item[1]))
    }), recursive = FALSE), use.names = FALSE)
    
    plotVars <- c("pp_change", plotVars)
    
    # Add lipid variable to plotVars
    pm <- ggpairs(correlation_df,
                  mapping = aes(color = group),
                  columns = plotVars
    )
    
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }
    
    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)
      
      
      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
                                        x = Inf, y = Inf,
                                        label = paste0(
                                          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
                                          #", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
                                          
                                          "All: Spearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
                                          "    |    rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
                                          #"\nHED: Pearson, p = ", formatC(correlation_row$pearson_p_HED, format = "f", digits = 3),
                                          #", r = ", formatC(correlation_row$pearson_r_HED, format = "f", digits = 3),
                                          "\nHED: Spearman, p = ", formatC(correlation_row$spearman_p_HED, format = "f", digits = 3),
                                          "    |    rho = ", formatC(correlation_row$spearman_rho_HED, format = "f", digits = 3),
                                          #"\nDIWL: Pearson, p = ", formatC(correlation_row$pearson_p_DIWL, format = "f", digits = 3),
                                          #", r = ", formatC(correlation_row$pearson_r_DIWL, format = "f", digits = 3),
                                          "\nDIWL: Spearman, p = ", formatC(correlation_row$spearman_p_DIWL, format = "f", digits = 3),
                                          "    |    rho = ", formatC(correlation_row$spearman_rho_DIWL, format = "f", digits = 3),
                                          #"\nWLEX: Pearson, p = ", formatC(correlation_row$pearson_p_WLEX, format = "f", digits = 3),
                                          #", r = ", formatC(correlation_row$pearson_r_WLEX, format = "f", digits = 3),
                                          "\nWLEX: Spearman, p = ", formatC(correlation_row$spearman_p_WLEX, format = "f", digits = 3),
                                          "    |    rho = ", formatC(correlation_row$spearman_rho_WLEX, format = "f", digits = 3),
                                          "\n*****p-values are not adjusted*****"
                                        ),
                                        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }
    
    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }
    
    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }
    
    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }
  
  savePath <- paste0(getwd(), "/outputs/saturation/change, correlations/scatter/", saturation_type, "/")
  
  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )
  
  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
}


#################### RUN FUNCTION
# intialize empty list
correlation_values_ch_saturation_list <- list()

######## IN LOOP
for (saturation_type in c("sat_proportion", "unsat_proportion", "unsat_mono_proportion", "unsat_poly_proportion")){
  
  # Initialize the dataframe to be able to store as saturation_type
  correlation_values_ch_saturation <- data.frame()
  
  #Loop over each lipid class and make plots
  for (lipid_class in unique_lipid_classes[unique_lipid_classes != c("PC.PE", "Cer ratio")]) {
    print( paste0("Analysing ",lipid_class, " - ", saturation_type, "..."))
    
    # Organize data
    correlation_df <- prepare_and_combine_data(
      lipidomicsData = lipidomicsDF_saturation,
      pre_post_cols = mirage_ch_vars,
      mirageData = mirage_data,
      lipidclass = lipid_class,
      saturation_col = saturation_type)
    
    # Calculate correlations for changes
    correlation_values_ch_saturation <- rbind(correlation_values_ch_saturation, correlation_of_change(
      correlation_df = correlation_df,
      lipidomicsData = lipidomicsDF_saturation,
      mirage_data_long_ch = mirage_data_long_ch,
      mirage_variables_of_interest = mirage_ch_vars,
      lipidclass = lipid_class))
    
    # Store the dataframe in the list under a dynamically named key
    correlation_values_ch_saturation_list[[saturation_type]] <- correlation_values_ch_saturation
    
    ## Plot data
    correlation_change_plot(
      correlation_df = correlation_df,
      mirage_ch_vars = mirage_ch_vars,
      correlation_results = correlation_values_ch_saturation,
      lipidclass = lipid_class,
      saturation_type = saturation_type
      
    )
  }}
```

### Heatmap

```{r}
heatmap_changes_saturation <- function (saturation_type, overall_title){
  
  
  ####### Data preparation
  #Gather the Spearman p-value columns
  long_format_p_adj.non <- correlation_values_ch_saturation_list[[saturation_type]] %>% 
    select(all_of(c("lipid", "test_against", "spearman_p_all"))) %>%
    pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")
  
  
  #Gather the Spearman rho columns
  long_format_cor <- correlation_values_ch_saturation_list[[saturation_type]] %>%
    select(all_of(c("lipid", "test_against", "spearman_rho_all"))) %>%
    pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")
  
  
  # Capitalize all to ALL
  long_format_p_adj.non$spearman_type <- gsub("all", "ALL", long_format_p_adj.non$spearman_type)
  long_format_cor$spearman_type <- gsub("all", "ALL", long_format_cor$spearman_type)
  
  # Remove Na rows based on NA in correlation
  long_format_cor <- long_format_cor %>%
    filter(!is.na(rho_value))
  
  # Use the 'lipid' values to filter long_format_p_adj.non
  long_format_p_adj.non <- long_format_p_adj.non %>%
    filter(lipid  %in% long_format_cor$lipid)
  
  # Adjust p-values by group
  long_format_p_adj.gr <- long_format_p_adj.non %>%
    group_by(test_against, spearman_type) %>%
    mutate(p_value = p.adjust(p_value, method = "BH"))%>%
    ungroup()
  
  # adjust p-values by group and lipidClass
  long_format_p_adj.gr.class <- long_format_p_adj.non %>%
    mutate(lipidClass = sub("^(\\S+)\\s.*$", "\\1", lipid)) %>%
    group_by(test_against, spearman_type, lipidClass) %>%
    mutate(p_value = p.adjust(p_value, method = "BH")) %>%
    ungroup()
  
  
  ######### PLOT HEATMAP ##########
  heatmap_changes_sat <- function(test_against_input, save_name){
    
    # Group lipidclasses to make multiple, clean heatmaps
    lipids_groups <- list(
      gr_all = c("TAG", "1,2-DG", "1,3-DG", "AC", "PC", "PC.PE ratio", "PE", "SPM", "SPH", "Cer", "dhCer", "GluCer", "LacCer", "GalCer", "LPC", "LPE", "LPG", "LPI", "LPS", "PA", "PS", "PG", "PI")
    )
    
    # Define function to filter and sort lipids based on group names
    filter_lipid_group_base <- function(data_frame, lipid_group) {
      # Create the pattern for matching lipid groups
      pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
      # Sort the data_frame by lipid column
      sorted_data_frame <- data_frame[order(data_frame$lipid), ]
      # Filter based on the pattern and return the sorted & filtered data frame
      sorted_filtered_data_frame <- sorted_data_frame[grepl(pattern, sorted_data_frame$lipid), ]
      return(sorted_filtered_data_frame)
    }
    
    # Select specific test against
    long_format_p_adj_selected.non <- long_format_p_adj.non[long_format_p_adj.non$test_against %in% test_against_input,]
    long_format_p_adj_selected.gr <- long_format_p_adj.gr[long_format_p_adj.gr$test_against %in% test_against_input,]
    long_format_p_adj_selected.gr.class <- long_format_p_adj.gr.class[long_format_p_adj.gr.class$test_against %in% test_against_input,]
    
    long_format_corr_selected <- long_format_cor[long_format_cor$test_against %in% test_against_input,] 
    
    # Apply the filter function to each group and store the results in a lists
    # p-values
    long_format_p_adj_groups.non <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.non)
    long_format_p_adj_groups.gr <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr)
    long_format_p_adj_groups.all <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr.class)
    # correlations
    long_format_corr_groups <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_corr_selected)
    
    
    # Function to create 'unique_test_against' column for p-value df
    mutate_unique_column_p <- function(data_frame) {
      data_frame %>%
        mutate(unique_test_against = paste0(sub("spearman_p_", "", spearman_type), "_", test_against))
    }
    
    # Adjust the function for correlation df
    mutate_unique_column_corr <- function(data_frame) {
      data_frame %>%
        mutate(unique_test_against = paste0(sub("spearman_rho_", "", spearman_type), "_", test_against))
    }
    
    # Apply the mutation function to each group's data frames for p-values
    long_format_p_adj_groups.non <- lapply(long_format_p_adj_groups.non, mutate_unique_column_p)
    long_format_p_adj_groups.gr <- lapply(long_format_p_adj_groups.gr, mutate_unique_column_p)
    long_format_p_adj_groups.all <- lapply(long_format_p_adj_groups.all, mutate_unique_column_p)
    
    # Apply the mutation function to each group's data frames for correlations
    long_format_corr_groups <- lapply(long_format_corr_groups, mutate_unique_column_corr)
    
    
    # Function to perform negative log10 transformation and remove p_value column
    transform_p_values <- function(df) {
      df %>%
        mutate(p_log10 = -log10(p_value)) %>%
        select(-p_value)
    }
    
    # Apply the transformation to each list
    long_format_p_adj_log10.non <- lapply(long_format_p_adj_groups.non, transform_p_values)
    long_format_p_adj_log10.gr <- lapply(long_format_p_adj_groups.gr, transform_p_values)
    long_format_p_adj_log10.all <- lapply(long_format_p_adj_groups.all, transform_p_values)
    
    
    # Define a function to spread the data and convert it to a matrix
    spread_and_convert_matrix <- function(df, unitName) {
      result_matrix <- df %>%
        select(lipid, unique_test_against, all_of(unitName)) %>%
        pivot_wider(names_from = unique_test_against, 
                    values_from = unitName, 
                    values_fill = setNames(list(NA), unitName)) %>%
        column_to_rownames(var = "lipid") %>%
        as.matrix()
      return(result_matrix)
    }
    
    
    
    # Apply the function to each list
    matrices_p_adj_non <- lapply(long_format_p_adj_groups.non, function(x) spread_and_convert_matrix(x, "p_value"))
    matrices_p_adj_gr <- lapply(long_format_p_adj_groups.gr, function(x) spread_and_convert_matrix(x, "p_value"))
    matrices_p_adj_all <- lapply(long_format_p_adj_groups.all, function(x) spread_and_convert_matrix(x, "p_value"))
    # To correlation values
    matrices_rho <- lapply(long_format_corr_groups, function(x) spread_and_convert_matrix(x, "rho_value"))
    
    #### Should return a double - not a list when indexed like this [[1]]
    
    generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims) {
      # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
      
      # Extract test_against by removing the first part (treatment group) and the first underscore
      # This joins back the remaining parts to form the full 'test_against' label
      colTitles <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) paste(x[-1], collapse = "_"))
      colTitles <- unique(colTitles)
      
      
      # Modify the column names to only show the group
      colnames(hm_matrix) <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) {
        # Concatenate the first part with the first four letters of the second part and "..."
        paste0(x[1], "", substr(x[2], 1, 0), "")
      })
      
      
      Heatmap(hm_matrix,
              name = "rho", # Sets the name of the color scale
              
              col = colorMap, # Use provided color map
              rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
              row_names_side = "left", # Position of row labels
              row_names_gp = gpar(fontsize = 11), # Change font size of row labels
              column_split = rep(1:(ncol(hm_matrix) / 1), each = 1), # Splits the columns and names them
              column_title = colTitles, # Custom titles for each split
              column_title_rot = 45,
              column_names_rot = 0, # Rotate column names to 0 degrees (horizontal)
              column_names_gp = gpar(col = "white", fontsize = 0), # Make column names invisible
              column_title_side = "top", # Placement of the column titles
              column_title_gp = gpar(fontsize = 8, fontface = "bold"),
              
              #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
              
              border = TRUE, # Set border around the splits
              cluster_rows = FALSE, # Don't make clusters
              cluster_columns = FALSE, # Don't make clusters
              
              cell_fun = function(j, i, x, y, width, height, fill) {
                if (!is.na(p_val_matrix[i, j])) {
                  if (p_val_matrix[i, j] < pLims$p1) {
                    grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p2) {
                    grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p3) {
                    grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  }
                }
              })
    }
    
    # Define color map for heatmap
    color_mapping <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))
    
    # Set p-value limits
    p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
    
    # Create a list for the heatmaps
    hm <- list()
    
    # Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
    for (i in 1:length(lipids_groups)) {
      # Generate heatmap and store it in the list
      hm[[i]] <- generate_heatmap(matrices_rho[[i]], matrices_p_adj_gr[[i]], color_mapping, p_value_limits)
    }
    
    # Define the path and name of your PDF file
    pdf_path <- paste0(getwd(), "/outputs/saturation/change, correlations/heatmap/", saturation_type, "/",save_name, ".pdf")
    
    # Open a PDF device
    pdf(pdf_path, width = 8, height = 10)
    
    # Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
    for (i in 1:length (hm)){
      draw(hm[[i]], padding = unit(c(0, 0, 10, 0), "mm"))
      
      # Add a common title
      grid.text(overall_title, x = unit(0.5, "npc"), y = unit(0.98, "npc"), 
                gp = gpar(fontsize = 14, fontface = "bold"))
    }
    dev.off()
  }
  
  # Loop over every group within the compositions
  for (i in seq_along(mirage_ch_vars)) {
    # Print the name of the current list being processed
    list_name <- names(mirage_ch_vars)[i]
    print(paste("Processing list:", list_name))
    
    test_against_input <- unlist(lapply(mirage_ch_vars[[i]], function(sublist) {
      # Check if the sublist is long enough to have at least the first element
      if(length(sublist) >= 1) {
        # Replace '_pre' with '_ch' in the first element
        return(gsub("_pre", "_ch", sublist[1]))
      }}))
    heatmap_changes_sat(test_against_input = test_against_input, save_name = list_name)
  }
}

######## Run functions
heatmap_changes_saturation(
  saturation_type = "sat_proportion",
  overall_title = "Correlations based on changes: Saturated lipids")

heatmap_changes_saturation(
  saturation_type = "unsat_proportion",
  overall_title = "Correlations based on changes: Unsaturated lipids")

heatmap_changes_saturation(
  saturation_type = "unsat_mono_proportion",
  overall_title = "Correlations based on changes: Mono unsaturated lipids")

heatmap_changes_saturation(
  saturation_type = "unsat_poly_proportion",
  overall_title = "Correlations based on changes: Poly unsaturated lipids")
```

## CrossSection analysis

```{r}
# run function test
# Function to prepare data
prepare_and_combine_crossSection_sat <- function(lipidomicsData, mirageData, lipidclass, sat_type) {
  
  # Filter and prepare lipidomics data
  lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
  
  # Select columns of interest
  lipidomics_filtered <- lipidomics_selected %>%
    select( all_of( c("id", "group", "time", "lipidClass", sat_type)))
  
  # Pivot to wide format
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = sat_type, names_prefix = "lipid_percent_") %>%
    relocate(id, .before = everything()) # Moves id to front
  
  
  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")
  
  # Convert certain columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))
  
  return(combined_df)
}


################ SATISTICS ################

# Define a function to compute correlations of change
correlation_cross_sectional_sat <- function(correlation_df, lipidomicsDF, mirage_variables_of_interest, lipidclass, sat_type) {
  
  # Determine the lipid name based on the presence of lipid composition   
  
  lipidName <- lipidclass
  
  # Make Na if too few values determined from prepare data function
  
  if (sum( !is.na(correlation_df$lipid_percent_Pre)) < analysis_cutoff)
  {
    correlation_results <- data.frame(
      lipid = lipidName,
      test_against = NA,
      pearson_r_all = NA,
      pearson_p_all = NA,
      spearman_rho_all = NA,
      spearman_p_all = NA,
      pearson_r_HED = NA,
      pearson_p_HED = NA,
      spearman_rho_HED = NA,
      spearman_p_HED = NA,
      pearson_r_DIWL = NA,
      pearson_p_DIWL = NA,
      spearman_rho_DIWL = NA,
      spearman_p_DIWL = NA,
      pearson_r_WLEX = NA,
      pearson_p_WLEX = NA,
      spearman_rho_WLEX = NA,
      spearman_p_WLEX = NA
    )
  } else {
    
    # Initialize an empty data frame to store correlation results
    correlation_results <- data.frame(
      lipid = character(),
      test_against = character(),
      pearson_r_all = numeric(),
      pearson_p_all = numeric(),
      spearman_rho_all = numeric(),
      spearman_p_all = numeric(),
      pearson_r_HED = numeric(),
      pearson_p_HED = numeric(),
      spearman_rho_HED = numeric(),
      spearman_p_HED = numeric(),
      pearson_r_DIWL = numeric(),
      pearson_p_DIWL = numeric(),
      spearman_rho_DIWL = numeric(),
      spearman_p_DIWL = numeric(),
      pearson_r_WLEX = numeric(),
      pearson_p_WLEX = numeric(),
      spearman_rho_WLEX = numeric(),
      spearman_p_WLEX = numeric()
    )
    
    # Loop over every mirage variables of interest
    for (i in seq_along(mirage_variables_of_interest)) {
      for (j in seq_along(mirage_variables_of_interest[[i]])){
        
        # Manipulate current variable name
        test_against_name <- mirage_variables_of_interest[[i]][[j]][1]
        test_against_name_clean <- sub("_pre$", "", test_against_name)
        
        # Add new row to output df
        correlation_results <- add_row(correlation_results)
        
        # Identify the index of current row to be able to append data to it
        current_row_index <- nrow(correlation_results)
        
        # Assign lipid name and test against to last row
        correlation_results$lipid[current_row_index] <- lipidName
        correlation_results$test_against[current_row_index] <- test_against_name
        
        # Lipid unit
        lipid_unit <- "lipid_percent_Pre"
        
        
        # Perform Pearson and Spearman correlations for all data
        result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
        result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
        
        
        # Assign results the the results df
        correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
        correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
        correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
        correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p
        
        # Calculate correlations for each group
        for (current_group in unique(correlation_df$group)) {
          # Filter the dataframe for the current group
          correlation_df_group <- filter(correlation_df, group == current_group)
          
          
          # Perform Pearson and Spearman correlations for the current group
          result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
          result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
          
          # Dynamic assignment of results based on the current group
          pearson_r_col <- paste0("pearson_r_", current_group)
          pearson_p_col <- paste0("pearson_p_", current_group)
          spearman_rho_col <- paste0("spearman_rho_", current_group)
          spearman_p_col <- paste0("spearman_p_", current_group)
          
          correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
          correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
          correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
          correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
        }
      }
    }
  }
  return(correlation_results)
}



####### Scatter plot #######

correlation_crossSectional_plot <- function(correlation_df, mirage_crossSectional_vars, correlation_results, lipidclass, sat_type) {
  # Make lipid name
  lipidName <- lipidclass
  
  # Only plot if there's data to plot
  if (sum( !is.na(correlation_df$lipid_percent_Pre)) >= analysis_cutoff)
  {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_crossSectional_vars, function(category) {
      lapply(category, function(item) item[1])
    }), recursive = FALSE), use.names = FALSE)
    
    # If lipidcomposition is null, then only plot class
    
    # Filter and prepare lipidomics data
    # Add lipid variable to plotVars
    plotVars <- c("lipid_percent_Pre", plotVars)
    
    pm <- ggpairs(correlation_df,
                  mapping = aes(color = group),
                  columns = plotVars
    )
    
    
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }
    
    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)
      
      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
                                        x = Inf, y = Inf,
                                        label = paste0(
                                          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
                                          # ", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
                                          "\nSpearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
                                          ", rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
                                          "\n***** Non-adjusted *****"
                                        ),
                                        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }
    
    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }
    
    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }
    
    
    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }
  
  savePath <- paste0(getwd(), "/outputs/saturation/cross section/scatter/", sat_type, "/")
  
  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )
  
  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
  
}

```

### Run functions

```{r}
#Run functions

# Initialize list to store data  
correlation_values_crossSection_saturation_list <- list()

######## IN LOOP
for (sat_type in c("sat_proportion", "unsat_proportion", "unsat_mono_proportion", "unsat_poly_proportion")){
  
  # Initialize the dataframe to be able to store as saturation_type
  corrrelation_results_crossSection_sat <- data.frame()
  
  #Loop over each lipid class and make plots
  for (lipid_class in unique_lipid_classes[unique_lipid_classes != c("PC.PE", "Cer ratio")]) {
    
    print( paste0( "Analysing ", lipid_class, " - ", sat_type, "..."))
    
    # Organize data
    correlation_crossSection_df <- prepare_and_combine_crossSection_sat(
      lipidomicsData = lipidomicsDF_saturation,
      mirageData = mirage_data,
      lipidclass = lipid_class,
      sat_type = sat_type)
    
    # Calculate correlations for changes
    corrrelation_results_crossSection_sat <- rbind(corrrelation_results_crossSection_sat, correlation_cross_sectional_sat(
      correlation_df = correlation_crossSection_df,
      lipidomicsDF = lipidomicsDF_saturation,
      mirage_variables_of_interest = mirage_crossSectional_vars,
      lipidclass = lipid_class,
      sat_type = sat_type))
    
    # Store the dataframe in the list under a dynamically named key
    correlation_values_crossSection_saturation_list[[sat_type]] <- corrrelation_results_crossSection_sat
    
    # Plot data
    correlation_crossSectional_plot(
      correlation_df = correlation_crossSection_df,
      mirage_crossSectional_vars = mirage_crossSectional_vars,
      correlation_results = corrrelation_results_crossSection_sat,
      lipidclass = lipid_class,
      sat_type = sat_type)
  }}
```

### volcano plot

```{r}
volcano_crossSection <- function(input_vars, save_sub_path, correlation_results, plot_title, save_folder){
  
  # Remove NA rows
  correlation_results <- correlation_results[!is.na(correlation_results$spearman_rho_all), ]
  
  # Select columns: Rho and p-value
  vulc_data_crossSection <- correlation_results %>% 
    select("lipid", "test_against", "spearman_rho_all", "spearman_p_all")
  
  # Filter rows where 'test_against' column values are in 'input_vars'
  vulc_data_crossSection <- vulc_data_crossSection[vulc_data_crossSection$test_against %in% input_vars, ]
  
  # Adjust the p-value column based test_against.
  vulc_data_crossSection <- vulc_data_crossSection %>%
    group_by(test_against) %>%
    mutate(across("spearman_p_all", ~ p.adjust(.x, method = "BH"), .names = "p_value")) %>%
    ungroup()
  
  # Make a identifier column that combines lipid and test_against
  vulc_data_crossSection$identifier <- paste0(vulc_data_crossSection$lipid, " ~ ", vulc_data_crossSection$test_against)
  
  
  ### Plot settings
  # Set threshold for when to plot label
  threshold_rho <- 0.2
  
  # Assuming unique_tests has been defined as before
  unique_tests <- sort(unique(vulc_data_crossSection$test_against))
  
  
  # Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
  base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                                c = 100, 
                                l = 65)[1:length(unique_tests)]
  
  # Assign each test to a color
  colors_for_tests <- setNames(base_colors, unique_tests)
  
  ### Create plot
  vulc_plot <- ggplot(vulc_data_crossSection, aes(x = spearman_rho_all, y = -log10(p_value))) +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", linewidth = 0.2) +
    geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
    scale_color_manual(values = colors_for_tests) +
    scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12), guide = FALSE) + # TRUE for significant, FALSE for not
    geom_text_repel(aes(label = ifelse(p_value < 0.06 & abs(spearman_rho_all) > threshold_rho, identifier, "")),
                    box.padding = .3, point.padding = .3,
                    size = 3, segment.color = 'grey50') +
    theme_minimal() +
    xlim(-1,1) +
    guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) + # Hide the alpha legend and fix the color legend
    labs(title = paste0("Correlations at baseline: ", plot_title, " - ", save_sub_path), x = "Spearman rho", y = "-log10 P-value")+
    theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  1
  # Save path
  save_path <- paste0( getwd(), "/outputs/saturation/cross section/volcano", "/", save_folder,"/" ,save_sub_path, ".jpeg")
  
  # Save the plot
  ggsave(save_path , plot = vulc_plot, width = 12, height = 8, dpi = 400)
}

# Run function

# Loop through each main category in mirage_crossSection_vars
for (i in seq_along(mirage_crossSectional_vars)) {
  # Print the name of the current list being processed
  list_name <- names(mirage_crossSectional_vars)[i]
  print(paste("Processing list:", list_name))
  
  # Use lapply to iterate over each sublist in the current category
  names_to_use <- unlist(lapply(mirage_crossSectional_vars[[i]], function(sublist) {
    # Check if the sublist is long enough to have at least the first element
    if(length(sublist) >= 1) {
      # Replace '_pre' with '_ch' in the first element
      return( sublist[1])
    } else {
      return(NA)  # Return NA if the sublist does not have at least one element
    }
  }))
  
  volcano_crossSection(input_vars = names_to_use,
                       save_sub_path = list_name,
                       correlation_results = correlation_values_crossSection_saturation_list$sat_proportion,
                       plot_title = "saturated proportion",
                       save_folder = "saturated")
  
  volcano_crossSection(input_vars = names_to_use,
                       save_sub_path = list_name,
                       correlation_results = correlation_values_crossSection_saturation_list$unsat_proportion,
                       plot_title = "unsaturated proportion",
                       save_folder = "unsaturated")
  
  
  volcano_crossSection(input_vars = names_to_use,
                       save_sub_path = list_name,
                       correlation_results = correlation_values_crossSection_saturation_list$unsat_mono_proportion,
                       plot_title = "mono unsaturated proportion",
                       save_folder = "mono unsaturated")
  
  
  volcano_crossSection(input_vars = names_to_use,
                       save_sub_path = list_name,
                       correlation_results = correlation_values_crossSection_saturation_list$unsat_poly_proportion,
                       plot_title = "poly unsaturated proportion",
                       save_folder = "poly unsaturated")
}

```

# Mirage pre-post analysis w plot
```{r}
## Make function for the analysis
mirage_analysis_and_plot <- function(endpoint_variable, y_label, save_folder){
  
  # Turn MIRAGE data into long format to be able to plot data
  # Combine all variables of interest
  subset_variables <- c("id", "group", "gender", endpoint_variable)
  
  # Rename the endpoint variable to match the name in long format 
  endpoint_variable <- gsub("_pre", "", endpoint_variable[1])
  
  # Subset 'mirage_data' to include only the variables of interest
  mirage_subset <- mirage_data[, subset_variables]
  
  # Transform 'mirage_data_subset' to long format
  mirage_plot_long <- pivot_longer(
    mirage_subset,
    cols = -c(id, group, gender),  # exclude cols from the pivot
    names_to = c(".value", "time"),
    names_pattern = "(.+)_(pre|post)"
  )
  
  ### Make a column called in_lipidomics to filter out values that are present in that dataset
  # Make id columns strings to be able to search
  mirage_plot_long$id <- as.character(mirage_plot_long$id)
  lipidomicsDF$id <- as.character(lipidomicsDF$id)
  
  # Create the new column 'in_lipidomics' based on 'id' existence in lipidomicsDF
  mirage_plot_long <- mirage_plot_long %>%
    mutate(in_lipidomics = if_else(id %in% lipidomicsDF$id, TRUE, FALSE))
  
  
  # Adjust the 'time' column in 'mirage_data_long_ch' to match 'Pre' and 'Post'
  mirage_plot_long <- mirage_plot_long %>%
    mutate(time = case_when(
      time == "pre" ~ "Pre",
      time == "post" ~ "Post",
      TRUE ~ time # Keeps the original value if it's neither 'pre' nor 'post'
    ))
  
  
  ##### MIXED MODEL
  
  mirage_lmer <- function(modelData, endpoint_variable){
    # Writing out formula allows dynamic naming
    model_formula <- as.formula(paste(
      endpoint_variable,
      "~ time * group +
      (1 | id)"))
    
    model <- lmer(model_formula,
                  data = modelData,
                  na.action = na.exclude)
    
    # Estimated marginal of means to get out slope and between groups statistics
    emm <- emmeans(model, ~ time * group)
    
    # Contrasts for differences in slopes between groups
    model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")
    
    model.slope.contrasts.results <- summary(model.slope.contrasts)
    
    # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
    model.slope.contrasts.results <- model.slope.contrasts.results %>%
      mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
      select(contrast, estimate, SE, df, t.ratio, p.value)
    
    # Pre, Post between group comparisons
    prepost.contrasts <- pairs(emm, adjust = "none")
    
    # Get results
    prepost.contrasts.results <- summary(prepost.contrasts)
    
    return(list(enpoint = as.character(endpoint_variable), slope_results = model.slope.contrasts.results, prepost_results = prepost.contrasts.results))
  }
  
  # Run function
  lmer_results.mirage <- mirage_lmer(mirage_plot_long, endpoint_variable)
  lmer_results.lipidomics <- mirage_lmer(mirage_plot_long[mirage_plot_long$in_lipidomics==TRUE,], endpoint_variable)
  
  ##### PLOT DATA
  
  # Function to extract p-value based on contrast
  extract_p_value <- function(results, contrast_name) {
    results$p.value[results$contrast == contrast_name]
  }
  
  # In lipidomics data
  p_value.hed <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post HED - Pre HED")
  p_value.diwl <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post DIWL - Pre DIWL")
  p_value.wlex <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post WLEX - Pre WLEX")
  p_value_slope.hed_diwl <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : DIWL - HED")
  p_value_slope.diwl_wlex <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : DIWL - WLEX")
  p_value_slope.wlex_hed <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : HED - WLEX")
  # For whole mirage data
  p_value.hed_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post HED - Pre HED")
  p_value.diwl_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post DIWL - Pre DIWL")
  p_value.wlex_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post WLEX - Pre WLEX")
  p_value_slope.hed_diwl_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : DIWL - HED")
  p_value_slope.diwl_wlex_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : DIWL - WLEX")
  p_value_slope.wlex_hed_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : HED - WLEX")
  
  
  # Calculate the count (n) for each group and time
  # lipidomics data
  n_hed_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "HED" & mirage_plot_long$time == "Pre"]))
  n_hed_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "HED" & mirage_plot_long$time == "Post"]))
  n_diwl_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Pre"]))
  n_diwl_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Post"]))
  n_wlex_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Pre"]))
  n_wlex_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Post"]))
  
  # mirage data
  n_hed_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "HED" & mirage_plot_long$time == "Pre"]))
  n_hed_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "HED" & mirage_plot_long$time == "Post"]))
  n_diwl_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Pre"]))
  n_diwl_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Post"]))
  n_wlex_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Pre"]))
  n_wlex_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Post"]))
  
  
  # Calculate both means for lipidomics ids and mirage ids
  mean_data <- mirage_plot_long %>%
    group_by(group, time) %>%
    summarise(
      mean_lipidomics = mean(ifelse(in_lipidomics == TRUE, .data[[endpoint_variable]], NA), na.rm = TRUE),
      mean_mirage = mean(.data[[endpoint_variable]], na.rm = TRUE),
      .groups = 'drop'
    )
  
  # Generate labels with original and corrected p-values including n counts
  annotation_hed <- paste0(
    "HED pre (n=", n_hed_pre, ") vs post (n=", n_hed_post,
    "), p = ", formatC(p_value.hed, format = "f", digits = 3), 
    "\n MIRAGE: pre (n=", n_hed_pre_mirage, ") vs post (n=", n_hed_post_mirage,
    "), p = ", formatC(p_value.hed_mirage, format = "f", digits = 3))
  
  annotation_diwl <- paste0(
    "DIWL pre (n=", n_diwl_pre, ") vs post (n=", n_diwl_post, 
    "), p = ", formatC(p_value.diwl, format = "f", digits = 3), 
    "\n MIRAGE: pre (n=", n_diwl_pre_mirage, ") vs post (n=", n_diwl_post_mirage, 
    "), p = ", formatC(p_value.diwl_mirage, format = "f", digits = 3))
  
  annotation_wlex <- paste0(
    "WLEX pre (n=", n_wlex_pre, ") vs post (n=", n_wlex_post, 
    "), p = ", formatC(p_value.wlex, format = "f", digits = 3), 
    "\n MIRAGE: pre (n=", n_wlex_pre_mirage, ") vs post (n=", n_wlex_post_mirage, 
    "), p = ", formatC(p_value.wlex_mirage, format = "f", digits = 3))
  
  
  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(p_value_slope.hed_diwl, format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(p_value_slope.wlex_hed, format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(p_value_slope.diwl_wlex, format = "f", digits = 3),
    "\n MIRAGE:         HED vs DIWL, p = ", formatC(p_value_slope.hed_diwl_mirage, format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(p_value_slope.wlex_hed_mirage, format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(p_value_slope.diwl_wlex_mirage, format = "f", digits = 3)
  )
  
  # Make the plot
  plot <- ggplot(mirage_plot_long, aes(
    x = factor(interaction(group, time, sep = " "),
               levels = c(
                 "HED Pre",
                 "HED Post", 
                 "DIWL Pre", 
                 "DIWL Post", 
                 "WLEX Pre", 
                 "WLEX Post")),
    y = !!sym(endpoint_variable), group = interaction(id, group))) +
    
    # Lines for all, colored conditionally, alpha adjusted directly
    geom_line(aes(color = if_else(in_lipidomics == TRUE, "Lipidomics", "MIRAGE"), 
                  alpha = if_else(in_lipidomics == TRUE, 1, 0.95)), 
              position = position_nudge(x = 0.03)) +
    
    # Points for all, colored conditionally, alpha adjusted directly
    geom_point(aes(color = if_else(in_lipidomics == TRUE, "Lipidomics", "MIRAGE"), 
                   alpha = if_else(in_lipidomics == TRUE, 1, 0.95)),  # Adjusted alpha for visibility
               position = position_nudge(x = 0.03)) +
    
    geom_boxplot(data = mirage_plot_long[mirage_plot_long$in_lipidomics == TRUE, ],
                 aes(group = interaction(group, time)),
                 width = 0.3, alpha = 0.2, outlier.shape = NA,
                 position = position_dodge(width = 0.75), color = "black") +
    
    # Mean line lipidomics
    geom_line(data = mean_data, aes(x = interaction(group, time, sep = " "), y = mean_lipidomics, group = group), 
              color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
    
    # Mean line MIRAGE
    geom_line(data = mean_data, aes(x = interaction(group, time, sep = " "), y = mean_mirage, group = group), 
              color = "darkgrey", alpha = 0.95, linewidth = 1, position = position_nudge(x = 0.03)) +
    
    scale_color_manual(values = c("Lipidomics" = "black", "MIRAGE" = "darkgrey"), name = "Data") +
    
    labs(
      title = paste(endpoint_variable, "(p-vals not adj.)"),
      subtitle = annotation_pvals_slope,
      y = y_label,
      x = ""
    ) +
    guides(alpha = FALSE) + # Hide the alpha legend
    # Insert P-values pre post
    annotate("text", x = 1.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
             label = annotation_hed, size = 2.1, hjust = 0.5) +
    annotate("text", x = 3.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
             label = annotation_diwl, size = 2.1, hjust = 0.5) +
    annotate("text", x = 5.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
             label = annotation_wlex, size = 2.1, hjust = 0.5) +
    theme_minimal(base_size = 12) + # Start with a minimal theme
    theme(
      axis.title.x = element_blank(), 
      axis.text.x = element_text(angle = 45, hjust = 1), 
      legend.position = "right",
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"), # Bold and centered title
      plot.subtitle = element_text(hjust = 0.5, size = 8), # Smaller and centered subtitle
      legend.text = element_text(size = 6),
      legend.title = element_text(size = 6, hjust = 0.5), 
      panel.grid.major.x = element_blank(), 
      panel.grid.minor.x = element_blank(),
      plot.caption = element_text(size = 8)
    )
  
  # Define the directory
  dir_path <- paste0( getwd(), "/outputs/mirage/", save_folder)
  
  # Create the directory if it does not exist
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }
  
  # Define the filename
  filename <- file.path(dir_path, paste0(endpoint_variable, ".jpg"))
  
  # Save the plot
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)
  
}


### Run function
# Loop through each named element of mirage_ch_vars
for (list_name in names(mirage_ch_vars)) {
  # Print the name of the list
  for (i in 1:length(mirage_ch_vars[[list_name]])) {
    mirage_analysis_and_plot(endpoint_variable=mirage_ch_vars[[list_name]][[i]][1:2], y_label=mirage_ch_vars[[list_name]][[i]][3], save_folder = list_name)
  }}




# endpoint_variable <- c("mpa_mins_day_pre", "mpa_mins_day_post")
# y_label <- expression("mins/day")





```

# PCA
```{r}
## Based on summed results 
summarizedDF <- lipidomicsDF %>%
  group_by(id, time, group, lipidClass) %>%
  summarise(pmol_mg = sum(pmol_mg, na.rm = TRUE)) %>%
  ungroup()

# Filter necessary columns
lipidomicsDF_filtered <- summarizedDF %>%
  filter(!(lipidClass %in% c("Cer ratio", "PC.PE"))) %>%
  #filter(lipidClass %in% c("TAG", "AC", "1,2-DG", "1,3-DG", "Cer", "dhCer")) %>% #####
select(id, time, lipidClass, pmol_mg)

# Apply log2 transformation to avoid log of zero, we can use log2(x + 1)
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  mutate(pmol_mg_log = log2(pmol_mg + 0.01))

# Normalize pmol_mg_log within each lipid class and lipid composition
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  group_by(lipidClass) %>%
  mutate(pmol_mg_log = scale(pmol_mg_log)) %>%
  ungroup()

# Combine lipidComposition and lipidClass into a single identifier
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  mutate(lipid_id = paste(lipidClass, sep = " "))

# ----

# Based on all data equally divided
# Filter necessary columns
lipidomicsDF_filtered <- lipidomicsDF %>%
  filter(!(lipidClass %in% c("Cer ratio", "PC.PE"))) %>%
  #filter(lipidClass %in% c("TAG", "AC", "1,2-DG", "1,3-DG", "Cer", "dhCer")) %>% #####
select(id, time, lipidComposition, lipidClass, pmol_mg)

# Apply log2 transformation to avoid log of zero, we can use log2(x + 1)
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  mutate(pmol_mg_log = log2(pmol_mg + 0.01))

# Normalize pmol_mg_log within each lipid class and lipid composition
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  group_by(lipidClass, lipidComposition) %>%
  mutate(pmol_mg_log = scale(pmol_mg_log)) %>%
  ungroup()

# # Apply quantile normalization within each lipid class and lipid composition
## Nb. different scales, so scale and center should be TRUE?
# lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
#   group_by(lipidClass, lipidComposition) %>%
#   mutate(pmol_mg_log = as.vector(normalize.quantiles(as.matrix(pmol_mg_log)))) %>%
#   ungroup()

# Combine lipidComposition and lipidClass into a single identifier
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  mutate(lipid_id = paste(lipidClass, lipidComposition, sep = " "))

###-----

# Based on pre-post differences
# Filter necessary columns
lipidomicsDF_filtered <- lipidomicsDF %>%
  filter(!(lipidClass %in% c("Cer ratio", "PC.PE"))) %>%
  filter(lipidClass %in% c("TAG", "AC", "1,2-DG", "1,3-DG", "Cer", "dhCer")) %>%
  filter(time == "Pre") %>%
  select(id, time, lipidComposition, lipidClass, pmol_mg_abs_delta)

# Apply log2 transformation to avoid log of zero, we can use log2(x + 1)
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  mutate(pmol_mg_log = log2(pmol_mg_abs_delta + 0.01))

# Normalize pmol_mg_log within each lipid class and lipid composition
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  group_by(lipidClass, lipidComposition) %>%
  mutate(pmol_mg_log = scale(pmol_mg_log)) %>%
  ungroup()

# Combine lipidComposition and lipidClass into a single identifier
lipidomicsDF_filtered <- lipidomicsDF_filtered %>%
  mutate(lipid_id = paste(lipidClass, lipidComposition, sep = " "))





# Pivot the data to wide format
lipidomicsDF_wide <- lipidomicsDF_filtered %>%
  select(id, time, lipid_id, pmol_mg_log) %>%
  pivot_wider(names_from = lipid_id, values_from = pmol_mg_log)

lipidomicsDF_wide <- lipidomicsDF_filtered %>%
  select(id, time, pmol_mg, lipid_id) %>%
  pivot_wider(names_from = lipid_id, values_from = pmol_mg)



# Remove columns with all NA values
lipidomicsDF_wide <- lipidomicsDF_wide %>%
  select(where(~!all(is.na(.))))


# QC plots for each lipid composition within each lipid class
plot_switch <- 1
if (plot_switch == 1) {
  unique_lipid_classes <- unique(lipidomicsDF_filtered$lipidClass)
  for (lipid_class in unique_lipid_classes) {
    lipidomicsDF_filtered_class <- lipidomicsDF_filtered %>%
      filter(lipidClass == lipid_class)
    
    for (lipid_comp in unique(lipidomicsDF_filtered_class$lipidComposition)) {
      lipidomicsDF_filtered_comp <- lipidomicsDF_filtered_class %>%
        filter(lipidComposition == lipid_comp)
      
      # Combined scatter plot and boxplot
      combined_plot <- ggplot(lipidomicsDF_filtered_comp, aes(x = "", y = pmol_mg_log)) +
        geom_point(position = position_jitter(width = 0.2), alpha = 0.5) +
        geom_boxplot(alpha = 0.5) +
        labs(title = paste("Lipid", lipid_class, " ", lipid_comp),
             x = "",
             y = "log2 transformed -> scaled") +
        #ylim(-3, 3) +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 90, hjust = 1))
      
      # Replace / with _ in filenames
      safe_lipid_class <- gsub("/", ",", lipid_class)
      safe_lipid_comp <- gsub("/", ",", lipid_comp)
      
      # Save plot as a low-resolution image
      ggsave(filename = paste0("/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/PCA QC/", safe_lipid_class, "_", safe_lipid_comp, ".jpg"),
             plot = combined_plot, width = 5, height = 4, dpi = 144)
    }
  }
}

# Remove non-numeric columns for PCA
lipidomicsDF_numeric <- lipidomicsDF_wide %>%
  select(-id, -time)

# Perform PCA
pca_result <- prcomp(lipidomicsDF_numeric, center = FALSE, scale. = FALSE)

summary(pca_result)

# Create a dataframe for plotting
pca_df <- as.data.frame(pca_result$x)
pca_df$id <- lipidomicsDF_wide$id
#pca_df$time <- lipidomicsDF_wide$time

# Add group information from the original dataframe
pca_df <- pca_df %>%
  left_join(lipidomicsDF %>% select(id, group) %>% distinct(), by = "id")

# Plot the first two principal components
# Plot the first two principal components
plot <- ggplot(pca_df, aes(x = PC1, y = PC2, color = group, label = id)) +
  geom_point(size = 3) +
  #geom_text(vjust = 1.5, hjust = 1.5, size = 3) +
  labs(title = "PCA of Lipidomics Data",
       x = "Dim 1",
       y = "Dim 2") +
  theme_minimal() +
  theme(legend.position = "bottom")

print(plot)

```

# Table 1 
```{r}
####### Function to calculate p-values #########
pvalue <- function(x, name) {
  # Construct vectors of data y, and groups (strata) g
  y <- unlist(x)
  g <- factor(rep(1:length(x), times=sapply(x, length)))
  # Convert numeric levels in g to character labels
  levels(g) <- levels(mirage_included$group)
  
  ### OLD CODE
  # # Create a new data frame
  # data <- data.frame(y = y, g = g)
  # 
  # # Remove NA values for accurate t-test computation
  # data_clean <- na.omit(data)
  
  # ## Subset data to include only DIWL and WLEX groups
  # data_subset <- subset(data_clean, g %in% c("DIWL", "WLEX"))
  ###
  
  # make _post name of current variable
    name_post <- sub("_pre$", "_post", name)
  
    # make _change variable name
    name_change <- sub("_pre$", "_change", name)
    
    # Make a dataframe with relevant columns
    data <- mirage_included[c("id", "group", name, name_post)]
    
  if (is.numeric(y)) {  
   ### Old code
    # # Perform t-test on the subset
   #  p <- t.test(y ~ g, data = data_subset)$p.value
   #  ci <- t.test (y ~ g, data = data_subset)$conf.int
    
    # # Calculate P-value on change
    # 
    # # Filter and create the new data frame
    # p_change_subset <- mirage_included %>%
    #   filter(group %in% c("DIWL", "WLEX")) %>%
    #   select(g = group, y = !!sym(name_change))  # renaming columns in the select statement
    # 
    # 
    # p_change <- t.test (y ~ g, data = p_change_subset)$p.value
    # ci_change <- t.test (y ~ g, data = p_change_subset)$conf.int
    # 
    # ci_vals <- c(sprintf("[%0.2f, %0.2f]", ci[1], ci[2]),
    #              sprintf("[%0.2f, %0.2f]", ci_change[1], ci_change[2])
    # )
    
       # Make dataframe into long format
    data_long <- data %>%
      pivot_longer(
        cols = contains(c("pre", "post")),  # Select columns that contain "pre" or "post"
        names_to = "time",                  # Create a new column "time" for the names
        values_to = "value"                 # Create a new column "value" for the values
      )    %>% 
      mutate(
        time = ifelse(grepl("pre", time), "Pre", "Post")  # Simplify the time values to "Pre" or "Post"
      )
    
    ###
    # Ensure cols are factors
    data_long$group <- factor(data_long$group, levels = c("HED", "DIWL", "WLEX"))
    data_long$time <- factor(data_long$time, levels = c("Pre", "Post"))
    
    # Run mixed model
    model <- lmer(value ~ time * group +
           (1 | id),
         data = data_long)

    emm <- emmeans(model, ~ time * group)
    
    model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")
    model.slope.contrasts.results <- summary(model.slope.contrasts)
  
    prepost.contrasts <- pairs(emm, adjust = "none")
    prepost.contrasts.results <- summary(prepost.contrasts)
    
    # Baseline P-value between groups
    p <- prepost.contrasts.results$p.value[prepost.contrasts.results$contrast == "Pre DIWL - Pre WLEX"]
    # Baseline P-value between groups
    p_change <- model.slope.contrasts.results$p.value[model.slope.contrasts.results$group_pairwise == "DIWL - WLEX"]
      
    
    if (name_change == "age_change"){
      p_vals <- c(sub("<", "&lt;", format.pval(p, digits=2, eps=0.001)),
                      paste0("<i>", sub("<", "&lt;", format.pval(p_change, digits = 2, eps = 0.001)), "</i>")
  )
    } else {
      p_vals <- c(sub("<", "&lt;", format.pval(p, digits=2, eps=0.001)),
                    paste0("<i>", sub("<", "&lt;", format.pval(p_change, digits = 2, eps = 0.001)), "</i>")
  )
    }
    
    return(p_vals)
    
    # For categorical variables, do not return p-value
  } else {
    # p <- chisq.test(table(y, g))$p.value
    # p_vals <-c("", "", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
    # return (p_vals)
  }
}

#############

# FIlter data and calculate a % change column
mirage_included <- mirage_data %>%
  filter(id %in% lipidomicsDF$id) %>%
  mutate(
    weight_change = (weight_post - weight_pre) / weight_pre * 100,
    rd_ss2kg_ffm_insulin_change = (rd_ss2kg_ffm_insulin_post - rd_ss2kg_ffm_insulin_pre) / rd_ss2kg_ffm_insulin_pre * 100,
    bmi_change = (bmi_post - bmi_pre) / bmi_pre * 100,
    tdpa_change = (tdpa_post - tdpa_pre) / tdpa_pre * 100,
    vo2kg_ffm_change = (vo2kg_ffm_post - vo2kg_ffm_pre) / vo2kg_ffm_pre * 100,
    hgb_a1c_change = (hgb_a1c_post - hgb_a1c_pre) / hgb_a1c_pre * 100,
    cholesterol_change = (cholesterol_post - cholesterol_pre) / cholesterol_pre * 100,
    ldl_change = (ldl_post - ldl_pre) / ldl_pre * 100,
    hdl_change = (hdl_post - hdl_pre) / hdl_pre * 100,
    fat_mass_dxa_change = (fat_mass_dxa_post - fat_mass_dxa_pre) / fat_mass_dxa_pre * 100,
    lean_mass_dxa_change = (lean_mass_dxa_post - lean_mass_dxa_pre) / lean_mass_dxa_pre * 100,
    age_change = (age_post - age_pre) / age_pre * 100,
    thigh_muscle_g_change = (thigh_muscle_g_post - thigh_muscle_g_pre) / thigh_muscle_g_pre * 100,
    percent_imat_change = (percent_imat_post - percent_imat_pre) / percent_imat_pre * 100,
    triglycerides_change = (triglycerides_post - triglycerides_pre) / triglycerides_pre * 100,
    
    
    group = factor(group, levels = c("DIWL", "WLEX", "HED"))
  )

# Making discrete variables as factors
mirage_included$sex_0_male_1_female <- 
  factor(mirage_included$sex_0_male_1_female, levels=c(0,1),
         labels=c("Male", 
                  "Female"))

# mirage_included$t2d_status <-
#   factor(mirage_included$t2d_status, levels=c(1),
#          labels=c("Yes"))

mirage_included$t2d_status <-
  factor(mirage_included$t2d_status, levels=c(1),
         labels=c("Yes"))


# Set labels
label(mirage_included$sex_0_male_1_female) <- "Sex"
label(mirage_included$age_pre) <- "Age"
label(mirage_included$weight_pre) <- "Weight"
label(mirage_included$bmi_pre) <- "BMI"
label(mirage_included$rd_ss2kg_ffm_insulin_pre) <- "ᵃ Glucose R<sub>d</sub><br/>"
label(mirage_included$tdpa_pre) <- "ᵇ Physical activity"
label(mirage_included$hgb_a1c_pre) <- "HbA1c"
label(mirage_included$cholesterol_pre) <- "Total cholesterol"
label(mirage_included$ldl_pre) <- "LDL cholesterol"
label(mirage_included$hdl_pre) <- "HDL cholesterol"
label(mirage_included$t2d_status) <- "Type 2-diabetes"
label(mirage_included$fat_mass_dxa_pre) <- "Fat mass"
label(mirage_included$lean_mass_dxa_pre) <- "Lean mass"
label(mirage_included$thigh_muscle_g_pre) <- "Thigh muscle"
label(mirage_included$percent_imat_pre) <- "ᵃThigh IMAT"
label(mirage_included$vo2kg_ffm_pre) <- "VO₂ peak"
label(mirage_included$triglycerides_pre) <- "Triglycerides"


# Set units
# Set units for the variables using SI units
units(mirage_included$age_pre) <- "years"
units(mirage_included$weight_pre) <- "kg"
units(mirage_included$bmi_pre) <- "kg/m"
units(mirage_included$rd_ss2kg_ffm_insulin_pre) <- "(mg/kgFFM/min)/insulin"
units(mirage_included$tdpa_pre) <- "min"
units(mirage_included$hgb_a1c_pre) <- "%"
units(mirage_included$cholesterol_pre) <- "mmol/l" 
units(mirage_included$ldl_pre) <- "mmol/l"  
units(mirage_included$hdl_pre) <- "mmol/l"  
units(mirage_included$t2d_status)  # T2D status might be categorical (e.g., Yes/No, 0/1)
units(mirage_included$fat_mass_dxa_pre) <- "kg"  # Fat mass typically measured in kilograms
units(mirage_included$lean_mass_dxa_pre) <- "kg"  # Lean mass typically measured in kilograms
units(mirage_included$thigh_muscle_g_pre) <- "g"
units(mirage_included$percent_imat_pre) <- "%"
units(mirage_included$vo2kg_ffm_pre) <- "ml/kgFFM"
units(mirage_included$triglycerides_pre) <- "mmol/l"



# Footnote
footnote <-paste0 ("ᵃ Rate of glucose disposal (R<sub>d</sub>) normalized to fat-free mass and blood insulin<br/>", # <br/> used as linebreak for html table
                   # "ᵇ Intramuscular adipose tissue<br/>",
                   "ᵇ Minutes of daily physical activity above 1.5 metabolic equivalent of task (MET)")


# Define a custom render function
custom_render <- function(x, name, ...) {
  
  # Handling for numeric data
  if (is.numeric(x)) {
    
    group_mean <- mean(x, na.rm = TRUE)
    
    # Initialize the variable to store the current group
    current_group <- NA
    
    # Loop through each level of 'group' in the data frame
    for (group in levels(mirage_included$group)) {
      # Calculate the mean for the current group for the specified column
      group_mean_current <- mean(mirage_included[[name]][mirage_included$group == group], na.rm = TRUE)
      
      # Check if this group mean is equal to the overall mean
      if (group_mean == group_mean_current) {
        current_group <- group
        break  # Exit the loop once the first matching group is found
      }
    }
    
  # make _post name of current variable
    name_post <- sub("_pre$", "_post", name)
  
    # make _change variable name
    name_change <- sub("_pre$", "_change", name)
    
    # Make a dataframe with relevant columns
    data <- mirage_included[c("id", "group", name, name_post)]
    
    
    ### Run mixed model to get p-values for symbols
         # Make dataframe into long format
    data_long <- data %>%
      pivot_longer(
        cols = contains(c("pre", "post")),  # Select columns that contain "pre" or "post"
        names_to = "time",                  # Create a new column "time" for the names
        values_to = "value"                 # Create a new column "value" for the values
      )    %>% 
      mutate(
        time = ifelse(grepl("pre", time), "Pre", "Post")  # Simplify the time values to "Pre" or "Post"
      )
    
    ###
    # Ensure cols are factors
    data_long$group <- factor(data_long$group, levels = c("HED", "DIWL", "WLEX"))
    data_long$time <- factor(data_long$time, levels = c("Pre", "Post"))
    
    # Run mixed model
    model <- lmer(value ~ time * group +
           (1 | id),
         data = data_long)

    emm <- emmeans(model, ~ time * group)
    
    model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")
    model.slope.contrasts.results <- summary(model.slope.contrasts)
  
    prepost.contrasts <- pairs(emm, adjust = "none")
    prepost.contrasts.results <- summary(prepost.contrasts)
    
    ###
    
    
    
    if (current_group == "DIWL"){
      p <- prepost.contrasts.results$p.value[prepost.contrasts.results$contrast == "Pre DIWL - Post DIWL"]
      p_hed_pre <- prepost.contrasts.results$p.value[prepost.contrasts.results$contrast == "Pre HED - Pre DIWL"]
      p_hed_ch <- model.slope.contrasts.results$p.value[model.slope.contrasts.results$group_pairwise == "HED - DIWL"]
    } else if (current_group == "WLEX") {
      p <- prepost.contrasts.results$p.value[prepost.contrasts.results$contrast == "Pre WLEX - Post WLEX"]
      p_hed_ch <- model.slope.contrasts.results$p.value[model.slope.contrasts.results$group_pairwise == "HED - WLEX"]
      p_hed_pre <- prepost.contrasts.results$p.value[prepost.contrasts.results$contrast == "Pre HED - Pre WLEX"]
  } else if (current_group == "HED") {
      p <- prepost.contrasts.results$p.value[prepost.contrasts.results$contrast == "Pre HED - Post HED"]
      p_hed_pre <- NA
      p_hed_ch <- NA
  }else{
    p <- NULL; p_hed_ch <- NULL
        }
      
    # Number of decimal places to show
decimal_places <- 1

    # Calculate stats for baseline
    stats_pre <- stats.default(x)
  
    SD_stats_pre_rounded <- round(stats_pre$SD, decimal_places)
    MEAN_stats_pre_rounded <- round(stats_pre$MEAN, decimal_places)
    
    # Formatting the result to display one decimal place instead of no decimals if rounded to .0
MEAN_stats_pre_rounded <- format(MEAN_stats_pre_rounded, nsmall = decimal_places)
SD_stats_pre_rounded <- format(SD_stats_pre_rounded, nsmall = decimal_places)
    
    if (name == "rd_ss2kg_ffm_insulin_pre" ){
      mean_sd_pre <- with(stats.apply.rounding(stats_pre, digits = 2), 
                      c(sprintf("%s (%s)", MEAN, SD)))
    }else{
      mean_sd_pre <- sprintf("%s (%s)", MEAN_stats_pre_rounded, SD_stats_pre_rounded)
    }

    ### If constant number of digits are wished use:
    # mean_sd_pre <- with(stats.apply.rounding(stats_pre, digits = 2), 
    #                       c(sprintf("%s (%s)", MEAN, SD)))
    
# Calculate stats
stats_change <- stats.default(mirage_included[[name_change]][mirage_included$group == current_group])

# Round mean and standard deviation to the desired decimal places
MEAN_stats_change_rounded <- round(stats_change$MEAN, decimal_places)
SD_stats_change_rounded <- round(stats_change$SD, decimal_places)

# Format the mean and standard deviation with one decimal place
mean_sd_change <- sprintf("<i>%.1f (%.1f)", MEAN_stats_change_rounded, SD_stats_change_rounded)


### Old code to show number of digits instead of decimal places        
    # stats_change <- stats.default(mirage_included[[name_change]] [mirage_included$group == current_group])
    # mean_sd_change <- with(stats.apply.rounding(stats_change, digits = 2),
    #                        sprintf("<i>%s (%s)", MEAN, SD))
    # 
        
    # Don't calculate stat changes for age
    if (name == "age_pre" | name == "bmi_pre"){
      summary_stat <- c("Baseline" = mean_sd_pre)
    }else{
      summary_stat <- c("Baseline" = mean_sd_pre, "<i>%-change" = mean_sd_change)
    }
    
    
    # Rename "Mean (SD)2" to "Mean (SD) and add unit "
    names(summary_stat)[names(summary_stat) == "Baseline2"] <- paste0("baseline") # add to paste to add units: units(mirage_included[[name]])
    
    if (!is.na(p_hed_pre) && p_hed_pre < 0.05) {
      summary_stat[["Baseline"]] <- paste0 (summary_stat[["Baseline"]], "*") }
    
    if ("<i>%-change" %in% names(summary_stat) && !is.na(p_hed_ch) && p_hed_ch < 0.05) {
      summary_stat[["<i>%-change"]] <- paste0 (summary_stat[["<i>%-change"]], "*") }
    
    
    if ("<i>%-change" %in% names(summary_stat) && !is.na(p) && p < 0.05) {
  summary_stat[["<i>%-change"]] <- paste0("<b>", summary_stat[["<i>%-change"]], "</b>")
}
    
    # Handling for categorical data
  } else if (is.factor(x)) {
    
    #levels_stat <- paste(levels(x), collapse=", ")
    if (name == "t2d_status"){
      summary_stat <- c(sapply(stats.default(x), function(y) with(y,
                                                                      sprintf("%d (%0.0f %%)", FREQ, PCT))))
    }else {
    summary_stat <- c("", sapply(stats.default(x), function(y) with(y,
                                                                    sprintf("%d (%0.0f %%)", FREQ, PCT))))
    }
    
  } else {
    summary_stat <- "Unsupported data type"
  }
  return(summary_stat)
}


# Generate the table with custom rendering for weight
result_table <- table1(~ + age_pre + sex_0_male_1_female  + t2d_status + rd_ss2kg_ffm_insulin_pre + hgb_a1c_pre + 
                         bmi_pre + weight_pre + 
                         fat_mass_dxa_pre + lean_mass_dxa_pre + vo2kg_ffm_pre + tdpa_pre +
                          + triglycerides_pre + cholesterol_pre + ldl_pre + hdl_pre | group,
                       data = mirage_included,
                       render = custom_render,
                       footnote = footnote,
                       overall = FALSE,
                       extra.col=list(`P-value`=pvalue),
                       extra.col.pos = c(3))

# Print the table
print(result_table)
```

# Analysis based on changes

## Prepare data (function)

Function to prepare and merge data into wide format

Ouliers handling: pmol_mg imputed is used. For composition, only rows that are not outliers are fed to the functions, i.e. imputed col will be equal to the original column. For classes, imputed values are used to not get scewed class sums.

```{r}
# Function to prepare data
prepare_and_combine_data <- function(lipidomicsData, pre_post_cols, mirageData, lipidclass, lipidcomposition) {
  
  # Define a small function to calculate the number of non-zero rows
  non_zero_rows <- function(x) {
    sum(x > 0, na.rm = TRUE)
  }
  
  # Define the analysis cutoff
  analysis_cutoff <- 5
  # Filter and prepare lipidomics data
  if (is.null(lipidcomposition) || lipidcomposition == "ratio") {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
  } else {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass, lipidComposition == lipidcomposition) 
  }
  
  # Remove lipid composition within lipid class if fewer non-zero values than the analysis_cutoff. Only for lipidComposition. Add new col called to to_analyse in based on number of non_zero_rows
  non_zero_rows <- lipidomics_selected %>%
    filter(pmol_mg > 0)
  
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, lipidComposition, pmol_mg_imp)
  
  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = pmol_mg_imp, names_prefix = "pmol_mg_") %>%
    relocate(id, .before = everything()) # Moves id to front
  
  # Calculate delta value
  lipidomics_wide$pmol_mg_ch <- lipidomics_wide$pmol_mg_Post - lipidomics_wide$pmol_mg_Pre
  
  # Adding a small constant to avoid log2(0) if there are zeros
  pseudo_count <- 0.001
  # Calculate log2 fold change directly within the dataset
  lipidomics_wide <- lipidomics_wide %>%
    mutate(
      lipid_log2fold = if_else(
        is.na(pmol_mg_Post) | is.na(pmol_mg_Pre), 
        NA_real_,  # This ensures the result is NA where either pre or post is NA
        log2((pmol_mg_Post + pseudo_count) / (pmol_mg_Pre + pseudo_count))
      )
    )
  
  # Remove Na rows
  lipidomics_wide <- lipidomics_wide[!is.na(lipidomics_wide$pmol_mg_ch), ]
  
  # Calculate the abs change and abs change for each ID, then add them back to the original dataframe
  lipidomics_wide <- lipidomics_wide %>%
    group_by(id) %>%
    # Calculate sum of abs fold change for each ID
    mutate(lipid_log2fold_id_avg = mean(lipid_log2fold, na.rm = TRUE),
           # Calculate absolute change for each ID
           pmol_mg_ch_id = sum(pmol_mg_Post, na.rm = TRUE) - sum(pmol_mg_Pre, na.rm = TRUE),
           # Assign row number for each group to identify the first occurrence
           row_num = row_number()) %>%
    # Calculate log2fold change for each ID across all points
    mutate(lipid_log2fold_id = log2((sum(pmol_mg_Post, na.rm = TRUE) + pseudo_count) / 
                                      (sum(pmol_mg_Pre, na.rm = TRUE) + pseudo_count))) %>%
    ungroup() %>%
    # Only retain the calculated values for the first occurrence of each ID
    mutate(lipid_log2fold_id_avg = if_else(row_num == 1, lipid_log2fold_id_avg, NA_real_),
           pmol_mg_ch_id = if_else(row_num == 1, pmol_mg_ch_id, NA_real_),
           lipid_log2fold_id = if_else(row_num == 1, lipid_log2fold_id, NA_real_)) %>%
    # Remove the auxiliary row number column
    select(-row_num)
  
  
  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")
  
  # Loop through all lists
  for (j in 1:length(pre_post_cols)){
    for (g in 1:length (pre_post_cols[[j]])){
      pre_col <- pre_post_cols[[j]][[g]][1]
      post_col <- pre_post_cols[[j]][[g]][2]
      delta_col_name <- paste0(sub("_pre", "", pre_col), "_ch")
      
      # Calculate deltas
      combined_df <- combined_df %>%
        mutate(!!sym(delta_col_name) := as.numeric(.[[post_col]]) - as.numeric(.[[pre_col]]))
    }
  }
  # }
  # Convert specified columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))
  
  # If lipid composition 
  if (!is.null(lipidcomposition) & nrow(non_zero_rows) < analysis_cutoff){
    combined_df$skipAnalysis <- TRUE
  }else{
    combined_df$skipAnalysis <- FALSE
  }
  return(combined_df)
}
```


## Statistics (function)

Function to get correlation between changes of defined parameters

```{r}
# Define a function to compute correlations of change
correlation_of_change <- function(corr_df, lipidomicsDF, mirage_data_long_ch, mirage_variables_of_interest, lipidclass, lipidcomposition) {
  
  # Determine the lipid name based on the presence of lipid composition
  if (!is.null(lipidcomposition) && lipidcomposition != "ratio")  {
    lipidName <- paste0(lipidclass, " ", lipidcomposition)
  } else {
    lipidName <- lipidclass
  }
  

    # Initialize an empty data frame to store correlation results
    correlation_results <- data.frame(
      lipid = character(),
      test_against = character(),
      pearson_r_all = numeric(),
      pearson_p_all = numeric(),
      spearman_rho_all = numeric(),
      spearman_p_all = numeric(),
      mixed_cor_all = numeric(),
      mixed_p_all = numeric(),
      pearson_r_HED = numeric(),
      pearson_p_HED = numeric(),
      spearman_rho_HED = numeric(),
      spearman_p_HED = numeric(),
      pearson_r_DIWL = numeric(),
      pearson_p_DIWL = numeric(),
      spearman_rho_DIWL = numeric(),
      spearman_p_DIWL = numeric(),
      pearson_r_WLEX = numeric(),
      pearson_p_WLEX = numeric(),
      spearman_rho_WLEX = numeric(),
      spearman_p_WLEX = numeric()
      )

    
    # Loop over every mirage variables of interest
    for (j in 1:length(mirage_variables_of_interest)){
      for (g in 1:length (mirage_variables_of_interest[[j]])){
       
         test_against_name <- mirage_variables_of_interest[[j]][[g]][[1]]
        test_against_name_clean <- sub("_pre$", "", test_against_name)
        test_against_name <- sub("pre$", "ch", test_against_name)
        
        # Add new row to output df
        correlation_results <- add_row(correlation_results)
        
        # Identify the index of the current row
        current_row_index <- nrow(correlation_results)
        
        # Assign lipid name and test against to last row
        correlation_results$lipid[current_row_index] <- lipidName
        correlation_results$test_against[current_row_index] <- test_against_name
        
        
        # Only run code if correlation df is not NA. If, Na, assign NA values to all correlation results
        if (corr_df$skipAnalysis[[1]] == TRUE){
          # Assign NA to all results
          correlation_results$pearson_r_all[current_row_index] <- NA
          correlation_results$pearson_p_all[current_row_index] <- NA
          correlation_results$spearman_rho_all[current_row_index] <- NA
          correlation_results$spearman_p_all[current_row_index] <- NA
          correlation_results$mixed_cor_all[current_row_index] <- NA
          correlation_results$mixed_p_all[current_row_index] <- NA
          correlation_results$pearson_r_HED[current_row_index] <- NA
          correlation_results$pearson_p_HED[current_row_index] <- NA
          correlation_results$spearman_rho_HED[current_row_index] <- NA
          correlation_results$spearman_p_HED[current_row_index] <- NA
          correlation_results$pearson_r_DIWL[current_row_index] <- NA
          correlation_results$pearson_p_DIWL[current_row_index] <- NA
          correlation_results$spearman_rho_DIWL[current_row_index] <- NA
          correlation_results$spearman_p_DIWL[current_row_index] <- NA
          correlation_results$pearson_r_WLEX[current_row_index] <- NA
          correlation_results$pearson_p_WLEX[current_row_index] <- NA
          correlation_results$spearman_rho_WLEX[current_row_index] <- NA
          correlation_results$spearman_p_WLEX[current_row_index] <- NA
          
          }else{
        
        # Use pmol_mg_ch for composition within group. Use pmol_mg_ch for all compositions within class.
        if (is.null(lipidcomposition) || lipidcomposition != "ratio") {
          lipid_unit <- "pmol_mg_ch_id"
        } else {
          lipid_unit <- "pmol_mg_ch"
        }
        
        # Perform Pearson and Spearman correlations for all data
        result_pearson_all <- correlation(corr_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
        result_spearman_all <- correlation(corr_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
        
        
        # Assign results the the results df
        correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
        correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
        correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
        correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p
        
        # Calculate correlations for each group
        for (current_group in unique(corr_df$group)) {
          # Filter the dataframe for the current group
          correlation_df_group <- filter(corr_df, group == current_group)
          
          # Perform Pearson and Spearman correlations for the current group
          result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
          result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
          
          # Dynamic assignment of results based on the current group
          pearson_r_col <- paste0("pearson_r_", current_group)
          pearson_p_col <- paste0("pearson_p_", current_group)
          spearman_rho_col <- paste0("spearman_rho_", current_group)
          spearman_p_col <- paste0("spearman_p_", current_group)
          
          correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
          correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
          correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
          correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
        }
        correlation_results$mixed_p_all[current_row_index] <- NA
        correlation_results$mixed_cor_all[current_row_index] <- NA
          }
        # Merge this transformed subset with 'lipidomicsDF' based on 'id' and 'time'
        merged_data <- left_join(lipidomicsDF, mirage_data_long_ch, by = c("id", "time"))
        
      
    }
    }
    
  return(correlation_results)
}
```

## Plot, scatter (function)

```{r}
correlation_change_plot <- function(correlation_df, mirage_ch_vars, correlation_results, savePath, lipidclass, lipidcomposition) {
  
  # Make lipid name
  if (!is.null(lipidcomposition) && lipidcomposition != "ratio") {
    lipidName <- paste0(lipidclass, " ", lipidcomposition)
  } else {
    lipidName <- lipidclass
  }
  
  
  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pmol_mg_ch))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_ch_vars, function(category) {
      lapply(category, function(item) sub("_pre", "_ch", item[1]))
    }), recursive = FALSE), use.names = FALSE)
    
    
    
    # If lipidcomposition is null, then only plot class
    if (!is.null(lipidcomposition) && lipidcomposition != "ratio") {
      # Add lipid variable to plotVars
      plotVars <- c("pmol_mg_ch", plotVars)
      
      # Now use ggpairs on the renamed dataframe
      pm <- ggpairs(correlation_df,
                    mapping = aes(color = group),
                    columns = plotVars,
                    lower = list(continuous = wrap("smooth", method = "none", se = FALSE))
      )
    } else {
      # Add lipid variable to plotVars
      # Make plot with log2 fold change if only class is available
      plotVars <- c("pmol_mg_ch_id", plotVars)
      
      pm <- ggpairs(correlation_df,
                    mapping = aes(color = group),
                    columns = plotVars
      )
    }
    
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }
    
    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)
      
      
      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
                                        x = Inf, y = Inf,
                                        label = paste0(
                                          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
                                          #", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
                                          
                                          "All: Spearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
                                          "    |    rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
                                          #"\nHED: Pearson, p = ", formatC(correlation_row$pearson_p_HED, format = "f", digits = 3),
                                          #", r = ", formatC(correlation_row$pearson_r_HED, format = "f", digits = 3),
                                          "\nHED: Spearman, p = ", formatC(correlation_row$spearman_p_HED, format = "f", digits = 3),
                                          "    |    rho = ", formatC(correlation_row$spearman_rho_HED, format = "f", digits = 3),
                                          #"\nDIWL: Pearson, p = ", formatC(correlation_row$pearson_p_DIWL, format = "f", digits = 3),
                                          #", r = ", formatC(correlation_row$pearson_r_DIWL, format = "f", digits = 3),
                                          "\nDIWL: Spearman, p = ", formatC(correlation_row$spearman_p_DIWL, format = "f", digits = 3),
                                          "    |    rho = ", formatC(correlation_row$spearman_rho_DIWL, format = "f", digits = 3),
                                          #"\nWLEX: Pearson, p = ", formatC(correlation_row$pearson_p_WLEX, format = "f", digits = 3),
                                          #", r = ", formatC(correlation_row$pearson_r_WLEX, format = "f", digits = 3),
                                          "\nWLEX: Spearman, p = ", formatC(correlation_row$spearman_p_WLEX, format = "f", digits = 3),
                                          "    |    rho = ", formatC(correlation_row$spearman_rho_WLEX, format = "f", digits = 3),
                                          "\n*****p-values are not adjusted*****"
                                        ),
                                        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }
    
    
    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }
    
    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }
    
    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }
  
  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )
  
  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
}
```

## Run functions

```{r}
# Save folder for .jpg output files
savePathClassComp <- paste0(getwd(), "/outputs/correlations in changes/scatter composition/")


savePathClass <- paste0(getwd(), "/outputs/correlations in changes/scatter class/")

# Initialize an empty data frame to hold all correlation values
correlation_values_ch_composition <- data.frame()
correlation_values_ch_class <- data.frame()

# Loop over each lipid composition
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
for (lipid_class in unique_lipid_classes[!unique_lipid_classes == "PC.PE"]) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {

    print( paste0 ("Analysing: ", lipid_class, " ", lipid_composition, "..."))
    # Organize data
    correlation_df <- prepare_and_combine_data(
      lipidomicsData = lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),],
      pre_post_cols = mirage_ch_vars,
      mirageData = mirage_data,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition
    )

    # Calculate correlations for changes
    correlation_values_ch_composition <- rbind(correlation_values_ch_composition, correlation_of_change(
      corr_df = correlation_df,
      lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),],
      mirage_data_long_ch,
      mirage_ch_vars,
      lipid_class,
      lipid_composition))

    #  # Plot data - Comment out if to be used
    #  correlation_change_plot(
    #    correlation_df,
    #    mirage_ch_vars,
    #    correlation_values_ch_composition,
    #    savePathClassComp,
    #    lipid_class,
    #    lipid_composition
    # )
  }
}

# Loop over each lipid class and make plots
for (lipid_class in unique_lipid_classes) { # [!unique_lipid_classes == "Cer ratio"]
  print( paste0 ("Analysing lipid class: ", lipid_class, "..."))
  # Organize data
  correlation_df <- prepare_and_combine_data(
    lipidomicsData = lipidomicsDF,
    pre_post_cols = mirage_ch_vars,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    lipidcomposition = NULL
  )
  
  # Calculate correlations for changes
  correlation_values_ch_class <- rbind(correlation_values_ch_class,
                                       correlation_of_change(
                                         correlation_df,
                                         lipidomicsDF,
                                         mirage_data_long_ch,
                                         mirage_ch_vars,
                                         lipid_class,
                                         lipidcomposition = NULL))
  
  # # Plot data - un-comment if to be used again
  #  correlation_change_plot(
  #    correlation_df,
  #    mirage_ch_vars,
  #    correlation_values_ch_class,
  #    savePathClass,
  #    lipid_class,
  #    lipidcomposition = NULL
  #  )
}

## SAVE AND LOAD VARIABLES TO NOT HAVE TO RERUN ALL THE ANALYSIS
# Define the path to save/load folder
# save_variable_path <- paste0(getwd(), "/outputs/saved variables/")
# 
# # Specify filenames for each variable
# file_correlation_values_ch_composition <- paste0(save_variable_path, "correlation_values_ch_composition.rds")
# file_correlation_values_ch_class <- paste0(save_variable_path, "correlation_values_ch_class.rds")
# 
# Save the variables
# saveRDS(correlation_values_ch_composition, file = file_correlation_values_ch_composition)
#saveRDS(correlation_values_ch_class, file = file_correlation_values_ch_class)

# OR LOAD VARIABLES
# correlation_values_ch_composition <- readRDS(file = file_correlation_values_ch_composition)
# correlation_values_ch_class <- readRDS(file = file_correlation_values_ch_class)

```

# ! Waterfall
```{r}
correlation_waterfall <- function(clinical_var){

# Filter, rename, and sort the dataframe
corr_ordered <- correlation_values_ch_class %>%
  filter(test_against %in% clinical_var[[1]]) %>% 
  mutate(lipid = ifelse(lipid == "PC.PE", "PC/PE", lipid)) %>% 
  filter(lipid != "Cer ratio") %>% 
  arrange(spearman_rho_all)

# Ensure 'lipid' is a factor and set its levels based on the sorted order
corr_ordered$lipid <- factor(corr_ordered$lipid, levels = corr_ordered$lipid)

# Get significance helper function
get_significance <- function(p_value) {
  if (p_value < 0.001) {
    return("***")
  }else if (p_value < 0.01){
    return("**")
    } else if (p_value < 0.05) {
    return("*")
  } else {
    return("")
  }
}

corr_ordered$significance <- sapply(corr_ordered$spearman_p_all, get_significance)
# Define your color mapping function
color_mapping_common <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

# Make non significant grey
# corr_ordered$color <- ifelse(corr_ordered$significance == "",
#                              "grey",
#                              color_mapping_common(corr_ordered$spearman_rho_all))

# All bars colored
corr_ordered$color <- color_mapping_common(corr_ordered$spearman_rho_all)


plot <- ggplot(corr_ordered, aes(lipid, spearman_rho_all)) +
   geom_col(aes(fill = color), 
            color = "black", linewidth = 1) +
  #geom_col(aes(fill = ifelse(significance == "", "grey", ifelse(spearman_rho_all > 0, "positive", "negative"))),
   #        color = "black", size = 1) +
  geom_text(aes(label = significance,
                y = ifelse(spearman_rho_all > 0, -0.05, 0.05),
                hjust = ifelse (spearman_rho_all > 0, 1, 0) ), # Adjust vertical position
            vjust = 0.8,      # Center the text horizontally
            size = 4) +      # Enlarge the size of asterisks
  coord_flip() +
  labs(x = "Predictor Variable", y = expression("Spearman's " * rho), title = clinical_var[[2]]) +
   scale_fill_identity() + 
   #scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, limits = c(-1, 1), guide = "none") +
  geom_hline(yintercept = 0, color = "black", linewidth = 1) +
  #scale_fill_manual(values = c(positive = "#FFB3B3", negative = "#B3C7E6", grey = "grey"), guide = "none") +
  ylim(-as.numeric(clinical_var[3]), as.numeric(clinical_var[[3]])) +
  theme(panel.background = element_rect("transparent"),
        axis.text = element_text(color = "black", size = 9),
        plot.background = element_rect(fill='transparent', color=NA),
        axis.title.y = element_blank(),
        axis.text.y = element_text(size = 7),
        axis.title.x = element_text(size = 7, color = "black"),
        axis.text.x = element_text(size = 7),
        axis.line = element_line(linewidth = 1),
        plot.title = element_text(hjust = .5, face = "bold", size = 8))
    

ggsave(paste0(getwd(), "/outputs/figures/change correlations/waterfall/", clinical_var[[1]], ".svg"), plot, device = "pdf", height = 80, width = 55 , units = "mm", bg = "transparent")

print(plot)
}

# Define clinical var c(var_name, plot_title, x-lim)
clinical_var <- list(
  c("weight_ch", bquote(bold("Body weight")), .7),
  c("tdpa_ch", bquote(bold("Total daily physical activity")), .7),
  c("rd_ss2kg_ffm_insulin_ch", bquote(bold("Rate of glucose disposal")), .7),
  c("percent_imat_ch", bquote(bold("Thigh IMAT proportion")), .7),
  c("vo2kg_ffm_ch", bquote(bold(VO[2] ~ "per kg FFM")), .7),
  c("hgb_a1c_ch", bquote(bold("Hemoglobin A1c")), .7),
  c("pcr_p_mrs_ch", bquote("PCr recovery"), .7),
  c("max_oxphos_ch", bquote("Max oxidative phosphorylation"), .7)
)

for (var in clinical_var){
  correlation_waterfall(var)
}
```

# ! Heatmap of compositions
```{r}
 generate_heatmap <- function(colorMap, pLims, hm_title, hm_unit, lipid_class, clin_var){
  
   # Create new columns 'lipidClass' and 'lipidComposition' using base R
res_lipid_names <- correlation_values_ch_composition %>%
  filter(!is.na(spearman_rho_all)) %>%  # Remove rows where spearman_corr_all is NA
  mutate(
    lipidClass = sapply(strsplit(as.character(lipid), " "), `[`, 1),
    lipidComposition = sapply(strsplit(as.character(lipid), " "), `[`, 2)
  ) %>%
  filter(lipidComposition != "ratio")  # Removed cer ratio

# Filter data for lipidClass 
filtered_data <- res_lipid_names[res_lipid_names$lipidClass == lipid_class & res_lipid_names$test_against == clin_var[[1]], ]

# Create a matrix
heatmap_matrix.corr <- as.matrix(filtered_data[, "spearman_rho_all", drop = FALSE])
heatmap_matrix.p <- as.matrix(filtered_data[, "spearman_p_all", drop = FALSE])
rownames(heatmap_matrix.corr) <- filtered_data$lipidComposition
rownames(heatmap_matrix.p) <- filtered_data$lipidComposition


hm_matrix <- t(heatmap_matrix.corr)
p_val_matrix <- t(heatmap_matrix.p)


ht_opt$ROW_ANNO_PADDING <- unit(0, "mm")
   hm <- Heatmap(hm_matrix,
          name = hm_unit, # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          
          show_row_names = FALSE, # Remove row labels
          
          # row_title = lipids_groups[[i]][2],
          row_title_gp = gpar(fontsize = 6, fontface = "bold"),
          row_title_rot = 0,
          
          column_title = lipids_groups[[i]][2],
          column_names_rot = 90, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 5),
           column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 6, fontface = "bold", lineheight = 0.2),
          
          
          
          heatmap_legend_param = list(
            title = bquote(bold("Spearman's"~rho)),   # Legend title
            direction = "vertical",  # Set legend labels vertically
            title_gp = gpar(fontsize = 6, fontface = "bold"),   # Adjust title font size
            labels_gp = gpar(fontsize = 5),  # Adjust label font size
            color_key_height = unit(0.3, "cm"),  # Adjust the color key height
            color_key_width = unit(.8, "cm"),     # Adjust the color key width
            legend_width = unit(2, "cm"),        # Adjust the width of the legend box
            legend_height = unit(1.5, "cm"),      # Adjust the height of the legend box
            title_position = "topcenter"        # Move the title to the top center of the legend
          ),
          show_heatmap_legend = lipids_groups[[i]][5],
          
          
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
         cell_fun = function(j, i, x, y, width, height, fill) {
                
if (is.na(hm_matrix[i, j])) {
  grid.rect(unit(x, "npc"), unit(y, "npc"), width, height, gp = gpar(fill = "grey", col = NA))
} else if (!is.na(p_val_matrix[i, j])) {
  if (p_val_matrix[i, j] < pLims$p1) {
    grid.text("*\n*\n*", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 5, fontface = "bold", lineheight = 0.4), just = "center")
  } else if (p_val_matrix[i, j] < pLims$p2) {
    grid.text("*\n*", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 5, fontface = "bold", lineheight = 0.4), just = "center")
  } else if (p_val_matrix[i, j] < pLims$p3) {
    grid.text("*", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 5, fontface = "bold", lineheight = 0.4), just = "center")
                  }
            }
          })
   
   savelocation_svg <- paste0(getwd(), "/outputs/figures/change correlations/waterfall/heatmaps/", clin_var[[1]], "/", lipids_groups[[i]][2], ".svg")
   dir.create(dirname(savelocation_svg), recursive = TRUE, showWarnings = FALSE)
   
   height <- as.double(lipids_groups[[i]][3])
   width <- as.double(lipids_groups[[i]][4])
   
   pdf(savelocation_svg, width = width, height = height) # dimensions in inches
   
   # Set the background to transparent
   
   draw(hm,
        heatmap_legend_side = "right", 
        annotation_legend_side = "right",
        background = "transparent"
   )
   
   # Close the device
   dev.off()
   
 }

# Define color map for heatmap
color_mapping_common <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)


lipids_groups <- list(
  gr_tag_ac = c("TAG", "Triacylglycerol", 0.65, 2.3, FALSE, "row_title"),
  gr_1_2_dg = c("1,2-DG", "1,2-diacylglycerol", 0.82, 2.4, FALSE, "row_title"),
  gr_1_3_dg = c("1,3-DG", "1,3-diacylglycerol", 0.82, 1.7, FALSE, "row_title"),
  gr_ac = c("AC", "Acylcarnitine", 0.67, 1.1, FALSE, "row_title"),
  gr_cer = c("Cer", "Ceramide", 0.65, .8, FALSE, "row_title"),
  gr_dhcer = c("dhCer", "Dihydroceramide", 0.65, .69, FALSE, "row_title"),
  gr_glucer = c("GluCer", "Glucosylceramide", 0.65, .73, FALSE, "row_title"),
  gr_laccer = c("LacCer", "Lactosylceramide", 0.65, .72, FALSE, "row_title"),
  gr_sph = c("SPH", "Sphingosine", 0.65, 1.5, FALSE, "row_title"),
  gr_spm = c("SPM", "Sphingomyelin", 0.65, .9, FALSE, "row_title"),
  gr_pc = c("PC", "Phosphatidylcholine", 0.85, 5.4, FALSE, "row_title"),
  gr_pe = c("PE", "Phosphatidylethanolamine", 0.85, 5.4, FALSE, "row_title"),
  gr_pc_pe = c("PC.PE", "Phosphatidylcholine.Phosphatidylethanolamine", 0.85, 5, FALSE, "row_title"),
  gr_pa = c("PA", "Phosphatidic acid", 0.82, 2.3, FALSE, "row_title"),
  gr_pg = c("PG", "Phosphatidylglycerol", 0.82, 1.5, FALSE, "row_title"),
  gr_ps = c("PS", "Phosphatidylserine", 0.82, 2.3, FALSE, "row_title"),
  gr_pi = c("PI", "Phosphatidylinositol", 0.82, 2.3, FALSE, "row_title"),
  gr_lpc = c("LPC", "Lysophosphatidylcholine", 0.65, 1.1, FALSE, "col_title"),
  gr_lpe = c("LPE", "Lysophosphatidylethanolamine", 0.65, 1.25, FALSE, "col_title"),
  gr_lpg = c("LPG", "Lysophosphatidylglycerol", 0.65, 1.05, FALSE, "col_title"),
  gr_lpi = c("LPI", "Lysophosphatidylinositol", 0.65, 1, FALSE, "col_title"),
  gr_lps = c("LPS", "Lysophosphatidylserine", 0.65, 1, FALSE, "col_title")
)


# Define clinical var c(var_name, plot_title, x-lim)
clinical_var <- list(
  c("weight_ch", bquote("Body weight"), .7),
  c("tdpa_ch", bquote("Total daily physical activity"), .7),
  c("rd_ss2kg_ffm_insulin_ch", bquote("Rate of glucose disposal"), .7),
  c("percent_imat_ch", bquote("Thigh IMAT proportion"), .7),
  c("vo2kg_ffm_ch", bquote(VO[2] ~ "per kg FFM"), .7),
  c("hgb_a1c_ch", bquote("Hemoglobin A1c"), .7),
  c("pcr_p_mrs_ch", bquote("PCr recovery"), .7),
  c("max_oxphos_ch", bquote("Max oxidative phosphorylation"), .7)
)


for (i in 1:length(lipids_groups)){
  for (var in clinical_var){
    hm <- generate_heatmap(color_mapping_common,
                           p_value_limits,
                           hm_title = "", 
                           hm_unit = "Spearman's ρ",
                           lipid_class = lipids_groups[[i]][1],
                           clin_var = var)
  }
}

```

# ! Publication: correlation grid
```{r}

# Correlation plot function
correlation_plots_publication <- function (plot_lipids, col_titles, selected_clinical, row_titles, y_lims, lipidomicsDF, save_size, save_name){

for (j in 1:length(selected_clinical)) {
  if (j == 1){
    plot_list <- list()
  }
  for (i in 1:length(plot_lipids)) {
    # Organize data and pick top
    correlation_df <- prepare_and_combine_data(
      lipidomicsData = lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),],
      pre_post_cols = mirage_ch_vars,
      mirageData = mirage_data,
      lipidclass = plot_lipids[i],
      lipidcomposition = NULL
    )
    
    # Create change name
    var_name_ch <- gsub("_pre$", "_ch", selected_clinical[[j]][[1]])
    
      # Custom function to format p-values
  format_p_value <- function(p_value, digits = 3, threshold = 0.001) {
    if (p_value < threshold) {
      return(paste0("P<", formatC(threshold, format = "f", digits = digits)))
    } else {
      return(paste0("P=", formatC(p_value, format = "f", digits = digits)))
    }
  }
    rho <- correlation_values_ch_class$spearman_rho_all[correlation_values_ch_class$lipid == plot_lipids[[i]] & correlation_values_ch_class$test_against == var_name_ch]
    p_value <- correlation_values_ch_class$spearman_p_all[correlation_values_ch_class$lipid == plot_lipids[[i]] & correlation_values_ch_class$test_against == var_name_ch]
    
    p_value_formated <- format_p_value(p_value)
    
    
        # Prepare labels
    y_label <- (selected_clinical[[j]][[3]])
    x_label <- bquote(Delta * " " * pmol %.% mg^{-1})
    
    
    # Make TAG, PE and PG nmol instead of pmol
if (plot_lipids[i] %in% c("TAG", "1,2-DAG", "1,3-DAG", "PE", "PC", "PI")) {
  correlation_df$pmol_mg_ch_id <- correlation_df$pmol_mg_ch_id / 1000
  x_label <- bquote(Delta * " " * nmol %.% mg^{-1})
}
    
    # Make PC/PE percentage point
        if (plot_lipids[i] %in% c("PC.PE", "Cer ratio")) {
      correlation_df$pmol_mg_ch_id <- correlation_df$pmol_mg_ch_id * 100  # Make pct point
  x_label <- bquote("pp")
  }

  
    # Create the plot with a black trendline
 plot <- ggplot(correlation_df, aes(x = pmol_mg_ch_id, y = !!sym(var_name_ch), shape = group, fill = gender)) +
      geom_point(size = 0.9, stroke = 0.5, color = "black") +
       labs(
    x = x_label,
    y = if (i == 1) selected_clinical[[j]][[3]] else NULL,
    color = "Gender",
    fill = "Gender"
  ) +
  scale_fill_manual(values = c("F" = "orange", "M" = "turquoise")) +  # Define fill colors for gender
  scale_shape_manual(values = c("HED" = 21, "DIWL" = 24, "WLEX" = 22)) +  # Define shapes for group
       scale_x_continuous(breaks = scales::breaks_extended(n = 4.5)) +  # Adjust the number of ticks on the x-axis to 3
      scale_y_continuous(
        limits = c(y_lims[[j]][1], y_lims[[j]][2])
        # , sec.axis = if (i == length(plot_lipids)) sec_axis(~ ., name = y_label) else waiver()
      ) +
      theme_minimal() +
        theme(
          legend.position = "none",
          plot.margin = margin(1, 1, 1, 1),
          
          axis.title.y = element_text(size = 7.5, face = if (i == 1) "bold" else "plain"),  # Set text size for left y-axis title
          axis.text.y = element_text(size = 5.5, face = if (i == 1) "bold" else "plain"),  # Set text size for left y-axis text
          
          # axis.title.y.right = element_text(size = 8),  # Set text size for right y-axis title
          # axis.text.y.right = element_text(size = 7),  # Set text size for right y-axis text
          
          axis.title.x = element_text (size = 8),
          axis.text.x = element_text(size = 6)  # Adjust text size for x-axis text
          
          # panel.background = element_rect("transparent"),
          # plot.background = element_rect(fill='transparent', color=NA)
        ) +
      if (p_value < 0.05){
 annotate("text", x = -Inf, y = Inf, label = paste0("rs=", round(rho, 2), "\n", p_value_formated), 
           hjust = -.1, vjust = 1.1, size = 2, fontface = "bold", color = "black", check_overlap = T)
      } else {
        annotate("text", x = -Inf, y = Inf, label = paste0("rs=", round(rho, 2), "\n", p_value_formated), 
           hjust = -.1, vjust = 1.1, size = 2, fontface = "plain", color = "black", check_overlap = T)
      }
    
 # Add trendlines based on P-values
  if (p_value < 0.05) {
    plot <- plot + geom_smooth(aes(group = 1), method = "lm", se = TRUE, color = "black", alpha = 0.3, linewidth = 0.5)
  } else if (p_value < 0.1) {
    plot <- plot + geom_smooth(aes(group = 1), method = "lm", se = FALSE, color = "black", linewidth = 0.5, linetype = "dashed")
  }
 
 
    
    # Add column titles only for the first row with adjusted size and bold
    if (j == 1) {
      plot <- plot + ggtitle(col_titles[i]) + theme(
        plot.title = element_text(size = 7.5, face = "bold", hjust = 0.5)
      )
    }
    
    # Remove y-axis labels for non-first columns
    if (i != 1) {
      plot <- plot + theme(
        axis.title.y = element_blank()
      )
    }
    
    # Remove y-axis ticks and text for all but the last column
    if (i != 1) {
      plot <- plot + theme(
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()
      )
    }

    # Remove x-axis text and ticks for all but the last row
    if (j != length(selected_clinical)) {
      plot <- plot + theme(
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank()
      )
    }
    
      plot_list[[length(plot_lipids) * (j - 1) + i]] <- plot
    }
}
  
# Combine plokg/min", "m", "kg")ng patchwork
plot_grid <- wrap_plots(plot_list, ncol = length(plot_lipids), nrow = length(selected_clinical)) +
  plot_layout(guides = "collect", widths = rep(1, length(plot_lipids)), heights = rep(1, length(selected_clinical)))
  

# Display the grid of plots
# print(plot_grid)

# Save the grid of plots in SVG format
ggsave(paste0(getwd(), "/outputs/figures/change correlations/grid plots/", save_name, ".svg"), plot_grid, device = "pdf", height = save_size[1], width = save_size[2] , units = "mm")
}

# Selected clinical
clinical_vars <- list(
  c("rd_ss2kg_ffm_insulin_pre", "rd_ss2kg_ffm_insulin_post", bquote(atop(NA, atop(textstyle(bold("Rate of glucose disposal")), textstyle(Delta * " " * "mg ·(min·kgFFM·ins)"^{-1}))))),
  c("hgb_a1c_pre", "hgb_a1c_post", bquote(atop(NA, atop(textstyle(bold(HbA1c)), textstyle(Delta * " " * "%"))))),
  c("vo2kg_ffm_pre", "vo2kg_ffm_post", bquote(atop(NA, atop(textstyle(bold(VO[2] * " peak")), textstyle(Delta * " " * "ml · kgFFM"^{-1}))))),
  c("tdpa_pre", "tdpa_post", bquote(atop(NA, atop(textstyle(bold("Physical activity")), textstyle(Delta * " " * ( "min · day"^{-1})))))),
  c("weight_pre", "weight_post", bquote(atop(NA, atop(textstyle(bold("Body weight")), textstyle(Delta * " " * "kg"^{-1}))))),
  c("percent_imat_pre", "percent_imat_post", bquote(atop(NA, atop(textstyle(bold("Thigh IMAT")), textstyle("pp"))))),
  
  c("pcr_p_mrs_pre", "pcr_p_mrs_post", bquote(atop(NA, atop(textstyle(bold("PCr recovery")), textstyle(Delta * " " * tau * " " * "(s)"))))),
  
  c("max_oxphos_pre", "max_oxphos_post", bquote(atop(NA, atop(textstyle(bold("Max ox phosphorylation")), textstyle("pmol O"[2] ~ "· sec"^{-1} ~ "· mg"^{-1})))))

  #c("age_pre", "age_post", "Age (years)"),
  #c("weight_pre", "weight_post", "Body mass (kg)" ),
)



#"Oxygen~uptake~(l %.% min^{-1} %.% kgFFM^{-1})")


clinical_limits <- list(
  c(min = -0.1, max = 0.15), 
  c(min = -3.0, max = 2), 
  c(min = -4, max = 3),
  c(min = -100, max = 300),
  c(min = -25, max = 5),
  c(min = -5, max = 5),
  c(min = -10, max = 10),
  c(min = -25, max = 50)
  )

# Info about each plot class
TAG_plot_lipids <- c("TAG","1,2-DG", "1,3-DG", "AC")
TAG_plot_colNames <- c("TAG", "1,2-DAG", "1,3-DAG", "AC")

correlation_plots_publication(plot_lipids = TAG_plot_lipids,
                              col_titles = TAG_plot_colNames,
                              selected_clinical = clinical_vars,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(240, 100),
                              save_name = "Acylglycerols, AC")

# # Info about each plot class
# AC_plot_lipids <- c("AC")
 # AC_plot_colNames <- c("AC")
# 
# correlation_plots_publication(plot_lipids = AC_plot_lipids,
#                               col_titles = AC_plot_colNames,
#                               selected_clinical = clinical_vars,
#                               y_lims = clinical_limits,
#                               lipidomicsDF = lipidomicsDF,
#                               save_size = c(240, 45),
#                               save_name = "Acylcarnitine")



# Define plot_lipids and col_titles for Sphingolipids (first and second rows combined)
Sphingolipids_plot_lipids <- c("Cer", "Cer ratio", "dhCer", "GluCer", "LacCer", "SPH", "SPM")
Sphingolipids_plot_colNames <- c("Cer", "Cer 16:0/24:0", "dhCer", "GluCer", "LacCer", "SPH", "SPM")

correlation_plots_publication(plot_lipids = Sphingolipids_plot_lipids,
                              col_titles = Sphingolipids_plot_colNames,
                              selected_clinical = clinical_vars,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(240, 165),
                              save_name = "Ceramides")

# Define plot_lipids and col_titles for Phospholipids (first and second rows combined)
Phospholipids_plot_lipids <- c("PC", "PE", "PC.PE", "PA", "PG", "PS", "PI")
Phospholipids_plot_colNames <- c("PC", "PE", "PC/PE", "PA", "PG", "PS", "PI")

correlation_plots_publication(plot_lipids = Phospholipids_plot_lipids,
                              col_titles = Phospholipids_plot_colNames,
                              selected_clinical = clinical_vars,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(240, 165),
                              save_name = "Phopholipids")

# Define plot_lipids and col_titles for Lysophospholipids (first and second rows combined)
Lysophospholipids_plot_lipids <- c("LPC", "LPE", "LPG", "LPI", "LPS")
Lysophospholipids_plot_colNames <- c("LPC", "LPE", "LPG", "LPI", "LPS")

correlation_plots_publication(plot_lipids = Lysophospholipids_plot_lipids,
                              col_titles = Lysophospholipids_plot_colNames,
                              selected_clinical = clinical_vars,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(240, 165),
                              save_name = "Lysophopholipids")

```


## Analysis with adjustments - under dev
My take on 8/6-2024
A standard linear model on changes. Can be used to correct for factors that may change correlations, like age and MVPA.
A mixed model may be used to look at the effects of characteristics across the whole dataset, e.g. if there is a correlation between certain lipids and an endpoint.
```{r}
lipid_class <- "1,2-DG"


df <- as.data.frame(correlation_df[!is.na(correlation_df$pmol_mg_ch_id), ])

model <- lm(pmol_mg_ch_id ~ rd_ss2kg_ffm_insulin_ch + age_pre + mvpa_mins_day_post, data = df)

sum <- summary(model)

print(sum)


merged_data <- left_join(lipidomicsDF, mirage_data_long_ch, by = c("id", "time"))

merged_data_filtered <- filter(merged_data, lipidClass == lipid_class)

merged_data_filtered$time <- factor(merged_data_filtered$time)

# Relevel 'time' so 'Pre' is the reference level
merged_data_filtered$time <- relevel(merged_data_filtered$time, ref = "Pre")
# Relevel 'group' so 'HED' is the reference level 
merged_data_filtered$group <- relevel(merged_data_filtered$group, ref = "HED")

model_mixed_simple <- lmer(pmol_mg ~ time + rd_ss2kg_ffm_insulin +
                             (1 | id) +
                             (1 + time | lipidComposition),
                           data = merged_data_filtered)

print("Simple model")
summary(model_mixed_simple)


model_mixed <- lmer(pmol_mg ~ time + rd_ss2kg_ffm_insulin + age + mvpa_mins_day +
                      (1 | id) +
                      (1 + time | lipidComposition),
                    data = merged_data_filtered)

print("Corrected model")
summary(model_mixed)




# Define the clinical variables once
clinical_vars <- c("bmi_pre", "hgb_a1c_pre", "vo2kg_ffm_pre", "max_oxphos_pre", "mvpa_mins_day_pre", "age_pre", "fat_mass_dxa_pre", "le_pre", "ldl_pre", "cholesterol_pre")


```


## Heatmap & volcano plot

### Common data preparation

```{r}
#Gather the Spearman p-value columns
# For composition data
long_format_p_adj_comp <- correlation_values_ch_composition %>%
  select(lipid, test_against, spearman_p_all, spearman_p_HED, spearman_p_DIWL, spearman_p_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")

# For class data
long_format_p_adj_class <- correlation_values_ch_class %>% 
  select(lipid, test_against, spearman_p_all, spearman_p_HED, spearman_p_DIWL, spearman_p_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")

# Combine both into one data frame
long_format_p_adj.non <- rbind(long_format_p_adj_comp, long_format_p_adj_class)

#Gather the Spearman rho columns
# For composition
long_format_cor_comp <- correlation_values_ch_composition %>%
  select(lipid, test_against, spearman_rho_all, spearman_rho_HED, spearman_rho_DIWL, spearman_rho_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")

# For class
long_format_cor_class <- correlation_values_ch_class %>%
  select(lipid, test_against, spearman_rho_all, spearman_rho_HED, spearman_rho_DIWL, spearman_rho_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")

# Combine composition and class into one df
long_format_cor <- rbind(long_format_cor_comp, long_format_cor_class)

# Capitalize all to ALL
long_format_p_adj.non$spearman_type <- gsub("all", "ALL", long_format_p_adj.non$spearman_type)
long_format_cor$spearman_type <- gsub("all", "ALL", long_format_cor$spearman_type)

# Remove Na rows based on NA in correlation
long_format_cor <- long_format_cor %>%
  filter(!is.na(rho_value))

# Use the 'lipid' values to filter long_format_p_adj.non
long_format_p_adj.non <- long_format_p_adj.non %>%
  filter(lipid  %in% long_format_cor$lipid)

# Adjust p-values by group
long_format_p_adj.gr <- long_format_p_adj.non %>%
  group_by(test_against, spearman_type) %>%
  mutate(p_value = p.adjust(p_value, method = "BH"))%>%
  ungroup()

# adjust p-values by group and lipidClass
# First reintroduce lipidclass
long_format_p_adj.gr.class <- long_format_p_adj.non %>%
  mutate(lipidClass = sub("^(\\S+)\\s.*$", "\\1", lipid)) %>%
  group_by(test_against, spearman_type, lipidClass) %>%
  mutate(p_value = p.adjust(p_value, method = "BH")) %>%
  ungroup()
```

### volcano plot

```{r}
volcano_changes <- function(input_vars, save_sub_path, spearman_types_select, sub_folder){
  ### Join p-values adjusted for all lipid species and join with the rho values
  
  # Filter rows where 'test_against' column values are in 'input_vars'
  vulc.pvals <- long_format_p_adj.gr[long_format_p_adj.gr$test_against %in% input_vars, ]
  
  # Filter out only the spearman groups specified
  vulc.pvals <- vulc.pvals[sub("spearman_p_", "", vulc.pvals$spearman_type) %in% spearman_types_select, ]
  
  vulc.pvals$spearman_type <- gsub("spearman_p_", "", vulc.pvals$spearman_type)
  
  # Correlation df
  vulc.cor <- long_format_cor[long_format_cor$test_against %in% input_vars, ]
  # Filter out only the spearman groups specified
  vulc.cor <- vulc.cor[sub("spearman_rho_", "", vulc.cor$spearman_type) %in% spearman_types_select, ]
  
  vulc.cor$spearman_type <- gsub("spearman_rho_", "", vulc.cor$spearman_type)
  
  # make into single dataframe
  vulc_data <- vulc.cor %>%
    left_join(vulc.pvals, by = c("lipid", "test_against", "spearman_type"))
  
  # Make a identifier column that combines lipid, test-against and Spearman_type
  vulc_data$identifier <- paste0(vulc_data$lipid, " ~ ", vulc_data$test_against, " | ", vulc_data$spearman_type)
  
  ### Plot settings
  # Set threshold for when to plot label
  threshold_rho <- 0.2
  
  # Assuming unique_tests has been defined as before
  unique_tests <- sort(unique(vulc_data$test_against))
  
  
  # Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
  base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                                c = 100, 
                                l = 65)[1:length(unique_tests)]
  
  # Assign each test to a color
  colors_for_tests <- setNames(base_colors, unique_tests)
  
  
  ### Create plot
  vulc_plot <- ggplot(vulc_data, aes(x = rho_value, y = -log10(p_value))) +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", linewidth = 0.2) +
    geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
    scale_color_manual(values = colors_for_tests) +
    scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) +
    theme_minimal() +
    labs(title = paste0("Correlation: ", save_sub_path, " within ", sub_folder),
         x = "Spearman rho", y = "-log10 P-value") +
    theme(plot.title = element_text(hjust = 0.5))+
    geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(rho_value) > threshold_rho, identifier, "")),
                    box.padding = 0.45, point.padding = 0.5, max.overlaps = 100,
                    size = 2, segment.color = 'grey50') +
    
    guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) 
  
  # Save the plot
  save_path <- paste0(getwd(), "/outputs/correlations in changes/volcano/",sub_folder, "/", save_sub_path, ".jpg")
  
  ggsave(save_path, plot = vulc_plot, width = 14, height = 10, dpi = 400)
}

# Define variables to go into functions
spearman_types_select.all <- c("ALL") # use ALL, HED, DIWL and WLEX
spearman_types_select.groups <- c("ALL", "HED", "DIWL", "WLEX") # use ALL, HED, DIWL, WLEX

# Loop through each main category in mirage_ch_vars
for (i in seq_along(mirage_ch_vars)) {
  # Print the name of the current list being processed
  list_name <- names(mirage_ch_vars)[i]
  print(paste("Processing list:", list_name))
  
  # Use lapply to iterate over each sublist in the current category
  names_to_use <- unlist(lapply(mirage_ch_vars[[i]], function(sublist) {
    # Check if the sublist is long enough to have at least the first element
    if(length(sublist) >= 1) {
      # Replace '_pre' with '_ch' in the first element
      return(gsub("_pre", "_ch", sublist[1]))
    } else {
      return(NA)  # Return NA if the sublist does not have at least one element
    }
    
  }))
  volcano_changes(input_vars = names_to_use, sub_folder = "all" , save_sub_path = list_name, spearman_types_select = spearman_types_select.all)
  volcano_changes(input_vars = names_to_use, sub_folder = "groups", save_sub_path = list_name, spearman_types_select = spearman_types_select.groups)
}
```

### Heatmap

```{r}

heatmap_changes <- function(test_against_input, save_name)
{
  
  # Group lipidclasses to make multiple, clean heatmaps
  lipids_groups <- list(
    gr_tag = c("TAG"),  # Triacylglycerols
    gr_dg_ac = c("1,2-DG", "1,3-DG", "AC"),  # Diglycerides and Acyl carnitines
    gr_pc = c("PC", "PC.PE"),  # Phosphatidylcholines and ratio
    gr_pe = c("PE"),  # Phosphatidylethanolamines
    gr_sphingolipids = c("SPM", "SPH", "Cer", "Cer ratio", "dhCer", "GluCer", "LacCer", "GalCer"),  # Sphingolipids: Sphingomyelins, Sphingosines, Ceramides and derivatives
    gr_lyso = c("LPC", "LPE", "LPG", "LPI", "LPS"),  # Lysophospholipids
    gr_pa_ps = c("PA", "PS"),  # Group combining Phosphatidic acids and Phosphatidylserines
    gr_pg_pi = c("PG", "PI")  # Group combining Phosphatidylglycerols and Phosphatidylinositols
  )
  
  # Define function to filter and sort lipids based on group names
  filter_lipid_group_base <- function(data_frame, lipid_group) {
    # Create the pattern for matching lipid groups
    pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
    # Sort the data_frame by lipid column
    sorted_data_frame <- data_frame[order(data_frame$lipid), ]
    # Filter based on the pattern and return the sorted & filtered data frame
    sorted_filtered_data_frame <- sorted_data_frame[grepl(pattern, sorted_data_frame$lipid), ]
    return(sorted_filtered_data_frame)
  }
  
  # Select specific test against
  long_format_p_adj_selected.non <- long_format_p_adj.non[long_format_p_adj.non$test_against %in% test_against_input,]
  long_format_p_adj_selected.gr <- long_format_p_adj.gr[long_format_p_adj.gr$test_against %in% test_against_input,]
  long_format_p_adj_selected.gr.class <- long_format_p_adj.gr.class[long_format_p_adj.gr.class$test_against %in% test_against_input,]
  long_format_corr_selected <- long_format_cor[long_format_cor$test_against %in% test_against_input,]
  
  # Only select ALL and not subgroups
  long_format_p_adj_selected.non <- long_format_p_adj_selected.non[long_format_p_adj_selected.non$spearman_type == "spearman_p_ALL", ]
  long_format_p_adj_selected.gr <- long_format_p_adj_selected.gr[long_format_p_adj_selected.gr$spearman_type == "spearman_p_ALL", ]
  long_format_p_adj_selected.gr.class <- long_format_p_adj_selected.gr.class[long_format_p_adj_selected.gr.class$spearman_type == "spearman_p_ALL", ]
  long_format_corr_selected <- long_format_corr_selected[long_format_corr_selected$spearman_type == "spearman_rho_ALL", ]
  
  
  # Apply the filter function to each group and store the results in a lists
  # p-values
  long_format_p_adj_groups.non <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.non)
  long_format_p_adj_groups.gr <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr.class)
  long_format_p_adj_groups.all <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr)
  # correlations
  long_format_corr_groups <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_corr_selected)
  
  
  # Function to create 'unique_test_against' column for p-value df
  mutate_unique_column_p <- function(data_frame) {
    data_frame %>%
      mutate(unique_test_against = paste0(sub("spearman_p_", "", spearman_type), "_", test_against))
  }
  
  # Adjust the function for correlation df
  mutate_unique_column_corr <- function(data_frame) {
    data_frame %>%
      mutate(unique_test_against = paste0(sub("spearman_rho_", "", spearman_type), "_", test_against))
  }
  
  # Apply the mutation function to each group's data frames for p-values
  long_format_p_adj_groups.non <- lapply(long_format_p_adj_groups.non, mutate_unique_column_p)
  long_format_p_adj_groups.gr <- lapply(long_format_p_adj_groups.gr, mutate_unique_column_p)
  long_format_p_adj_groups.all <- lapply(long_format_p_adj_groups.all, mutate_unique_column_p)
  
  # Apply the mutation function to each group's data frames for correlations
  long_format_corr_groups <- lapply(long_format_corr_groups, mutate_unique_column_corr)
  
  
  # Function to perform negative log10 transformation and remove p_value column
  transform_p_values <- function(df) {
    df %>%
      mutate(p_log10 = -log10(p_value)) %>%
      select(-p_value)
  }
  
  # Apply the transformation to each list
  long_format_p_adj_log10.non <- lapply(long_format_p_adj_groups.non, transform_p_values)
  long_format_p_adj_log10.gr <- lapply(long_format_p_adj_groups.gr, transform_p_values)
  long_format_p_adj_log10.all <- lapply(long_format_p_adj_groups.all, transform_p_values)
  
  # Define a function to spread the data and convert it to a matrix
  spread_and_convert_matrix <- function(df, unitName) {
    result_matrix <- df %>%
      select(lipid, unique_test_against, all_of(unitName)) %>%
      pivot_wider(names_from = unique_test_against, 
                  values_from = unitName, 
                  values_fill = setNames(list(NA), unitName)) %>%
      column_to_rownames(var = "lipid") %>%
      as.matrix()
    return(result_matrix)
  }
  
  # Apply the function to each list
  matrices_p_adj_non <- lapply(long_format_p_adj_groups.non, function(x) spread_and_convert_matrix(x, "p_value"))
  matrices_p_adj_gr <- lapply(long_format_p_adj_groups.gr, function(x) spread_and_convert_matrix(x, "p_value"))
  matrices_p_adj_all <- lapply(long_format_p_adj_groups.all, function(x) spread_and_convert_matrix(x, "p_value"))
  # To correlation values
  matrices_rho <- lapply(long_format_corr_groups, function(x) spread_and_convert_matrix(x, "rho_value"))
  
  
  generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims) {
    # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
    
    # Extract test_against by removing the first part (treatment group) and the first underscore
    # This joins back the remaining parts to form the full 'test_against' label
    colTitles <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) paste(x[-1], collapse = "_"))
    colTitles <- unique(colTitles)
    
    
    # Modify the column names to only show the group
    colnames(hm_matrix) <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) {
      # Concatenate the first part with the first four letters of the second part and "..."
      paste0(x[1], "", substr(x[2], 1, 0), "")
    })
    
    
    Heatmap(hm_matrix,
            name = "rho", # Sets the name of the color scale
            
            col = colorMap, # Use provided color map
            rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
            row_names_side = "left", # Position of row labels
            row_names_gp = gpar(fontsize = 9), # Change font size of row labels
            
            column_split = rep(1:(ncol(hm_matrix) / 1), each = 1), # Splits the columns and names them
            column_title = colTitles, # Custom titles for each split
            column_names_rot = 45, # Rotate column names for better readability
            column_names_gp = gpar(fontsize = 8, fontface = "bold"),
            column_title_side = "top", # Placement of the column titles
            column_title_gp = gpar(fontsize = 7, fontface = "bold"),
            #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
            
            border = TRUE, # Set border around the splits
            cluster_rows = FALSE, # Don't make clusters
            cluster_columns = FALSE, # Don't make clusters
            
            cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                if (p_val_matrix[i, j] < pLims$p1) {
                  grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                } else if (p_val_matrix[i, j] < pLims$p2) {
                  grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                } else if (p_val_matrix[i, j] < pLims$p3) {
                  grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                }
              }
            })
  }
  
  # Define color map for heatmap
  color_mapping <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))
  
  # Set p-value limits
  p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
  # Create a list for the heatmaps
  hm <- list()
  
  # Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
  for (i in 1:length(lipids_groups)) {
    # Generate heatmap and store it in the list
    hm[[i]] <- generate_heatmap(matrices_rho[[i]], matrices_p_adj_non[[i]], color_mapping, p_value_limits)
  }
  
  # Define the path and name of your PDF file
  pdf_path <- paste0(getwd(), "/outputs/correlations in changes/heatmap/", save_name, ".pdf")
  
  # Open a PDF device
  pdf(pdf_path, width = 12, height = 14)
  
  # Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
  for (i in 1:length (hm)){
    draw(hm[[i]])
  }
  dev.off()
  
}

# Loop over every group within the compositions
for (i in seq_along(mirage_ch_vars)) {
  # Print the name of the current list being processed
  list_name <- names(mirage_ch_vars)[i]
  print(paste("Processing list:", list_name))
  
  test_against_input <- unlist(lapply(mirage_ch_vars[[i]], function(sublist) {
    # Check if the sublist is long enough to have at least the first element
    if(length(sublist) >= 1) {
      # Replace '_pre' with '_ch' in the first element
      return(gsub("_pre", "_ch", sublist[1]))
    }}))
  heatmap_changes(test_against_input = test_against_input, save_name = list_name)
}

```

```{r}

```

## Plot p-values sorted

```{r}

# BH correct p-values
# Name the columns that should be adjusted
cols_to_adjust <- c(
  "pearson_p_all", "spearman_p_all", "mixed_p_all",
  "pearson_p_HED", "spearman_p_HED",
  "pearson_p_DIWL", "spearman_p_DIWL",
  "pearson_p_WLEX", "spearman_p_WLEX"
)

# Function to apply BH correction within each "test_against" group
adjust_p_values_within_group <- function(data, cols_to_adjust) {
  data %>%
    group_by(test_against) %>%
    mutate(across(all_of(cols_to_adjust), ~ p.adjust(.x, method = "BH"), .names = "{.col} (corrected)")) %>%
    ungroup()
}

# Apply correct function
# composition
correlation_values_ch_composition <- adjust_p_values_within_group(correlation_values_ch_composition, cols_to_adjust)
# class
correlation_values_ch_class <- adjust_p_values_within_group(correlation_values_ch_class, cols_to_adjust)
# class and composition
# combine data
correlation_values_ch_comp_and_class <- rbind(correlation_values_ch_composition, correlation_values_ch_class)
# Adjust
correlation_values_ch_comp_and_class <- adjust_p_values_within_group(correlation_values_ch_comp_and_class, cols_to_adjust)

### Plot p-values sorted
generate_barplot_ch <- function(data, col_non_corrected, col_corrected, output_base_path, data_name) {
  # Define common sizes for axis titles and plot title
  axis_title_size <- 12
  plot_title_size <- 13
  
  # Loop over every unique test
  for (test_var in unique(data$test_against)) {
    # Filter based on test variable
    data_test_filtered <- filter(data, test_against == test_var)
    
    # Remove row if non corrected column is Na
    data_test_filtered <- data_test_filtered[!is.na(data_test_filtered[[col_non_corrected]]), ]
    
    # Dynamic adjustment of the label size based on the number of bars (lipids)
    num_bars <- length(unique(data_test_filtered$lipid))
    label_size <- max(2, min(10, 50 / sqrt(num_bars))) # Adjusted dynamically
    
    
    # Generate plot for non-corrected p-values
    p1 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_non_corrected]]), y = data_test_filtered[[col_non_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_non_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )
    
    # Generate plot for corrected p-values
    p2 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_corrected]]), y = data_test_filtered[[col_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )
    
    # Combine the two plots
    subplot <- p1 + p2
    
    # Construct the subfolder path based on 'test_var'
    subfolder_path <- file.path(output_base_path, gsub("[ :()]", "_", test_var)) # Replace problematic characters
    
    # Ensure the subfolder exists
    dir.create(subfolder_path, recursive = TRUE, showWarnings = FALSE)
    
    # Construct the plot filename, ensuring no problematic characters for file names
    plot_filename <- paste0(gsub("[ :()]", "_", col_non_corrected), ", ", data_name, test_var, ".jpeg") # Replace spaces and special characters with underscores
    
    # Save the plot
    ggsave(file.path(subfolder_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
  }
}

# RUN FUNCTIONS
# Add a second row to cols_to_adjust with corrected column names
plot_nonadj_vs_adj <- data.frame(original = cols_to_adjust, corrected = paste0(cols_to_adjust, " (corrected)"))

# Just leave empty, as ch already indicates change in file name
dataframe_name_comp <- ""


####### MAKE FOR LIPID COMP AND CLASS!!!

# For lipid class
# Define output path
output_base_path <- paste0( getwd(), "/outputs/correlations in changes/plot, p-value sorted changes/lipid class")

for (i in 1:nrow( plot_nonadj_vs_adj)) {
  generate_barplot_ch(correlation_values_ch_class, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}

# For lipid class
# Define output path
output_base_path <- paste0(getwd(), "/outputs/correlations in changes/plot, p-value sorted changes/lipid class and composition")

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_ch(correlation_values_ch_composition, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}
```

# Cross sectional analysis

Analyse correlation between variables from the mirage dataset and the lipidomics data for all subjects at the time point pre.

## Prepare data (function)

Ouliers handled by using pmol_imputed. For lipid composition, outliers are removed before in the data fed to the dataset

```{r}
# run function test
# Function to prepare data
prepare_and_combine_crossSection <- function(lipidomicsData, mirageData, lipidclass, lipidcomposition) {
  
  # Filter and prepare lipidomics data.
  if (!is.null(lipidcomposition) && lipidcomposition != "ratio"){
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass, lipidComposition == lipidcomposition)
  } else {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
  }
  
  
  # Remove lipid composition within lipid class if fewer non-zero values than the analysis_cutoff. Only for lipidComposition
  non_zero_rows <- lipidomics_selected %>%
    filter(pmol_mg > 0)
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, lipidComposition, pmol_mg_imp)
  
  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = pmol_mg_imp, names_prefix = "pmol_mg_") %>%
    relocate(id, .before = everything()) # Moves id to front
  
  
  ## Calculate sum within each individual to use for lipid class.
  lipidomics_wide <- lipidomics_wide %>%
    group_by(id) %>%
    mutate(pmol_mg_id = if_else(row_number() == 1, sum(pmol_mg_Pre), NA_real_)) %>%
    ungroup()
  
  ### Normalize data
  # Normalization has to be within each lipidclass and composition.
  # Calculate z normalization within each lipid composition
  lipidomics_wide <- lipidomics_wide %>%
    group_by(lipidClass, lipidComposition) %>%
    mutate(lipid_normalized_z = scale(pmol_mg_Pre)[, 1]) %>%
    ungroup()
  
  #  # Calculate the mean z-score for each ID
  #  mean_z_score_per_id <- lipidomics_wide %>%
  #    group_by(id) %>%
  #    summarise(lipid_normalized_z_avg = mean(lipid_normalized_z, na.rm = TRUE)) %>%
  #    ungroup()
  #
  #  # Add the normalized data back to original dataframe for only for the first occurrence of each ID
  #  lipidomics_wide <- lipidomics_wide %>%
  #    left_join(mean_z_score_per_id, by = "id") %>%
  #    group_by(id) %>%
  #    mutate(
  #      row_num = row_number(),
  #      lipid_normalized_z_avg = if_else(row_num == 1, lipid_normalized_z_avg, NA_real_)
  #    ) %>%
  #    select(-row_num) %>%
  #    ungroup()
  
  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")
  
  # Convert certain columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))
  
  
  # output Na
  if (!is.null(lipidcomposition) & nrow(non_zero_rows) < analysis_cutoff){
    combined_df$skipAnalysis <- TRUE
  }else{
    combined_df$skipAnalysis <- FALSE
  }
  
  return(combined_df)
}

```

## Statistics (function)

```{r}
# Define a function to compute correlations of change
correlation_cross_sectional <- function(corr_df, lipidomicsDF, mirage_variables_of_interest, lipidclass, lipidcomposition) {
  
  # Determine the lipid name based on the presence of lipid composition   
  if (!is.null(lipidcomposition) && lipidcomposition != "ratio") {
    lipidName <- paste0(lipidclass, " ", lipidcomposition)
  } else {
    lipidName <- lipidclass
  }
  
  # Make Na if too few values determined from prepare data function
    # Initialize an empty data frame to store correlation results
    correlation_results <- data.frame(
      lipid = character(),
      test_against = character(),
      pearson_r_all = numeric(),
      pearson_p_all = numeric(),
      spearman_rho_all = numeric(),
      spearman_p_all = numeric(),
      pearson_r_HED = numeric(),
      pearson_p_HED = numeric(),
      spearman_rho_HED = numeric(),
      spearman_p_HED = numeric(),
      pearson_r_DIWL = numeric(),
      pearson_p_DIWL = numeric(),
      spearman_rho_DIWL = numeric(),
      spearman_p_DIWL = numeric(),
      pearson_r_WLEX = numeric(),
      pearson_p_WLEX = numeric(),
      spearman_rho_WLEX = numeric(),
      spearman_p_WLEX = numeric()
    )
    
    
    # Loop over every mirage variables of interest
    for (i in seq_along(mirage_variables_of_interest)) {
      for (j in seq_along(mirage_variables_of_interest[[i]])){
        
        
        # Manipulate current variable name
        test_against_name <- mirage_variables_of_interest[[i]][[j]][1]
        test_against_name_clean <- sub("_pre$", "", test_against_name)
        
        # Add new row to output df
        correlation_results <- add_row(correlation_results)
        
        # Identify the index of current row to be able to append data to it
        current_row_index <- nrow(correlation_results)
        
        # Assign lipid name and test against to last row
        correlation_results$lipid[current_row_index] <- lipidName
        correlation_results$test_against[current_row_index] <- test_against_name
        
         if (corr_df$skipAnalysis[[1]] == TRUE){
          # Assign NA to all results
          correlation_results$pearson_r_all[current_row_index] <- NA
          correlation_results$pearson_p_all[current_row_index] <- NA
          correlation_results$spearman_rho_all[current_row_index] <- NA
          correlation_results$spearman_p_all[current_row_index] <- NA
          correlation_results$pearson_r_HED[current_row_index] <- NA
          correlation_results$pearson_p_HED[current_row_index] <- NA
          correlation_results$spearman_rho_HED[current_row_index] <- NA
          correlation_results$spearman_p_HED[current_row_index] <- NA
          correlation_results$pearson_r_DIWL[current_row_index] <- NA
          correlation_results$pearson_p_DIWL[current_row_index] <- NA
          correlation_results$spearman_rho_DIWL[current_row_index] <- NA
          correlation_results$spearman_p_DIWL[current_row_index] <- NA
          correlation_results$pearson_r_WLEX[current_row_index] <- NA
          correlation_results$pearson_p_WLEX[current_row_index] <- NA
          correlation_results$spearman_rho_WLEX[current_row_index] <- NA
          correlation_results$spearman_p_WLEX[current_row_index] <- NA
          
          }else{
        
        
        
        # Choose the correct unit for lipid class and lipid comp
        if (!is.null(lipidcomposition) && lipidcomposition != "ratio") {
          lipid_unit <- "pmol_mg_Pre"
        } else {
          lipid_unit <- "pmol_mg_id"
        }
        
        # Perform Pearson and Spearman correlations for all data
        result_pearson_all <- correlation(corr_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
        result_spearman_all <- correlation(corr_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
        
        
        # Assign results the the results df
        correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
        correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
        correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
        correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p
        
        # Calculate correlations for each group
        for (current_group in unique(corr_df$group)) {
          # Filter the dataframe for the current group
          correlation_df_group <- filter(corr_df, group == current_group)
          
          
          # Perform Pearson and Spearman correlations for the current group
          result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
          result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
          
          # Dynamic assignment of results based on the current group
          pearson_r_col <- paste0("pearson_r_", current_group)
          pearson_p_col <- paste0("pearson_p_", current_group)
          spearman_rho_col <- paste0("spearman_rho_", current_group)
          spearman_p_col <- paste0("spearman_p_", current_group)
          
          correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
          correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
          correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
          correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
        }
          }

    }
  }
  return(correlation_results)
}

```

## Plot scatter (function)

```{r}
correlation_crossSectional_plot <- function(correlation_df, mirage_crossSectional_vars, correlation_results, savePath, lipidclass, lipidcomposition) {
  # Make lipid name
  if (!is.null(lipidcomposition) && lipidcomposition != "ratio"){
    lipidName <- paste0(lipidclass, " ", lipidcomposition)
  } else {
    lipidName <- lipidclass
  }
  
  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pmol_mg_Pre))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_crossSectional_vars, function(category) {
      lapply(category, function(item) item[1])
    }), recursive = FALSE), use.names = FALSE)
    
    
    # If lipidcomposition is null, then only plot class
    
    # Filter and prepare lipidomics data
    if (!is.null(lipidcomposition) && lipidcomposition != "ratio"){
      # Add lipid variable to plotVars
      plotVars <- c("pmol_mg_Pre", plotVars)
      
      # Now use ggpairs on the renamed dataframe
      pm <- ggpairs(correlation_df,
                    mapping = aes(color = group),
                    columns = plotVars,
                    lower = list(continuous = wrap("smooth", method = "none", se = FALSE))
      )
    } else {
      # Add lipid variable to plotVars
      # Make plot with log2 fold change if only class is available
      plotVars <- c("pmol_mg_id", plotVars)
      
      pm <- ggpairs(correlation_df,
                    mapping = aes(color = group),
                    columns = plotVars
      )
    }
    
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }
    
    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)
      
      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
                                        x = Inf, y = Inf,
                                        label = paste0(
                                          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
                                          # ", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
                                          "\nSpearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
                                          ", rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
                                          "\n***** Non-adjusted *****"
                                        ),
                                        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }
    
    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }
    
    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }
    
    
    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }
  
  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )
  
  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
}
```

## Run functions

```{r}
# Save folder for .jpg output files
savePathClassComp <- paste0(getwd(), "/outputs/cross section/scatter composition/")
savePathClass <- paste0(getwd(), "/outputs/cross section/scatter class/")

# Initialize an empty data frame to hold all correlation values
correlation_results_crossSection_composition <- data.frame()
correlation_results_crossSection_class <- data.frame()


# Loop over each lipid composition within each lipidclass
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)

for (lipid_class in unique_lipid_classes[!unique_lipid_classes == "PC.PE"]) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  
  for (lipid_composition in lipid_compositions_in_class) {
    print( paste0("Cross sectional analysis; processing ", lipid_class, " ", lipid_composition , "..."))
    # Select and prepare data for analysis
    correlation_crossSection_df <- prepare_and_combine_crossSection(
      lipidomicsData = lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),],
      mirageData = mirage_data,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition
    )
    
    # Calculate correlation coefficients
    correlation_results_crossSection_composition <- rbind(correlation_results_crossSection_composition, correlation_cross_sectional(
      corr_df = correlation_crossSection_df, 
      lipidomicsDF = lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),], 
      mirage_variables_of_interest = mirage_crossSectional_vars,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition))
  
# # Plot data - Comment out if to be used
# correlation_crossSectional_plot(
#   correlation_crossSection_df,
#   mirage_crossSectional_vars,
#   correlation_results_crossSection_composition,
#   savePathClassComp,
#   lipid_class,
#   lipid_composition
# )
}
  }


# Loop over each lipid class and make plots
for (lipid_class in unique_lipid_classes) { # [!unique_lipid_classes == "Cer ratio"]
  print( paste0 ("Analysing lipid class: ", lipid_class, "..."))
  # Organize data
  correlation_crossSection_df <- prepare_and_combine_crossSection(
    lipidomicsData = lipidomicsDF,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    lipidcomposition = NULL
  )
  
  # Calculate correlations for changes
  correlation_results_crossSection_class <- rbind(correlation_results_crossSection_class, correlation_cross_sectional(
    corr_df = correlation_crossSection_df,
    lipidomicsDF = lipidomicsDF,
    mirage_variables_of_interest = mirage_crossSectional_vars,
    lipidclass = lipid_class,
    lipidcomposition = NULL))
  
  # # Plot data - un-comment if to be used again
  # correlation_crossSectional_plot(
  #   correlation_crossSection_df,
  #   mirage_crossSectional_vars,
  #   correlation_results_crossSection_class,
  #   savePathClass,
  #   lipid_class,
  #   lipidcomposition = NULL
  # )
}


###### SAVE AND LOAD VARIABLES TO NOT HAVE TO RERUN ALL THE ANALYSIS #######
# Define the path to save/load folder
# save_variable_path <- paste0(getwd(), "/outputs/saved variables/")
# 
# # Specify filenames for each variable
# file_correlation_values_crossSection_composition <- paste0(save_variable_path, "correlation_values_crossSection_composition.rds")
# file_correlation_values_crossSection_class <- paste0(save_variable_path, "correlation_values_crossSection_class.rds")
# 
# Save the variables
# saveRDS(correlation_results_crossSection_composition, file = file_correlation_values_crossSection_composition)
# saveRDS(correlation_results_crossSection_class, file = file_correlation_values_crossSection_class)

# OR LOAD VARIABLES
# correlation_results_crossSection_composition <- readRDS(file = file_correlation_values_crossSection_composition)
# correlation_results_crossSection_class <- readRDS(file = file_correlation_values_crossSection_class)

```
# ! Waterfall

```{r}
correlation_waterfall <- function(clinical_var, save_sub_folder){

# Filter, rename, and sort the dataframe
corr_ordered <- correlation_results_crossSection_class %>%
  filter(test_against %in% clinical_var[[1]]) %>% 
  mutate(lipid = ifelse(lipid == "PC.PE", "PC/PE", lipid)) %>% 
  filter(lipid != "Cer ratio") %>% 
  arrange(spearman_rho_all)

# Ensure 'lipid' is a factor and set its levels based on the sorted order
corr_ordered$lipid <- factor(corr_ordered$lipid, levels = corr_ordered$lipid)

# Get significance helper function
get_significance <- function(p_value) {
  if (p_value < 0.001) {
    return("***")
  }else if (p_value < 0.01){
    return("**")
    } else if (p_value < 0.05) {
    return("*")
  } else {
    return("")
  }
}
corr_ordered$significance <- sapply(corr_ordered$spearman_p_all, get_significance)

# Define your color mapping function
color_mapping_common <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

# Make non significant grey
# corr_ordered$color <- ifelse(corr_ordered$significance == "",
#                              "grey",
#                              color_mapping_common(corr_ordered$spearman_rho_all))

# All bars colored
corr_ordered$color <- color_mapping_common(corr_ordered$spearman_rho_all)


plot <- ggplot(corr_ordered, aes(lipid, spearman_rho_all)) +
   geom_col(aes(fill = color), 
            color = "black", linewidth = 1) +
  #geom_col(aes(fill = ifelse(significance == "", "grey", ifelse(spearman_rho_all > 0, "positive", "negative"))),
   #        color = "black", size = 1) +
  geom_text(aes(label = significance,
                y = ifelse(spearman_rho_all > 0, -0.05, 0.05),
                hjust = ifelse (spearman_rho_all > 0, 1, 0) ), # Adjust vertical position
            vjust = 0.8,      # Center the text horizontally
            size = 4) +      # Enlarge the size of asterisks
  coord_flip() +
  labs(x = "Predictor Variable", y = expression("Spearman's " * rho), title = clinical_var[[2]]) +
   scale_fill_identity() + 
   #scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, limits = c(-1, 1), guide = "none") +
  geom_hline(yintercept = 0, color = "black", linewidth = 1) +
  #scale_fill_manual(values = c(positive = "#FFB3B3", negative = "#B3C7E6", grey = "grey"), guide = "none") +
  ylim(-as.numeric(clinical_var[3]), as.numeric(clinical_var[[3]])) +
  theme(panel.background = element_rect("transparent"),
        axis.text = element_text(color = "black", size = 9),
        plot.background = element_rect(fill='transparent', color=NA),
        axis.title.y = element_blank(),
        axis.text.y = element_text(size = 7),
        axis.title.x = element_text(size = 7, color = "black"),
        axis.text.x = element_text(size = 7),
        axis.line = element_line(linewidth = 1),
        plot.title = element_text(hjust = .5, face = "bold", size = 8))
    

ggsave(paste0(getwd(), "/outputs/figures/baseline correlations/waterfall/", save_sub_folder, clinical_var[[1]], ".svg"), plot, device = "pdf", height = 80, width = 55 , units = "mm", bg = "transparent")

print(plot)
}

# Define clinical var c(var_name, plot_title, x-lim)
clinical_var <- list(
  c("bmi_pre", bquote(bold("Body mass index")), .7),
  c("tdpa_pre", bquote(bold("Total daily physical activity")), .7),
  c("rd_ss2kg_ffm_insulin_pre", bquote(bold("Glucose R"[d])), .7),
  c("percent_fat_mass_pre", bquote(bold("Body fat")), .7),
  c("percent_imat_pre", bquote(bold("Thigh IMAT")), .7),
  c("vo2kg_ffm_pre", bquote(bold(VO[2] ~ "per kg FFM")), .7),
  c("hgb_a1c_pre", bquote(bold("Hemoglobin A1c")), .7),
  c("pcr_p_mrs_pre", bquote("PCr recovery"), .7),
  c("max_oxphos_pre", bquote("Max oxidative phosphorylation"), .7)
)

clinical_var_post <- list(
  c("bmi_post", bquote(bold("Body mass index (post)")), .7),
  c("tdpa_post", bquote(bold("Total daily physical activity (post)")), .7),
  c("rd_ss2kg_ffm_insulin_post", bquote(bold("Glucose R"[d]~"(post)")), .7),
  c("percent_fat_mass_post", bquote(bold("Body fat")), .7),
  c("percent_imat_post", bquote(bold("Thigh IMAT proportion (post)")), .7),
  c("vo2kg_ffm_post", bquote(bold(VO[2] ~ "per kg FFM (post)")), .7),
  c("hgb_a1c_post", bquote(bold("Hemoglobin A1c (post)")), .7),
  c("pcr_p_mrs_post", bquote("PCr recovery (post)"), .7),
  c("max_oxphos_post", bquote("Max oxidative phosphorylation (post)"), .7)
)

for (var in clinical_var){
  correlation_waterfall(var, 
                        save_sub_folder = "")
}


for (var in clinical_var_post){
  correlation_waterfall(var, 
                        save_sub_folder = "post/")
}
```

# ! Heatmap of compositions
```{r}
 generate_heatmap <- function(colorMap, pLims, hm_title, hm_unit, lipid_class, clin_var, save_sub_path){
  
   # Create new columns 'lipidClass' and 'lipidComposition' using base R
res_lipid_names <- correlation_results_crossSection_composition %>%
  filter(!is.na(spearman_rho_all)) %>%  # Remove rows where spearman_corr_all is NA
  mutate(
    lipidClass = sapply(strsplit(as.character(lipid), " "), `[`, 1),
    lipidComposition = sapply(strsplit(as.character(lipid), " "), `[`, 2)
  ) %>%
  filter(lipidComposition != "ratio")  # Removed cer ratio

# Filter data for lipidClass 
filtered_data <- res_lipid_names[res_lipid_names$lipidClass == lipid_class & res_lipid_names$test_against == clin_var[[1]], ]

# Create a matrix
heatmap_matrix.corr <- as.matrix(filtered_data[, "spearman_rho_all", drop = FALSE])
heatmap_matrix.p <- as.matrix(filtered_data[, "spearman_p_all", drop = FALSE])
rownames(heatmap_matrix.corr) <- filtered_data$lipidComposition
rownames(heatmap_matrix.p) <- filtered_data$lipidComposition


hm_matrix <- t(heatmap_matrix.corr)
p_val_matrix <- t(heatmap_matrix.p)


ht_opt$ROW_ANNO_PADDING <- unit(0, "mm")
   hm <- Heatmap(hm_matrix,
          name = hm_unit, # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          
          show_row_names = FALSE, # Remove row labels
          
          # row_title = lipids_groups[[i]][2],
          row_title_gp = gpar(fontsize = 6, fontface = "bold"),
          row_title_rot = 0,
          
          column_title = lipids_groups[[i]][2],
          column_names_rot = 90, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 5),
           column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 6, fontface = "bold", lineheight = 0.2),
          
          
          
          heatmap_legend_param = list(
            title = bquote(bold("Spearman's"~rho)),   # Legend title
            direction = "vertical",  # Set legend labels vertically
            title_gp = gpar(fontsize = 6, fontface = "bold"),   # Adjust title font size
            labels_gp = gpar(fontsize = 5),  # Adjust label font size
            color_key_height = unit(0.3, "cm"),  # Adjust the color key height
            color_key_width = unit(.8, "cm"),     # Adjust the color key width
            legend_width = unit(2, "cm"),        # Adjust the width of the legend box
            legend_height = unit(1.5, "cm"),      # Adjust the height of the legend box
            title_position = "topcenter"        # Move the title to the top center of the legend
          ),
          show_heatmap_legend = lipids_groups[[i]][5],
          
          
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
         cell_fun = function(j, i, x, y, width, height, fill) {
                
if (is.na(hm_matrix[i, j])) {
  grid.rect(unit(x, "npc"), unit(y, "npc"), width, height, gp = gpar(fill = "grey", col = NA))
} else if (!is.na(p_val_matrix[i, j])) {
  if (p_val_matrix[i, j] < pLims$p1) {
    grid.text("*\n*\n*", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 5, fontface = "bold", lineheight = 0.4), just = "center")
  } else if (p_val_matrix[i, j] < pLims$p2) {
    grid.text("*\n*", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 5, fontface = "bold", lineheight = 0.4), just = "center")
  } else if (p_val_matrix[i, j] < pLims$p3) {
    grid.text("*", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 5, fontface = "bold", lineheight = 0.4), just = "center")
                  }
            }
          })
   
   savelocation_svg <- paste0(getwd(), "/outputs/figures/baseline correlations/waterfall/heatmaps/", save_sub_path, clin_var[[1]], "/", lipids_groups[[i]][2], ".svg")
   dir.create(dirname(savelocation_svg), recursive = TRUE, showWarnings = FALSE)
   
   height <- as.double(lipids_groups[[i]][3])
   width <- as.double(lipids_groups[[i]][4])
   
   pdf(savelocation_svg, width = width, height = height) # dimensions in inches
   
   # Set the background to transparent
   
   draw(hm,
        heatmap_legend_side = "right", 
        annotation_legend_side = "right",
        background = "transparent"
   )
   
   # Close the device
   dev.off()
   
 }

# Define color map for heatmap
color_mapping_common <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)


lipids_groups <- list(
  gr_tag_ac = c("TAG", "Triacylglycerol", 0.65, 2.3, FALSE, "row_title"),
  gr_1_2_dg = c("1,2-DG", "1,2-diacylglycerol", 0.82, 2.4, FALSE, "row_title"),
  gr_1_3_dg = c("1,3-DG", "1,3-diacylglycerol", 0.82, 1.7, FALSE, "row_title"),
  gr_ac = c("AC", "Acylcarnitine", 0.67, 1.1, FALSE, "row_title"),
  gr_cer = c("Cer", "Ceramide", 0.65, .8, FALSE, "row_title"),
  gr_dhcer = c("dhCer", "Dihydroceramide", 0.65, .69, FALSE, "row_title"),
  gr_glucer = c("GluCer", "Glucosylceramide", 0.65, .73, FALSE, "row_title"),
  gr_laccer = c("LacCer", "Lactosylceramide", 0.65, .72, FALSE, "row_title"),
  gr_sph = c("SPH", "Sphingosine", 0.65, 1.5, FALSE, "row_title"),
  gr_spm = c("SPM", "Sphingomyelin", 0.65, .9, FALSE, "row_title"),
  gr_pc = c("PC", "Phosphatidylcholine", 0.85, 5.4, FALSE, "row_title"),
  gr_pe = c("PE", "Phosphatidylethanolamine", 0.85, 5.4, FALSE, "row_title"),
  gr_pc_pe = c("PC.PE", "Phosphatidylcholine.Phosphatidylethanolamine", 0.85, 5, FALSE, "row_title"),
  gr_pa = c("PA", "Phosphatidic acid", 0.82, 2.3, FALSE, "row_title"),
  gr_pg = c("PG", "Phosphatidylglycerol", 0.82, 1.5, FALSE, "row_title"),
  gr_ps = c("PS", "Phosphatidylserine", 0.82, 2.3, FALSE, "row_title"),
  gr_pi = c("PI", "Phosphatidylinositol", 0.82, 2.3, FALSE, "row_title"),
  gr_lpc = c("LPC", "Lysophosphatidylcholine", 0.65, 1.1, FALSE, "col_title"),
  gr_lpe = c("LPE", "Lysophosphatidylethanolamine", 0.65, 1.25, FALSE, "col_title"),
  gr_lpg = c("LPG", "Lysophosphatidylglycerol", 0.65, 1.05, FALSE, "col_title"),
  gr_lpi = c("LPI", "Lysophosphatidylinositol", 0.65, 1, FALSE, "col_title"),
  gr_lps = c("LPS", "Lysophosphatidylserine", 0.65, 1, FALSE, "col_title")
)


# Define clinical var c(var_name, plot_title, x-lim)
clinical_var <- list(
  c("bmi_pre", bquote("Body mass index"), .7),
  c("tdpa_pre", bquote("Total daily physical activity"), .7),
  c("rd_ss2kg_ffm_insulin_pre", bquote("Glucose R"[d]), .7),
  c("percent_fat_mass_pre", bquote("Body fat %"), .7),
  c("percent_imat_pre", bquote("Thigh IMAT %"), .7),
  c("vo2kg_ffm_pre", bquote(VO[2] ~ "per kg FFM"), .7),
  c("hgb_a1c_pre", bquote("Hemoglobin A1c"), .7),
  c("pcr_p_mrs_pre", bquote("PCr recovery"), .7),
  c("max_oxphos_pre", bquote("Max oxidative phosphorylation"), .7)
)

# Define clinical var c(var_name, plot_title, x-lim)
clinical_var_post <- list(
  c("bmi_post", bquote("Body mass index (post)"), .7),
  c("tdpa_post", bquote("Total daily physical activity (post)"), .7),
  c("rd_ss2kg_ffm_insulin_post", bquote("Glucose R"[d]~"(post)"), .7),
  c("percent_fat_mass_post", bquote("Body fat % (post)"), .7),
  c("percent_imat_post", bquote("Thigh IMAT % (post)"), .7),
  c("vo2kg_ffm_post", bquote(VO[2] ~ "per kg FFM (post)"), .7),
  c("hgb_a1c_post", bquote("Hemoglobin A1c (post)"), .7),
  c("pcr_p_mrs_post", bquote("PCr recovery (post)"), .7),
  c("max_oxphos_post", bquote("Max oxidative phosphorylation (post)"), .7)
)

for (i in 1:length(lipids_groups)){
  for (var in clinical_var){
    hm <- generate_heatmap(color_mapping_common,
                           p_value_limits,
                           hm_title = "", 
                           hm_unit = "Spearman's ρ",
                           lipid_class = lipids_groups[[i]][1],
                           clin_var = var,
                           save_sub_path = "")
  }
}

for (i in 1:length(lipids_groups)){
  for (var in clinical_var_post){
    hm <- generate_heatmap(color_mapping_common,
                           p_value_limits,
                           hm_title = "", 
                           hm_unit = "Spearman's ρ",
                           lipid_class = lipids_groups[[i]][1],
                           clin_var = var,
                           save_sub_path = "post/")
  }
}
```

# ! Correlation grid
```{r}

# Correlation plot function
correlation_plots_publication <- function (plot_lipids, col_titles, selected_clinical, row_titles, y_lims, lipidomicsDF, save_size, save_name, save_sub_path){
  
for (j in 1:length(selected_clinical)) {
  if (j == 1){
    plot_list <- list()
  }
  for (i in 1:length(plot_lipids)) {
    # Organize data and pick top
    correlation_df <- prepare_and_combine_crossSection(
      lipidomicsData = lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),],
      mirageData = mirage_data,
      lipidclass = plot_lipids[i],
      lipidcomposition = NULL
    )
    
    # Create change name
    var_name_pre <- selected_clinical[[j]][[1]]
    
      # Custom function to format p-values
  format_p_value <- function(p_value, digits = 3, threshold = 0.001) {
    if (p_value < threshold) {
      return(paste0("P<", formatC(threshold, format = "f", digits = digits)))
    } else {
      return(paste0("P=", formatC(p_value, format = "f", digits = digits)))
    }
  }
    rho <- correlation_results_crossSection_class$spearman_rho_all[correlation_results_crossSection_class$lipid == plot_lipids[[i]] & correlation_results_crossSection_class$test_against == var_name_pre]
    p_value <- correlation_results_crossSection_class$spearman_p_all[correlation_results_crossSection_class$lipid == plot_lipids[[i]] & correlation_results_crossSection_class$test_against == var_name_pre]
    
    p_value_formated <- format_p_value(p_value)
    
    
        # Prepare labels
    y_label <- selected_clinical[[j]][[2]]
    x_label <- bquote(pmol %.% mg^{-1})
    
    
    # Make TAG, PE and PG nmol instead of pmol
if (plot_lipids[i] %in% c("TAG", "PE", "PC", "PI", "1,2-DG", "1,3-DG")) {
  correlation_df$ pmol_mg_id <- correlation_df$ pmol_mg_id / 1000
  x_label <- bquote(nmol %.% mg^{-1})
}
  
    
    # Make PC/PE percentage point
    if (plot_lipids[i] %in% c("PC.PE", "Cer ratio")) {
      correlation_df$ pmol_mg_id <- correlation_df$ pmol_mg_id * 100  # Make pct point
  x_label <- bquote("%")
}

  
    # Create the plot with a black trendline
 plot <- ggplot(correlation_df, aes(x =  pmol_mg_id, y = !!sym(var_name_pre), shape = group, fill = gender)) +
      geom_point(size = 0.9, stroke = 0.5, color = "black") +
  labs(
    x = x_label,
    y = if (i == 1) selected_clinical[[j]][[2]] else NULL,
    color = "Gender",
    fill = "Gender"
  ) +
  scale_fill_manual(values = c("F" = "orange", "M" = "turquoise")) +  # Define fill colors for gender
  scale_shape_manual(values = c("HED" = 21, "DIWL" = 24, "WLEX" = 22)) +  # Define shapes for group
       scale_x_continuous(breaks = scales::breaks_extended(n = 4.5)) +  # Adjust the number of ticks on the x-axis to 3
      scale_y_continuous(
        limits = c(y_lims[[j]][1], y_lims[[j]][2])
        # , sec.axis = if (i == length(plot_lipids)) sec_axis(~ ., name = y_label) else waiver()
      ) +
      theme_minimal() +
        theme(
          legend.position = "none",
          plot.margin = margin(1, 1, 1, 1),
          axis.title.y = element_text(size = 7, face = if (i == 1) "bold" else "plain"),  # Set text size for left y-axis title
          axis.text.y = element_text(size = 5, face = if (i == 1) "bold" else "plain"),  # Set text size for left y-axis text
          # axis.title.y.right = element_text(size = 8),  # Set text size for right y-axis title
          # axis.text.y.right = element_text(size = 7),  # Set text size for right y-axis text
          axis.title.x = element_text (size = 7),
          axis.text.x = element_text(size = 6)  # Adjust text size for x-axis text
        ) +
      if (p_value < 0.05){
 annotate("text", x = -Inf, y = Inf, label = paste0("rs=", round(rho, 2), "\n", p_value_formated), 
           hjust = -.1, vjust = 1.1, size = 2, fontface = "bold", color = "black", check_overlap = T)
      } else {
        annotate("text", x = -Inf, y = Inf, label = paste0("rs=", round(rho, 2), "\n", p_value_formated), 
           hjust = -.1, vjust = 1.1, size = 2, fontface = "plain", color = "black", check_overlap = T)
      }
    
  # Add trendlines based on P-values
  if (p_value < 0.05) {
    plot <- plot + geom_smooth(aes(group = 1), method = "lm", se = TRUE, color = "black", alpha = 0.3, linewidth = 0.5)
  } else if (p_value < 0.1) {
    plot <- plot + geom_smooth(aes(group = 1), method = "lm", se = FALSE, color = "black", linewidth = 0.5, linetype = "dashed")
  }   
 
 
    # Add column titles only for the first row with adjusted size and bold
    if (j == 1) {
      plot <- plot + ggtitle(col_titles[i]) + theme(
        plot.title = element_text(size = 7.5, face = "bold", hjust = 0.5)
      )
    }
    
    # Remove y-axis labels for non-first columns
    if (i != 1) {
      plot <- plot + theme(
        axis.title.y = element_blank()
      )
    }
    
    # Remove y-axis ticks and text for all but the last column
    if (i != 1) {
      plot <- plot + theme(
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()
      )
    }

    # Remove x-axis text and ticks for all but the last row
    if (j != length(selected_clinical)) {
      plot <- plot + theme(
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank()
      )
    }
    
      plot_list[[length(plot_lipids) * (j - 1) + i]] <- plot
    }
}
  
# Combine plokg/min", "m", "kg")ng patchwork
plot_grid <- wrap_plots(plot_list, ncol = length(plot_lipids), nrow = length(selected_clinical)) +
  plot_layout(guides = "collect", widths = rep(1, length(plot_lipids)), heights = rep(1, length(selected_clinical)))
  

# Display the grid of plots
# print(plot_grid)

# Save the grid of plots in SVG format
ggsave(paste0(getwd(), "/outputs/figures/baseline correlations/grid_plots_classes/", save_sub_path, save_name, ".svg"), plot_grid, device = "pdf", height = save_size[1], width = save_size[2] , units = "mm")
}

# Selected clinical  
clinical_vars <- list(
  c("rd_ss2kg_ffm_insulin_pre", bquote(atop(NA, atop(textstyle(bold("Glucose R"[d])), textstyle( "mg ·(min·kgFFM·ins)"^{-1}))))),
  c("hgb_a1c_pre", bquote(atop(NA, atop(textstyle(bold(HbA1c)), textstyle( "%"))))),
  c("vo2kg_ffm_pre", bquote(atop(NA, atop(textstyle(bold(VO[2] * " peak")), textstyle( "ml · kgFFM"^{-1}))))),
  c("tdpa_pre", bquote(atop(NA, atop(textstyle(bold("Physical activity")), textstyle( "min · day"^{-1}))))),
  c("bmi_pre", bquote(atop(NA, atop(textstyle(bold(BMI)), textstyle( "kg · m"^{2}))))),
  c("percent_fat_mass_pre", bquote(atop(NA, atop(textstyle(bold("Fat mass")), textstyle( "%"))))),
  c("percent_imat_pre", bquote(atop(NA, atop(textstyle(bold("Thigh IMAT")), textstyle( "%")))))
  
  #c("max_oxphos_pre", bquote(atop(NA, atop(textstyle(bold("Max ox phosphorylation")), textstyle("pmol O"[2] ~ "· sec"^{-1} ~ "· mg"^{-1}))))),
  #c("pcr_p_mrs_pre", bquote(atop(NA, atop(textstyle(bold(PCr ~ recovery ~ tau)), textstyle( "s")))))
)

clinical_vars_post <- list(
  c("rd_ss2kg_ffm_insulin_pre", bquote(atop(NA, atop(textstyle(bold("Glucose R"[d])), textstyle( "mg ·(min·kgFFM·ins)"^{-1}))))),
  c("hgb_a1c_pre", bquote(atop(NA, atop(textstyle(bold(HbA1c)), textstyle( "%"))))),
  c("vo2kg_ffm_pre", bquote(atop(NA, atop(textstyle(bold(VO[2] * " peak")), textstyle( "ml · kgFFM"^{-1}))))),
  c("tdpa_pre", bquote(atop(NA, atop(textstyle(bold("Physical activity")), textstyle( "min · day"^{-1}))))),
  c("bmi_pre", bquote(atop(NA, atop(textstyle(bold(BMI)), textstyle( "kg · m"^{2})))))
  #c("percent_imat_pre", bquote(atop(NA, atop(textstyle(bold("Thigh IMAT")), textstyle( "%"))))),
  #c("max_oxphos_pre", bquote(atop(NA, atop(textstyle(bold("Max ox phosphorylation")), textstyle("pmol O"[2] ~ "· sec"^{-1} ~ "· mg"^{-1}))))),
  #c("pcr_p_mrs_pre", bquote(atop(NA, atop(textstyle(bold(PCr ~ recovery ~ tau)), textstyle( "s")))))
)


clinical_limits <- list(
  c(min = 0.02, max = 0.22),
  c(min = 4.5, max = 10),
  c(min = 15, max = 45),
  c(min = 0, max = 350),
  c(min = 25, max = 50),
  c(min = 5, max = 17.5),
  c(min = 20, max = 80),
  c(min = 15, max = 35)
  )

# Info about each plot class
TAG_plot_lipids <- c("TAG","1,2-DG", "1,3-DG", "AC")
TAG_plot_colNames <- c("TAG", "1,2-DAG", "1,3-DAG", "AC")

correlation_plots_publication(plot_lipids = TAG_plot_lipids,
                              col_titles = TAG_plot_colNames,
                              selected_clinical = clinical_vars,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(180, 120),
                              save_name = "Acylglycerols_AC",
                              save_sub_path = "")

correlation_plots_publication(plot_lipids = TAG_plot_lipids,
                              col_titles = TAG_plot_colNames,
                              selected_clinical = clinical_vars_post,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(180, 120),
                              save_name = "Acylglycerols_AC",
                              save_sub_path = "post/")

# # Info about each plot class
# AC_plot_lipids <- c("AC")
# AC_plot_colNames <- c("AC")

# correlation_plots_publication(plot_lipids = AC_plot_lipids,
#                               col_titles = AC_plot_colNames,
#                               selected_clinical = clinical_vars,
#                               y_lims = clinical_limits,
#                               lipidomicsDF = lipidomicsDF,
#                               save_size = c(180, 45),
#                               save_name = "Acylcarnitine")



# Define plot_lipids and col_titles for Sphingolipids (first and second rows combined)
Sphingolipids_plot_lipids <- c("Cer", "Cer ratio", "dhCer", "GluCer", "LacCer", "SPH", "SPM")
Sphingolipids_plot_colNames <- c("Cer", "Cer 16:0/24:0", "dhCer", "GluCer", "LacCer", "SPH", "SPM")

correlation_plots_publication(plot_lipids = Sphingolipids_plot_lipids,
                              col_titles = Sphingolipids_plot_colNames,
                              selected_clinical = clinical_vars,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(180, 165),
                              save_name = "Ceramides",
                              save_sub_path = "")

correlation_plots_publication(plot_lipids = Sphingolipids_plot_lipids,
                              col_titles = Sphingolipids_plot_colNames,
                              selected_clinical = clinical_vars_post,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(180, 165),
                              save_name = "Ceramides",
                              save_sub_path = "post/")

# Define plot_lipids and col_titles for Phospholipids (first and second rows combined)
Phospholipids_plot_lipids <- c("PC", "PE", "PC.PE", "PA", "PG", "PS", "PI")
Phospholipids_plot_colNames <- c("PC", "PE", "PC/PE", "PA", "PG", "PS", "PI")

correlation_plots_publication(plot_lipids = Phospholipids_plot_lipids,
                              col_titles = Phospholipids_plot_colNames,
                              selected_clinical = clinical_vars,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(180, 165),
                              save_name = "Phopholipids",
                              save_sub_path = "")

correlation_plots_publication(plot_lipids = Phospholipids_plot_lipids,
                              col_titles = Phospholipids_plot_colNames,
                              selected_clinical = clinical_vars_post,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(180, 165),
                              save_name = "Phopholipids",
                              save_sub_path = "post/")


# Define plot_lipids and col_titles for Lysophospholipids (first and second rows combined)
Lysophospholipids_plot_lipids <- c("LPC", "LPE", "LPG", "LPI", "LPS")
Lysophospholipids_plot_colNames <- c("LPC", "LPE", "LPG", "LPI", "LPS")

correlation_plots_publication(plot_lipids = Lysophospholipids_plot_lipids,
                              col_titles = Lysophospholipids_plot_colNames,
                              selected_clinical = clinical_vars,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(180, 165),
                              save_name = "Lysophopholipids",
                              save_sub_path = "")

correlation_plots_publication(plot_lipids = Lysophospholipids_plot_lipids,
                              col_titles = Lysophospholipids_plot_colNames,
                              selected_clinical = clinical_vars_post,
                              y_lims = clinical_limits,
                              lipidomicsDF = lipidomicsDF,
                              save_size = c(180, 165),
                              save_name = "Lysophopholipids",
                              save_sub_path = "post/")

```




## volcano
```{r}
volcano_crossSection <- function(input_vars, save_sub_path){
  # Combine class and composition data
  correlation_results_crossSection_class_and_comp <- rbind(correlation_results_crossSection_composition, correlation_results_crossSection_class)
  
  
  # Remove NA rows
  correlation_results_crossSection_class_and_comp <- correlation_results_crossSection_class_and_comp[!is.na(correlation_results_crossSection_class_and_comp$spearman_rho_all), ]
  
  # Select columns: Rho and p-value
  vulc_data_crossSection <- correlation_results_crossSection_class_and_comp %>% 
    select("lipid", "test_against", "spearman_rho_all", "spearman_p_all")
  
  # Filter rows where 'test_against' column values are in 'input_vars'
  vulc_data_crossSection <- vulc_data_crossSection[vulc_data_crossSection$test_against %in% input_vars, ]
  
  # ********* P-ADJUST ***********
  
  Adjust the p-value column based test_against and count of all lipids
  vulc_data_crossSection <- vulc_data_crossSection %>%
    group_by(test_against) %>%
    mutate(across("spearman_p_all", ~ p.adjust(.x, method = "BH"), .names = "p_value")) %>%
    ungroup()
  
  # # adjust p-values by count within group and lipidClass
  # # First reintroduce lipidclass
  # vulc_data_crossSection <- vulc_data_crossSection %>%
  #   mutate(lipidClass = sub("^(\\S+)\\s.*$", "\\1", lipid)) %>%
  #   group_by(test_against, lipidClass) %>%
  #   mutate(p_value = p.adjust(spearman_p_all, method = "BH")) %>%
  #   ungroup()
  
  # ********************
  
  # Make a identifier column that combines lipid and test_against
  vulc_data_crossSection$identifier <- paste0(vulc_data_crossSection$lipid, " ~ ", vulc_data_crossSection$test_against)
  
  
  ### Plot settings
  # Set threshold for when to plot label
  threshold_rho <- 0.2
  
  # Assuming unique_tests has been defined as before
  unique_tests <- sort(unique(vulc_data_crossSection$test_against))
  
  
  # Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
  base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                                c = 100, 
                                l = 65)[1:length(unique_tests)]
  
  # Assign each test to a color
  colors_for_tests <- setNames(base_colors, unique_tests)
  
  ### Create plot
  vulc_plot <- ggplot(vulc_data_crossSection, aes(x = spearman_rho_all, y = -log10(p_value))) +
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", linewidth = 0.2) +
    geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
    scale_color_manual(values = colors_for_tests) +
    scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12), guide = FALSE) + # TRUE for significant, FALSE for not
    geom_text_repel(aes(label = ifelse(p_value < 0.06 & abs(spearman_rho_all) > threshold_rho, identifier, "")),
                    box.padding = .3, point.padding = .3,
                    size = 3, segment.color = 'grey50') +
    theme_minimal() +
    xlim(-1,1) +
    guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) + # Hide the alpha legend and fix the color legend
    labs(title = paste0("Correlations at baseline - ", save_sub_path), x = "Spearman rho", y = "-log10 P-value")+
    theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  
  # Save path
  save_path <- paste0( getwd(), "/outputs/cross section/volcano/", save_sub_path, ".jpeg")
  
  # Save the plot
  ggsave(save_path , plot = vulc_plot, width = 12, height = 8, dpi = 400)
  
}


# Run function

# Loop through each main category in mirage_crossSection_vars
for (i in seq_along(mirage_crossSectional_vars)) {
  # Print the name of the current list being processed
  list_name <- names(mirage_crossSectional_vars)[i]
  print(paste("Processing list:", list_name))
  
  # Use lapply to iterate over each sublist in the current category
  names_to_use <- unlist(lapply(mirage_crossSectional_vars[[i]], function(sublist) {
    # Check if the sublist is long enough to have at least the first element
    if(length(sublist) >= 1) {
      # Replace '_pre' with '_ch' in the first element
      return( sublist[1])
    } else {
      return(NA)  # Return NA if the sublist does not have at least one element
    }
  }))
  
  volcano_crossSection(input_vars = names_to_use , save_sub_path = list_name)
}

```

## p-value plots

**Correct p-values based on Bejamini-Hochberg**

```{r}
# BH correct p-values
# Name the columns that should be adjusted
cols_to_adjust <- c(
  "pearson_p_all", "spearman_p_all"
)

# Function to apply BH correction within each "test_against" group
adjust_p_values_within_group <- function(data, cols_to_adjust) {
  data %>%
    group_by(test_against) %>%
    mutate(across(all_of(cols_to_adjust), ~ p.adjust(.x, method = "BH"), .names = "{.col} (corrected)")) %>%
    ungroup()
}


# Apply adjustment function
# Composition and class
# Combine class and composition
correlation_results_crossSection_class_and_comp <- rbind(correlation_results_crossSection_composition, correlation_results_crossSection_class)
# Run adjustment
correlation_results_crossSection_class_and_comp <-
  adjust_p_values_within_group(correlation_results_crossSection_class_and_comp, cols_to_adjust)

# Composition
correlation_results_crossSection_composition <-
  adjust_p_values_within_group(correlation_results_crossSection_composition, cols_to_adjust)

# Class
correlation_results_crossSection_class <-
  adjust_p_values_within_group(correlation_results_crossSection_class, cols_to_adjust)

```

**Plot p-values**

```{r}
generate_barplot_crossSection <- function(data, col_non_corrected, col_corrected, output_base_path, data_name) {
  # Define common sizes for axis titles and plot title
  axis_title_size <- 12
  plot_title_size <- 13
  
  # Loop over every unique test
  for (test_var in unique(data$test_against)) {
    # Filter based on test variable and columns of interest
    data_test_filtered <- data %>%
      filter(test_against == test_var) %>%
      select(lipid, test_against, pearson_p_all, spearman_p_all, `pearson_p_all (corrected)`, `spearman_p_all (corrected)`)
    
    # Remove row if non corrected column is Na
    data_test_filtered <- data_test_filtered[!is.na(data_test_filtered[[col_non_corrected]]), ]
    
    # Dynamic adjustment of the label size based on the number of bars (lipids)
    num_bars <- length(unique(data_test_filtered$lipid))
    label_size <- max(2, min(10, 50 / sqrt(num_bars))) # Adjusted dynamically
    
    
    # Generate plot for non-corrected p-values
    p1 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_non_corrected]]), y = data_test_filtered[[col_non_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_non_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )
    
    # Generate plot for corrected p-values
    p2 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_corrected]]), y = data_test_filtered[[col_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )
    
    # Combine the two plots
    subplot <- p1 + p2
    
    # Construct the subfolder path based on 'test_var'
    subfolder_path <- file.path(output_base_path, gsub("[ :()]", "_", test_var)) # Replace problematic characters
    
    # Ensure the subfolder exists
    dir.create(subfolder_path, recursive = TRUE, showWarnings = FALSE)
    
    # Construct the plot filename, ensuring no problematic characters for file names
    plot_filename <- paste0(gsub("[ :()]", "_", col_non_corrected), ", ", data_name, test_var, ".jpeg") # Replace spaces and special characters with underscores
    
    # Save the plot
    ggsave(file.path(subfolder_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
  }
}


# RUN FUNCTIONS
# Add a second row to cols_to_adjust with corrected column names
plot_nonadj_vs_adj <- data.frame(original = cols_to_adjust, corrected = paste0(cols_to_adjust, " (corrected)"))

# Just leave empty, as ch already indicates change in file name
dataframe_name_comp <- ""


# For lipid class
# Define output path
output_base_path <- paste0(getwd(), "/outputs/cross section/plot, p-value sorted cross section/class")

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_class, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}


# For lipid composition within lipid class
# Define output path
output_base_path <- paste0(getwd(), "/outputs/cross section/plot, p-value sorted cross section/composition")

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_composition, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}

# For lipid composition and lipid class combined
# Define output path
output_base_path <- paste0(getwd(), "/outputs/cross section/plot, p-value sorted cross section/class and composition")

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_class_and_comp, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}
```

# Pre-post analysis

## Mixed models

Insulin sensitivity. Original data was analyzed by one-way ANOVA. So this would be to double check results mixed model for pre-post changes for every lipid composition within all lipid classes and for every lipid class.

```{r}
# Set the max number of observations that the emmeans package will handle. Lower number shorter computation times, larger number, more precise CI and p-value estimates
emm_options(pbkrtest.limit = 6000) # change to 5000 after code works

mixedmodel_pre_post <- function(dataset, response_var, lipidclass, lipidcomposition = NULL) {
  
  # Print progress
  ifelse( is.null(lipidcomposition),
          print (paste0( "Analysing ", lipidclass, "...")),
          print( paste0( "Analysing ", lipidclass, " ", lipidcomposition, "...")))
  
  # Filter dataset based on lipidclass and optionally lipidcomposition
  if (!is.null(lipidcomposition)) {
    data_to_model <- filter(dataset, lipidClass == lipidclass & lipidComposition == lipidcomposition)
  } else {
    data_to_model <- filter(dataset, lipidClass == lipidclass)
    
    # Make sum for each id and timepoint
    data_to_model <- data_to_model %>%
    group_by(id, lipidClass, time, group) %>%
    summarize(pmol_mg_sum = sum(pmol_mg, na.rm = TRUE),, .groups = "drop") %>%
    ungroup()
  }
  
  # Check number of non-zero rows
  non_zero_rows <- data_to_model %>% 
    filter(!!sym(response_var) > 0) %>% 
    nrow()
  
  # only proceed if number of non zero rows is above cutoff
  if (non_zero_rows < analysis_cutoff){
    
    results_list <- list(
      lipidClass = as.character(lipidclass),
      lipidComposition = as.character(lipidcomposition),
      slope_results = NA_real_,
      prepost_results = NA_real_
      # slope_results.ci = NA_real_,
      # prepost_results.ci = NA_real_
    )
    
    results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
    
    return(results_list)
  } else {
    
    # Prepare factors
    data_to_model$group <- factor(data_to_model$group, levels = c("HED", "DIWL", "WLEX"))
    data_to_model$time <- factor(data_to_model$time, levels = c("Pre", "Post"))
    
    
    # Determine if lipidComposition can be a random effect
    if (!is.null(lipidcomposition) || length(unique(data_to_model$lipidComposition)) <= 1) {
      model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id)"))
    } else {
      #model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id) + (1 + time | lipidComposition)"))
      model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id)"))
    }
    
    # Try-catch block for model fitting
    tryCatch(
      {
        model <- lmer(model_formula,
                      data = data_to_model,
                      na.action = na.exclude)
        # Estimated marginal of means to get out slope and between groups statistics
        emm <- emmeans(model, ~ time * group)
        
        
        # Contrasts for differences in slopes between groups
        model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")
        
        model.slope.contrasts.results <- summary(model.slope.contrasts)
        
        # # Calculate confidence interval
        # ci_slopes <- confint(model.slope.contrasts)
        
        # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
        model.slope.contrasts.results <- model.slope.contrasts.results %>%
          mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
          select(contrast, estimate, SE, df, t.ratio, p.value)
        
        # Pre, Post between group comparisons
        prepost.contrasts <- pairs(emm, adjust = "none")
        
        # ci_prepost <- confint(prepost.contrasts)
        
        # Get results
        prepost.contrasts.results <- summary(prepost.contrasts)
        
        # Create results list
        results_list <- list(
          lipidClass = as.character(lipidclass),
          lipidComposition = as.character(lipidcomposition),
          slope_results = model.slope.contrasts.results,
          prepost_results = prepost.contrasts.results
          # slope_results.ci = ci_slopes,
          # prepost_results.ci = ci_prepost
        )
        
        # Name results list
        ifelse( is.null(lipidcomposition),
                results_list <- setNames(list(results_list), lipidclass),
                results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
        )
        
        return(results_list)
      },
      error = function(e) {
        results_list <- list(
          lipidClass = as.character(lipidclass),
          lipidComposition = as.character(lipidcomposition),
          slope_results = NA_real_,
          prepost_results = NA_real_
          # slope_results.ci = NA_real_,
          # prepost_results.ci = NA_real_
        )
        
        results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
        
        return(results_list)
      }
    )
  }
}

# Define lipidclasses and compositions to use by removing the ratios
lipid_classes <- unique(unique_combinations$lipidClass[!unique_combinations$lipidClass == "Cer ratio"])

lipid_classes_per_comp <- unique_combinations$lipidClass[!unique_combinations$lipidClass == "PC.PE"]

lipid_compositions <- unique_combinations$lipidComposition[!unique_combinations$lipidClass == "PC.PE"]

# Order compositions correcty
order(lipid_compositions)

# Run function for lipid composition
# PC.PE is not analysed as a composition, but only as class
# result.lipid.pre_post.class_comp <- pmap(
#   list(lipidClass = lipid_classes_per_comp,
#        lipidComposition = lipid_compositions),
#   ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", ..1, ..2)
# )

# Outlier removed
result.lipid.pre_post.class_comp.outlierRM <- pmap(
  list(lipidClass = lipid_classes_per_comp,
       lipidComposition = lipid_compositions),
  ~ mixedmodel_pre_post(lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),], "pmol_mg", ..1, ..2)
)
# Flatten to set  list names to first level
# result.lipid.pre_post.class_comp <- flatten(result.lipid.pre_post.class_comp)
result.lipid.pre_post.class_comp.outlierRM <- flatten(result.lipid.pre_post.class_comp.outlierRM)



# # Use map to iterate over lipid classes
# result.lipid.pre_post.class <- map(lipid_classes, ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", .x))

# With outliers removed - NB. imputed values could be used instead.
result.lipid.pre_post.class.outlierRM <- map(lipid_classes, ~ mixedmodel_pre_post(lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),], "pmol_mg_sum", .x))

#result.lipid.pre_post.class <- flatten(result.lipid.pre_post.class)
result.lipid.pre_post.class.outlierRM <- flatten(result.lipid.pre_post.class.outlierRM)
```

## Mixed model - corrections
```{r}
# Add sex to lipidomics DF
if(! "gender" %in% colnames(lipidomicsDF)){
  lipidomicsDF <- lipidomicsDF %>%
    left_join(mirage_data %>% select(id, gender), by = "id")
}
# Add age
if(! "age" %in% colnames(lipidomicsDF)){
  lipidomicsDF <- lipidomicsDF %>%
    left_join(mirage_data %>% select(id, age_pre), by = "id") %>% 
    rename(age = age_pre)
}

# Adding bmi
if (!"bmi" %in% colnames(lipidomicsDF)) {
  lipidomicsDF <- lipidomicsDF %>%
    left_join(mirage_data %>% select(id, bmi_pre, bmi_post), by = "id") %>%
    mutate(bmi = case_when(
      time == "Pre" ~ bmi_pre,
      time == "Post" ~ bmi_post,
      TRUE ~ NA_real_
    )) %>%
    select(-bmi_pre, -bmi_post)
}


# Set the max number of observations that the emmeans package will handle. Lower number shorter computation times, larger number, more precise CI and p-value estimates
emm_options(pbkrtest.limit = 6000) # change to 5000 after code works

mixedmodel_pre_post <- function(dataset, response_var, lipidclass, lipidcomposition = NULL) {
  
  # Print progress
  ifelse( is.null(lipidcomposition),
          print (paste0( "Analysing ", lipidclass, "...")),
          print( paste0( "Analysing ", lipidclass, " ", lipidcomposition, "...")))
  
  # Filter dataset based on lipidclass and optionally lipidcomposition
  if (!is.null(lipidcomposition)) {
    data_to_model <- filter(dataset, lipidClass == lipidclass & lipidComposition == lipidcomposition)
  } else {
    data_to_model <- filter(dataset, lipidClass == lipidclass)
  }
  
  
  # Check number of non-zero rows
  non_zero_rows <- data_to_model %>% 
    filter(pmol_mg > 0) %>% 
    nrow()
  
  # only proceed if number of non zero rows is above cutoff
  if (non_zero_rows < analysis_cutoff){
    
    results_list <- list(
      lipidClass = as.character(lipidclass),
      lipidComposition = as.character(lipidcomposition),
      slope_results = NA_real_,
      prepost_results = NA_real_
      # slope_results.ci = NA_real_,
      # prepost_results.ci = NA_real_
    )
    
    results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
    
    return(results_list)
  } else {
    
    # Prepare factors
    data_to_model$group <- factor(data_to_model$group, levels = c("HED", "DIWL", "WLEX"))
    data_to_model$time <- factor(data_to_model$time, levels = c("Pre", "Post"))
    
    
    # Determine if lipidComposition can be a random effect
    if (!is.null(lipidcomposition) || length(unique(data_to_model$lipidComposition)) <= 1) {
      model_formula <- as.formula(paste(response_var, "~ time * group + age + (1 | id)"))
    
    } else {
      model_formula <- as.formula(paste(response_var, "~ time * group + age + (1 | id) + (1 + time | lipidComposition)"))
      }
    
    
    # Try-catch block for model fitting
    tryCatch(
      {
        model <- lmer(model_formula,
                      data = data_to_model,
                      na.action = na.exclude)
        
        
        # Estimated marginal of means to get out slope and between groups statistics
        emm <- emmeans(model, ~ time * group)
        
        # Contrasts for differences in slopes between groups
        model.slope.contrasts <- contrast(emm, method = "pairwise", interaction = "pairwise", adjust = "none")
        
        model.slope.contrasts.results <- summary(model.slope.contrasts)
        
        # # Calculate confidence interval
        # ci_slopes <- confint(model.slope.contrasts)
        
        # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
        model.slope.contrasts.results <- model.slope.contrasts.results %>%
          mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
          select(contrast, estimate, SE, df, t.ratio, p.value)
        
        # Pre, Post between group comparisons
        prepost.contrasts <- pairs(emm, adjust = "none")
        
        # ci_prepost <- confint(prepost.contrasts)
        
        # Get results
        prepost.contrasts.results <- summary(prepost.contrasts)
        
        # Create results list
        results_list <- list(
          lipidClass = as.character(lipidclass),
          lipidComposition = as.character(lipidcomposition),
          slope_results = model.slope.contrasts.results,
          prepost_results = prepost.contrasts.results
          # slope_results.ci = ci_slopes,
          # prepost_results.ci = ci_prepost
        )
        
        # Name results list
        ifelse( is.null(lipidcomposition),
                results_list <- setNames(list(results_list), lipidclass),
                results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
        )
        
        return(results_list)
      },
      error = function(e) {
        results_list <- list(
          lipidClass = as.character(lipidclass),
          lipidComposition = as.character(lipidcomposition),
          slope_results = NA_real_,
          prepost_results = NA_real_
          # slope_results.ci = NA_real_,
          # prepost_results.ci = NA_real_
        )
        
        results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
        
        return(results_list)
      }
    )
  }
}

# Define lipidclasses and compositions to use by removing the ratios
lipid_classes <- unique(unique_combinations$lipidClass[!unique_combinations$lipidClass == "Cer ratio"])

lipid_classes_per_comp <- unique_combinations$lipidClass[!unique_combinations$lipidClass == "PC.PE"]

lipid_compositions <- unique_combinations$lipidComposition[!unique_combinations$lipidClass == "PC.PE"]

# # Run function for lipid composition
# # PC.PE is not analysed as a composition, but only as class
# result.lipid.pre_post.class_comp <- pmap(
#   list(lipidClass = lipid_classes_per_comp,
#        lipidComposition = lipid_compositions),
#   ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", ..1, ..2)
# )

# Outlier removed
result.lipid.pre_post.class_comp.outlierRM <- pmap(
  list(lipidClass = lipid_classes_per_comp,
       lipidComposition = lipid_compositions),
  ~ mixedmodel_pre_post(lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),], "pmol_mg", ..1, ..2)
)
# Flatten to set  list names to first level
#result.lipid.pre_post.class_comp <- flatten(result.lipid.pre_post.class_comp)
result.lipid.pre_post.class_comp.outlierRM <- flatten(result.lipid.pre_post.class_comp.outlierRM)


# # Use map to iterate over lipid classes
# result.lipid.pre_post.class <- map(lipid_classes, ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", .x))

# With outliers removed - NB. imputed values could be used instead.
result.lipid.pre_post.class.outlierRM <- map(lipid_classes, ~ mixedmodel_pre_post(lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),], "pmol_mg", .x))

#result.lipid.pre_post.class <- flatten(result.lipid.pre_post.class)
result.lipid.pre_post.class.outlierRM <- flatten(result.lipid.pre_post.class.outlierRM)
```

### Adjust factor for correct estimates and CI
NB. not used and does not work!
Codes tries to make a scaling factor to convert emmeans CI to a scale that would fit with the means.
The current code tries to use a ratio between then group, time mean - the real mean - and the mean provided by the model and apply the factor to the CI. However, the resulting CI is precisely centered around the real mean, which suggests that this approach does not work.

If we would like to get CI, the obvious option would be to run simple t-tests on the sums. This would work, but outliers would not be handled as well and id could not be a random factor.

```{r}
# Calculate the means for each groups at each time point
class_means <- lipidomicsDF %>% 
  group_by(id, lipidClass, time, group) %>%
  summarize(id_sum = sum(pmol_mg, na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(lipidClass, time, group) %>% 
  summarize(mean_pmol_mg = mean(id_sum, na.rm = TRUE)) %>%
  ungroup()


# Pivot wider to have 'Pre' and 'Post' means in separate columns
class_means <- class_means %>%
  pivot_wider(names_from = time, values_from = mean_pmol_mg, 
              names_prefix = "time_")

# Calculate the difference of means
class_means <- class_means %>%
  mutate(difference_of_mean = time_Post - time_Pre)

class_means$difference_of_mean[class_means$lipidClass== "TAG" & class_means$group == "WLEX"]

# View the final data frame
print(class_means_final)


# Make ratio between calculated mean and model mean from result.lipid.pre_post.class
model_mean_diwl <- as.numeric(result.lipid.pre_post.class.outlierRM$TAG$prepost_results.ci[result.lipid.pre_post.class.outlierRM$TAG$prepost_results.ci$contrast =="Pre WLEX - Post WLEX", c("estimate")])

model_real_ratio <- as.numeric( class_means[class_means$lipidClass == "TAG" & class_means$group == "WLEX", "difference_of_mean"] / model_mean_diwl)

CI_diwl <- as.numeric(result.lipid.pre_post.class.outlierRM$TAG$prepost_results.ci[result.lipid.pre_post.class.outlierRM$TAG$prepost_results.ci$contrast =="Pre WLEX - Post WLEX", c("lower.CL", "upper.CL")])

adjusted_CI <- model_real_ratio * CI_diwl / 1000

print(adjusted_CI)
# Make object with adjusted mean and CI
```

### QC: Diff p-values
```{r}
library(broom)
# Calculate class sums for each id
class_sums <- lipidomicsDF %>% 
  group_by(id, lipidClass, time, group) %>% 
  summarize( class_sum = sum(pmol_mg)) %>% 
  ungroup()

# Imputed
class_sums_outlier.imp <- lipidomicsDF %>% 
  group_by(id, lipidClass, time, group) %>% 
  summarize( class_sum = sum(pmol_mg_imp)) %>% 
  ungroup()


# Calculate pre-post delta
class_deltas <- class_sums %>%
  filter(time %in% c("Pre", "Post")) %>%
  pivot_wider(
    names_from = time, 
    values_from = class_sum, 
    names_prefix = "class_sum_"
  ) %>%
  group_by(id, lipidClass, group) %>%
  summarize(
    class_delta = class_sum_Post - class_sum_Pre,
    .groups = "drop"
  ) %>%
  ungroup()

# Calculate pre-post delta
class_deltas.imp <- class_sums_outlier.imp %>%
  filter(time %in% c("Pre", "Post")) %>%
  pivot_wider(
    names_from = time, 
    values_from = class_sum, 
    names_prefix = "class_sum_"
  ) %>%
  group_by(id, lipidClass, group) %>%
  summarize(
    class_delta = class_sum_Post - class_sum_Pre,
    .groups = "drop"
  ) %>%
  ungroup()


# Calculate t-tests based on delta
results_ttest <- class_deltas %>%
  filter(group %in% c("DIWL", "WLEX")) %>%
  group_by(lipidClass) %>%
  do(tidy(t.test(class_delta ~ group, data = .))) %>%
  ungroup()

# Calculate t-tests based on delta
results_ttest.imp <- class_deltas.imp %>%
  filter(group %in% c("DIWL", "WLEX")) %>%
  group_by(lipidClass) %>%
  do(tidy(t.test(class_delta ~ group, data = .))) %>%
  ungroup()


# Create table with lipid classes and p-values
p_value_table <- results_ttest %>%
  select(lipidClass, p.value)

# Imputed
p_value_table.imp <- results_ttest.imp %>%
  select(lipidClass, p.value)

# Renaming the p.value column
p_value_table <- p_value_table %>%
  rename(p.value.ttest = p.value)

# For imputed
p_value_table.imp <- p_value_table.imp %>%
  rename(p.value.ttest.imp = p.value)

# Join imputed ttest p-values
p_value_table <- p_value_table.imp %>%
  left_join(p_value_table, by = "lipidClass")

# Extract p-values from mixed model
# Function to extract the third p-value from each lipid class results
extract_p_value <- function(lipid_class_results) {
  if (!is.null(lipid_class_results$slope_results$p.value) && length(lipid_class_results$slope_results$p.value) >= 3) {
    return(lipid_class_results$slope_results$p.value[[3]])
  } else {
    return(NA)  # Return NA if the p-value does not exist or the structure is incorrect
  }
}
# Apply the function to each lipidClass and create a data frame
p_value_mixed <- sapply(result.lipid.pre_post.class, extract_p_value, USE.NAMES = TRUE)
p_value_mixed_df <- data.frame(lipidClass = names(p_value_mixed), p.value.mixed = p_value_mixed, stringsAsFactors = FALSE)

# without outliers
p_value_mixed.noOutliers <- sapply(result.lipid.pre_post.class.outlierRM, extract_p_value, USE.NAMES = TRUE)
p_value_mixed_df.noOutliers <- data.frame(lipidClass = names(p_value_mixed.noOutliers), p.value.mixed.noOutliers = p_value_mixed.noOutliers, stringsAsFactors = FALSE)


# Join mixed model p-values
p_value_table <- p_value_mixed_df %>%
  left_join(p_value_table, by = "lipidClass")

p_value_table <- p_value_mixed_df.noOutliers %>%
  left_join(p_value_table, by = "lipidClass")

# Make with correct decimals
p_value_table <- p_value_table %>%
  mutate(
    p.value.ttest = round(p.value.ttest, digits = 5),
    p.value.ttest.imp = round(p.value.ttest.imp, digits = 5),
    p.value.mixed = round(p.value.mixed, digits = 5),
    p.value.mixed.noOutliers = round(p.value.mixed.noOutliers, digits = 5)
  )

# Add a sorting order based on p.value.mixed.noOutliers
p_value_table_ordered <- p_value_table %>%
  mutate(ordering = rank(p.value.mixed.noOutliers, ties.method = "first")) %>%
  arrange(ordering)

# Reshape data from wide to long, preserving the ordering
p_value_long <- p_value_table_ordered %>%
  pivot_longer(
    cols = starts_with("p.value"),
    names_to = "p_value_type",
    values_to = "p_value"
  )

# Factor the lipidClass with levels specified by the ordering to ensure ggplot uses this order
p_value_long$lipidClass <- factor(p_value_long$lipidClass, levels = unique(p_value_long$lipidClass))

# Create a grouped bar plot with ordered lipidClass
ggplot(p_value_long, aes(x = lipidClass, y = p_value, fill = p_value_type)) +
  geom_col(position = position_dodge(width = 0.8), alpha = 0.8) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") + 
  labs(title = "P-values comparisons: Pre-post for DIWL vs WLEX",
       subtitle = "Mixed model: lipidcomposition and id as random factors \nt-tests: calculated on lipidclass pre-post deltas",
       x = "Lipid Class",
       y = "P-value",
       fill = "P-value Type") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x labels for better readability

```


## Prepare data

Sort, adjust by Benjamini-Hochberg for lipid composition within lipid class

```{r}
prepare_lipid_data_for_plotting <- function(result_data) {
  pvals_df <- data.frame()
  est_df <- data.frame()
  
  contrasts_prepost <- c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX")
  contrasts_slope <- c("Pre - Post : HED - DIWL", "Pre - Post : HED - WLEX", "Pre - Post : DIWL - WLEX")
  
  for (test_name in names(result_data)) {
    # Check if prepost_results and slope_results are not NULL
    if (!is.na(result_data[[test_name]]$prepost_results[[1]][1])) {
      prepost_results <- result_data[[test_name]]$prepost_results
    } else {
      prepost_results <- data.frame(contrast = character(), p.value = numeric())
    }
    
    if (!is.na(result_data[[test_name]]$slope_results[[1]][1])) {
      slope_results <- result_data[[test_name]]$slope_results
    } else {
      slope_results <- data.frame(contrast = character(), p.value = numeric())
    }
    
    # Proceed with extraction using the ensured data frames
    prepost_pvals <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)
    
    slope_pvals <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)
    
    prepost_est <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    slope_est <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    
    # Combine values  %>%  single data
    # p-values
    combined_pvals <- c(prepost_pvals, slope_pvals)
    combined_pvals <- setNames(combined_pvals, c(contrasts_prepost, contrasts_slope))
    pvals_df <- rbind(pvals_df, cbind(lipid = test_name, t(as.data.frame(list(combined_pvals)))))
    
    # Estimates
    combined_est <- c(prepost_est, slope_est)
    combined_est <- setNames(combined_est, c(contrasts_prepost, contrasts_slope))
    est_df <- rbind(est_df, cbind(lipid = test_name, t(as.data.frame(list(combined_est)))))
    
  }
  
  # Select all columns after the first one to exclude lipid column
  corrected_cols <- names(pvals_df)[-1]
  
  # Remove rows where every column from the second column onwards contains NA
  pvals_df <- pvals_df[rowSums(is.na(pvals_df[, -1])) < (ncol(pvals_df) - 1), ]
  
  # Apply Benjamini-Hochberg correction and create new columns with the suffix "_BH_corrected"
  for (col in corrected_cols) {
    
    # ********** P ADJUSTMENT ***********

    # # adjust p-values by group and lipidClass
    # # P-values based on test counts within lipid class.
    pvals_df <- pvals_df %>%
      mutate(lipidClass = sub("([^_]+)_.*", "\\1", lipid)) %>%
      group_by(lipidClass) %>%
      mutate(
        !!paste0(col, " (corrected)") := p.adjust(.data[[col]], method = "none") # METHOD FOR P-adjust: none, e.g. no adjustment applied.
      ) %>%
      ungroup() %>%
      select(-lipidClass)  # Remove the lipidClass column
   
       # P-values based on all test count
      pvals_df[[paste0(col, " (corrected)")]] <- p.adjust(pvals_df[[col]], method = "none")
  }
  
  # ********** P ADJUSTMENT ***********
  
  # Reset row names to simple sequential numbers
  rownames(pvals_df) <- NULL
  rownames(est_df) <- NULL
  
  # Only keep rows in est_df where the lipid values match those in pvals_df
  est_df <- est_df[est_df$lipid %in% pvals_df$lipid, ]
  
  # Convert the columns to numeric
  # p-vals
  for (i in 2:ncol(pvals_df)) {
    if (!is.numeric(pvals_df[[i]])) {
      pvals_df[[i]] <- as.numeric(pvals_df[[i]])
    }
  }
  # estimates 
  for (i in 2:ncol(est_df)) {
    if (!is.numeric(est_df[[i]])) {
      est_df[[i]] <- as.numeric(est_df[[i]])
    }
  }
  
  # Combine the est and pvals dataframes into a list to be returned
  est_and_pvals <- list(p.vals = pvals_df, estimates = est_df)
  return(est_and_pvals)
}


## Code from when class and composition was seperated
# Prepare data for plotting lipid composition within each lipid class
# est_and_p_lipid_comp <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_comp)


# Outlier rm
est_and_p_lipid_comp.outlierRM <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_comp.outlierRM)  

# # Prepare data for plotting lipid classes
# est_and_p_pvals_lipid_class <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class)
# Outlier rm
est_and_p_pvals_lipid_class.outlierRM <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class.outlierRM)



# ### Code for when class and composition were combined
# # Combine lists
# result.lipid.pre_post.class_and_comp <- c(result.lipid.pre_post.class_comp, result.lipid.pre_post.class)
# # Outlier removed
# result.lipid.pre_post.class_and_comp.outlierRM <- c(result.lipid.pre_post.class_comp.outlierRM, result.lipid.pre_post.class.outlierRM)
# 
# # Run prepare data function on combined list
# est_and_p_lipid_class_and_comp <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_and_comp)
# # Outlier rm
# est_and_p_lipid_class_and_comp.outlierRM <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_and_comp.outlierRM)

```

## !!! Publication plots
### Fig. 1: Classes
```{r}
# Add sex to lipidomics DF
if(! "gender" %in% colnames(lipidomicsDF)){
  lipidomicsDF <- lipidomicsDF %>%
    left_join(mirage_data %>% select(id, gender), by = "id")
}

plot_lipid_class <- function(lipidomicsDF, lipid_class, p_val_df, unit, y_limit, y_label_cutoff, y.labels, save_subfolder) {
  
  
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))
  
  # MAKE SUM FOR EACH ID
  pmol_mg_class_sum <- filtered_data %>%
    group_by(lipidClass, group, id, time) %>%
    summarize(
      sum_pmol_mg = sum(pmol_mg_imp, na.rm = TRUE),
      sum_log_transformed = log(sum_pmol_mg + 1), #Add one to avoid 0 failure during transform
      .groups = "drop") %>% 
    mutate(sum_pmol_mg = ifelse(lipidClass == "TAG" | lipidClass == "PE" | lipidClass == "PC", sum_pmol_mg/1000, sum_pmol_mg)) %>% 
    left_join(filtered_data %>% distinct(id, gender), by = "id")  # Add gender column back
  
  
  mean_data_class <- pmol_mg_class_sum %>%
    group_by(group, time, lipidClass) %>%
    summarise(mean_class = mean(!!sym(unit), na.rm = TRUE), .groups = 'drop')
  
  print( paste0("LIPID CLASS: ", lipid_class))
  print(mean_data_class)
  
  # Get p-values
  p_slope_DIWL_WLEX.num <- p_val_df[[lipid_class]]$slope_results[p_val_df[[lipid_class]]$slope_results$contrast =="Pre - Post : DIWL - WLEX", c("p.value")]
  
    p_slope_DIWL_HED.num <- p_val_df[[lipid_class]]$slope_results[p_val_df[[lipid_class]]$slope_results$contrast =="Pre - Post : HED - DIWL", c("p.value")]
    
    p_slope_WLEX_HED.num <- p_val_df[[lipid_class]]$slope_results[p_val_df[[lipid_class]]$slope_results$contrast =="Pre - Post : HED - WLEX", c("p.value")]
  
  p_prepost_HED.num <- p_val_df[[lipid_class]]$prepost_results[p_val_df[[lipid_class]]$prepost_results$contrast =="Pre HED - Post HED", c("p.value")]
  
  p_prepost_DIWL.num <- p_val_df[[lipid_class]]$prepost_results[p_val_df[[lipid_class]]$prepost_results$contrast =="Pre DIWL - Post DIWL", c("p.value")]
  
  p_prepost_WLEX.num <-p_val_df[[lipid_class]]$prepost_results[p_val_df[[lipid_class]]$prepost_results$contrast =="Pre WLEX - Post WLEX", c("p.value")]
  
  # Custom function to format p-values
  format_p_value <- function(p_value, digits = 3, threshold = 0.001) {
    if (p_value < threshold) {
      return(paste0("P<", formatC(threshold, format = "f", digits = digits)))
    } else {
      return(paste0("P=", formatC(p_value, format = "f", digits = digits)))
    }
  }
  
  # Formatting p-values using the custom function
  p_slope_DIWL_WLEX <- format_p_value(p_slope_DIWL_WLEX.num)
  p_prepost_HED<- format_p_value(p_prepost_HED.num)
  p_prepost_DIWL <- format_p_value(p_prepost_DIWL.num)
  p_prepost_WLEX <- format_p_value(p_prepost_WLEX.num)
  
  
  # Add * if HED time x group against HED is significant
  if (p_slope_DIWL_HED.num < 0.05){
    p_prepost_DIWL <- paste0(p_prepost_DIWL, "*")
  }
  
  if (p_slope_WLEX_HED.num < 0.05){
    p_prepost_WLEX <- paste0(p_prepost_WLEX, "*")
  }
  
  
  # Use switch to simplify the conditional checks
  y_label <- y.labels
  
  x_pos <- c(.0, .12, .22, 0.34, 0.46, 0.58)
  y_lim <- y_limit
  
  x_positions <- data.frame(
    combo = c("DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post", "HED Pre", "HED Post"),
    x_pos = x_pos  # Manual positions
  )
  
  # Adding these positions to your data frames based on matching group and time combinations
  pmol_mg_class_sum$x_pos <- x_positions$x_pos[match(interaction(pmol_mg_class_sum$group, pmol_mg_class_sum$time, sep = " "), x_positions$combo)]
  mean_data_class$x_pos <- x_positions$x_pos[match(interaction(mean_data_class$group, mean_data_class$time, sep = " "), x_positions$combo)]
  
  # Create the plot
  plot <- ggplot(pmol_mg_class_sum, aes(x = x_pos, y = !!sym(unit), group = interaction(id, group))) +
    geom_line(aes(group = interaction(id, group)), color = "black", alpha = 0.9, linewidth = 0.05) +
    geom_point(aes(color = gender), alpha = 0.6, size = 0.1) +
    scale_color_manual(values = c("F" = "orange", "M" = "turquoise")) +  # Define colors for gender
    geom_boxplot(aes(group = interaction(group, time)),
                 fill = NA, width = 0.03, alpha = 0, outlier.shape = NA,
                 position = position_dodge(width = 0.25), color = "black", linewidth = 0.25
    ) +
    geom_line(data = mean_data_class, aes(x = x_pos, y = mean_class, group = group), color = "black", linewidth = .7, lineend = "round") +
    labs(y = y_label, x = "") +
    theme_minimal() +
    theme(panel.background = element_rect("transparent", color = NA),
          plot.background = element_rect(fill='transparent', color=NA),
          axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 45, hjust = 1.2, vjust = 2.4, size = 6),
          axis.title.y = element_text(size = 7, face = "plain"),
          axis.text.y = element_text(size = 6),
          
          legend.position = "none", legend.title = element_text(hjust = 0.5, size = 6),
          panel.grid.major.x = element_blank(),
          plot.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"),
          panel.grid.minor.x = element_blank(), plot.title = element_text(hjust = 0.5)) +
    coord_cartesian(clip = "off") +
    scale_x_continuous(breaks = x_positions$x_pos, labels=c("Pre","Post","Pre","Post","Pre","Post"))+
    scale_y_continuous(
      limits = y_lim
    )
  
  
  # add significance levels
  x_offset <- -0.01
  text_size <- 1.8
  y_pos_line_1 <- y_lim[2] * 0.88; y_pos_line_2 <- y_lim[2] * 0.94
  y_pos_text_1 <- y_lim[2] * 0.90; y_pos_text_2 <- y_lim[2] *0.96
  
  plot <- plot +
    geom_line(data=tibble(x = c(x_pos[1]+x_offset, x_pos[2]-x_offset)), y =c(y_pos_line_1, y_pos_line_1), aes(x=x, y=y), inherit.aes = FALSE) +
    geom_line(data=tibble(x = c(x_pos[3]+x_offset, x_pos[4]-x_offset)), y =c(y_pos_line_1, y_pos_line_1), aes(x=x, y=y), inherit.aes = FALSE) +
    geom_line(data=tibble(x = c(x_pos[5]+x_offset, x_pos[6]- x_offset)), y =c(y_pos_line_1, y_pos_line_1), aes(x=x, y=y), inherit.aes = FALSE) +
    geom_line(data=tibble(x = c((x_pos[2]-x_pos[1])/2+x_pos[1], (x_pos[4]-x_pos[3])/2+x_pos[3])), y =c(y_pos_line_2, y_pos_line_2), aes(x=x, y=y), inherit.aes = FALSE)+
    geom_text(data = tibble(x = c((x_pos[2]-x_pos[1])/2 + x_pos[1])), y = c(y_pos_text_1), aes(x = x, y = y),
              label = p_prepost_DIWL, inherit.aes = FALSE, size = text_size, 
              fontface = ifelse(p_prepost_DIWL.num < 0.05, "bold", "plain")) +
    geom_text(data = tibble(x = c((x_pos[4]-x_pos[3])/2 + x_pos[3])), y = c(y_pos_text_1), aes(x = x, y = y),
              label = p_prepost_WLEX, inherit.aes = FALSE, size = text_size, 
              fontface = ifelse(p_prepost_WLEX.num < 0.05, "bold", "plain")) + 
    geom_text(data = tibble(x = c((x_pos[6]-x_pos[5])/2 + x_pos[5])), y = c(y_pos_text_1), aes(x = x, y = y),
              label = p_prepost_HED, inherit.aes = FALSE, size = text_size, 
              fontface = ifelse(p_prepost_HED.num < 0.05, "bold", "plain")) + 
    geom_text(data = tibble(x = c((x_pos[1] + x_pos[4]) / 2)), y = c(y_pos_text_2), aes(x = x, y = y),
              label = p_slope_DIWL_WLEX, inherit.aes = FALSE, size = text_size, 
              fontface = ifelse(p_slope_DIWL_WLEX.num < 0.05, "bold", "plain")) + 
    
    
    # Add lines and text for group labels
    geom_text(data= tibble(x = c((x_pos[1]+x_pos[2])/2, (x_pos[3]+x_pos[4])/2, (x_pos[5]+x_pos[6])/2)), y =c(0), aes(x=x, y=y),
              label=c("DIWL", "WLEX", "HED"), inherit.aes = FALSE, vjust  = 4.4, fontface="bold", size = 2)
  
  return(plot)
}

# Make lipid class settings
y.lims <- list("TAG" = c(0, 190 ,200),
               "1,2-DG" = c(0, 2300, 1700),
               "1,3-DG" = c(0, 1000, 1000),
               "AC" = c(0, 500, 500),
               "Cer" = c(0, 150, 150),
               "dhCer" = c(0, 2.8, 2.8),
               "GalCer" = c(0, 60, 60),
               "GluCer" = c(0, 10, 10),
               "LacCer" = c(0, 90, 90),
               "LPC" = c(0, 350, 350),
               "LPE" = c(0, 200, 200),
               "LPG" = c(0, 2.5, 2.5),
               "LPI" = c(0, 180, 180),
               "LPS" = c(0, 70, 70),
               "PA" = c(0, 50, 50),
               "PC" = c(0, 17.5, 17.5),
               "PE" = c(0, 13.5, 13.5),
               "PG" = c(0, 200, 200),
               "PI" = c(0, 6000, 6000),
               "PS" = c(0, 2000, 2000),
               "SPH" = c(0, 5.5, 5.5),
               "SPM" = c(0, 2800, 2000),
               "Cer ratio" = c(0, .65, .65),
               "PC.PE" = c(0, 4.5, 4.5)
               
)

y.labels <- list(
  "TAG" = bquote("Triacylglycerol (nmol · mg"^-1*")"),
  "1,2-DG" = bquote("1,2-diacylglycerol (pmol · mg"^-1*")"),
  "1,3-DG" = bquote("1,3-diacylglycerol (pmol · mg"^-1*")"),
  
  "AC" = bquote("Acylcarnitine (pmol · mg"^-1*")"),
  
  "Cer" = bquote("Ceramide (pmol · mg"^-1*")"),
  "Cer ratio" = bquote("Ceramide 16:0 / ceramide 24:0"),
  "dhCer" = bquote("Dihydroceramide (pmol · mg"^-1*")"),
  
  "GluCer" = bquote("Glucosylceramide (pmol · mg"^-1*")"),
  "LacCer" = bquote("Lactosylceramide (pmol · mg"^-1*")"),
  "SPH" = bquote("Sphingosine (pmol · mg"^-1*")"),
  "SPM" = bquote("Sphingomyelin (pmol · mg"^-1*")"),
  
  "GalCer" = bquote("Galactosylceramide (pmol · mg"^-1*")"),
  
  
  "LPC" = bquote("Lysophosphatidylcholine (pmol · mg"^-1*")"),
  "LPE" = bquote("Lysophosphatidylethanolamine (pmol · mg"^-1*")"),
  "LPG" = bquote("Lysophosphatidylglycerol (pmol · mg"^-1*")"),
  "LPI" = bquote("Lysophosphatidylinositol (pmol · mg"^-1*")"),
  "LPS" = bquote("Lysophosphatidylserine (pmol · mg"^-1*")"),
  "PA" = bquote("Phosphatidic acid (pmol · mg"^-1*")"),
  "PC" = bquote("Phosphatidylcholine (nmol · mg"^-1*")"),
  "PE" = bquote("Phosphatidylethanolamine (nmol · mg"^-1*")"),
  "PG" = bquote("Phosphatidylglycerol (pmol · mg"^-1*")"),
  "PI" = bquote("Phosphatidylinositol (pmol · mg"^-1*")"),
  "PS" = bquote("Phosphatidylserine (pmol · mg"^-1*")"),
  
  "PC.PE" = bquote("Phosphatidylcholine / phophoethanolamine")
)


# Loop to call the plotting function for each lipid class
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)

# Copy to new results list
results_to_plot <- result.lipid.pre_post.class.outlierRM
# Add ceramide ratio
results_to_plot$`Cer ratio` <- result.lipid.pre_post.class_comp.outlierRM$`Cer ratio_16:0 24:0`

list_of_plots <- list()

for (lipid_class in unique_lipid_classes) {
  list_of_plots[[lipid_class]] <- plot_lipid_class(lipidomicsDF = lipidomicsDF,
                                                   lipid_class = lipid_class,
                                                   p_val_df = results_to_plot,
                                                   y_limit = y.lims[[lipid_class]][1:2],
                                                   y_label_cutoff = y.lims[[lipid_class]][3], # Not implemented
                                                   y.labels = y.labels [[lipid_class]],
                                                   unit = "sum_pmol_mg",
                                                   save_subfolder = "")
}

acylglycerole_row.1 <-
  list_of_plots[["TAG"]] | 
  list_of_plots[["1,2-DG"]] | 
  list_of_plots[["1,3-DG"]] 

Sphingolipids_row.1 <- list_of_plots[["Cer"]] | 
  list_of_plots[["dhCer"]] | 
list_of_plots[["SPH"]]

#list_of_plots[["GalCer"]] | 

Sphingolipids_row.2 <-
  list_of_plots [["SPM"]] |
  list_of_plots [["GluCer"]] |
  list_of_plots[["LacCer"]]



phospholipid_row.1 <-
  list_of_plots[["PC"]] | 
  list_of_plots[["PE"]] | 
  list_of_plots[["PA"]] 

phospholipid_row.2 <-
  list_of_plots[["PG"]] | 
  list_of_plots[["PS"]] |
  list_of_plots[["PI"]] 


lysophospholipids_row.1 <-
  list_of_plots[["LPG"]] |
  list_of_plots[["LPC"]] | 
  list_of_plots[["LPE"]]
  

lysophospholipids_row.2 <-
  list_of_plots[["LPI"]] |
  list_of_plots[["LPS"]]


acylcarnitine_row.1 <- list_of_plots[["AC"]]

ratios_row.1 <-
  # list_of_plots[["Cer ratio"]] |
  list_of_plots[["PC.PE"]]

# output device:
device_out <- "pdf"


# Plot and save

plot_layout_1 <- acylglycerole_row.1 +
  plot_layout(guides = 'collect') +
  plot_annotation(tag_levels = 'A') &
  theme(plot.tag.position = c(0, .98))  # Adjust tag position
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "tag_ac.svg")
ggsave(filename, plot = plot_layout_1, device = cairo_pdf, width = 6, height = 3)

plot_sphingo_1 <- Sphingolipids_row.1  +
  plot_annotation(tag_levels = 'A') &
  theme(
    plot.tag = element_text(size = 12),  # Adjust size as needed
    plot.tag.position = c(0, .98)  # Adjust tag position
  )
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "sphingolipids_1.svg")
ggsave(filename, plot = plot_sphingo_1, device = device_out, width = 6, height = 3)

plot_sphingo_2 <- Sphingolipids_row.2 +
  plot_annotation(tag_levels = list(c('D', "E", "F", "G"))) &
  theme(
    plot.tag = element_text(size = 12),  # Adjust size as needed
    plot.tag.position = c(0, .98)  # Adjust tag position
  )
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "sphingolipids_2.svg")
ggsave(filename, plot = plot_sphingo_2, device = device_out, width = 6, height = 3)

plot_phospholipids_1 <- phospholipid_row.1 +
  plot_annotation(tag_levels = 'A') &
  theme(
    plot.tag = element_text(size = 12),
    plot.tag.position = c(0, .98)  # Adjust tag position
  )
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "phospholipids_1.svg")
ggsave(filename, plot = plot_phospholipids_1, device = device_out, width = 6, height = 3)

plot_phospholipids_2 <- phospholipid_row.2 +
  plot_annotation(tag_levels = list(c('D', "E", "F", "G"))) &
  theme(
    plot.tag = element_text(size = 12),  # Adjust size as needed
    plot.tag.position = c(0, .98)  # Adjust tag position
  )
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "phospholipids_2.svg")
ggsave(filename, plot = plot_phospholipids_2, device = device_out, width = 6, height = 3)

plot_lyso1 <- lysophospholipids_row.1 +
  plot_annotation(tag_levels = 'A') &
  theme(
    plot.tag = element_text(size = 12),  # Adjust size as needed
    plot.tag.position = c(0, .98)  # Adjust tag position
  )
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "lysophospholipids_1.svg")
ggsave(filename, plot = plot_lyso1, device = device_out, width = 6, height = 3)

plot_lyso2 <- lysophospholipids_row.2 +
  plot_annotation(tag_levels = list(c('D', "E"))) &
  theme(
    plot.tag = element_text(size = 12),  # Adjust size as needed
    plot.tag.position = c(0, .98)  # Adjust tag position
  )
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "lysophospholipids_2.svg")
ggsave(filename, plot = plot_lyso2, device = device_out, width = 3, height = 3)


plot_ac <- acylcarnitine_row.1 +  
  plot_annotation(tag_levels = list(c('A'))) &
  theme(
    plot.tag = element_text(size = 12),  # Adjust size as needed
    plot.tag.position = c(0, .98)  # Adjust tag position
  )
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "acylcarnitine.svg")
ggsave(filename, plot = plot_ac, device = device_out, width = 2.5, height = 3)

plot_ratios <- ratios_row.1
# +  plot_annotation(tag_levels = 'A') &
#   theme(
#     plot.tag = element_text(size = 12),  # Adjust size as needed
#     plot.tag.position = c(0, .98)  # Adjust tag position
#   )
filename <- paste0(getwd(), "/outputs/figures/figure 1/", "ratios.svg")
ggsave(filename, plot = plot_ratios, device = device_out, width = 2.5, height = 3)


```
### !!!Figure: Composiion Heatmaps

#### Prepare data
```{r}
### Data prepare
# When class and composition is analysed together, merge p-values and correlations
pvals_df <- est_and_p_lipid_comp.outlierRM$p.vals
estimates_df <- est_and_p_lipid_comp.outlierRM$estimates

pvals_df_sorted <- pvals_df[order(pvals_df$lipid), ]

# Select the specified columns for hm_data.p-vals matrix
pvals_df <- pvals_df[ , c("lipid", "Pre HED - Post HED (corrected)", "Pre DIWL - Post DIWL (corrected)", 
                          "Pre WLEX - Post WLEX (corrected)", "Pre - Post : HED - DIWL (corrected)",
                          "Pre - Post : HED - WLEX (corrected)", "Pre - Post : DIWL - WLEX (corrected)")]


### Calculate log2 change and percentage change
log2fold_ch_comp <- lipidomicsDF %>%
  filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidClass, lipidComposition, group) %>%
  summarize(
    log2fCh = log2(mean(pmol_mg[time == "Post"], na.rm = TRUE) / 
                     mean(pmol_mg[time == "Pre"], na.rm = TRUE)),
    percent_change = (mean(pmol_mg[time == "Post"], na.rm = TRUE) - 
                        mean(pmol_mg[time == "Pre"], na.rm = TRUE)) / 
      mean(pmol_mg[time == "Pre"], na.rm = TRUE) * 100,
    .groups = "drop"
  )

# # Class
# log2fold_ch_class <- lipidomicsDF %>%
#   group_by(lipidClass, group) %>%
#   summarize(
#     log2fCh = log2(mean(pmol_mg_imp[time == "Post"], na.rm = TRUE) / 
#                           mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE)),
#     .groups = "drop"
#   )

# Make names to match lipid
# Composition
log2fold_ch_comp <- log2fold_ch_comp %>%
  mutate(lipid = paste(lipidClass, lipidComposition, sep = "_")) %>%
  select(-lipidComposition, -lipidClass)

# # Class
# log2fold_ch_class <- log2fold_ch_class %>%
#   rename(lipid = lipidClass)

# Combine lipid composition and lipid class data
log2fold_ch <- log2fold_ch_comp  #rbind(log2fold_ch_class, log2fold_ch_comp)

# Rename col names to match the ones on the DF
log2fold_ch <- log2fold_ch %>%
  mutate(group = case_when(
    group == "HED"  ~ "Pre HED - Post HED",
    group == "DIWL" ~ "Pre DIWL - Post DIWL",
    group == "WLEX" ~ "Pre WLEX - Post WLEX",
    TRUE ~ group  # Keeps the original value if none of the above conditions are met
  ))

### Replace the model change values with the log2change
# Reshape estimates_df from wide to long format to make replacement
estimates_long <- estimates_df %>%
  pivot_longer(
    cols = c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX"),
    names_to = "group",
    values_to = "value"
  )
# perform replacement based on lipid and group
estimates_long_log2ch <- estimates_long %>%
  left_join(log2fold_ch, by = c("lipid", "group")) %>%
  mutate(value = percent_change) %>%
  select(-log2fCh, -percent_change)

# pivot back to wide format
estimates_df_log2ch <- estimates_long_log2ch %>%
  pivot_wider(
    names_from = group,
    values_from = value
  )

### Slope: Relative changes
# Calculate the mean at time Pre for every lipidComposition within lipidClass and for lipidClass across all groups to use for normalization
lipidomicsDF <- lipidomicsDF %>%
  # Class only
  group_by(lipidClass) %>%
  mutate(pmol_mg_pre_mean_class = ifelse(time == "Pre", mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE), NA)) %>%
  ungroup() %>% 
  # Add the mean for composition
  filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidComposition, lipidClass) %>%
  mutate(pmol_mg_pre_mean_comp = ifelse(time == "Pre", mean(pmol_mg[time == "Pre"], na.rm = TRUE), NA)) %>%
  ungroup()


# Calculate absolute pre-post changes
# Composition
slope_norm_ch_comp <- lipidomicsDF %>%
  filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidClass, lipidComposition, group) %>%
  summarize(
    norm_ch = (mean(pmol_mg[time == "Post"], na.rm = TRUE) - 
                 mean(pmol_mg[time == "Pre"], na.rm = TRUE)) /
      mean(pmol_mg_pre_mean_comp[time == "Pre"], na.rm = TRUE),
    .groups = "drop"
  )
# 
# # Class
# slope_norm_ch_class <- lipidomicsDF %>%
#   group_by(lipidClass, group) %>%
#   summarize(
#     norm_ch = (mean(pmol_mg_imp[time == "Post"], na.rm = TRUE) - 
#       mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE)) / 
#       mean(pmol_mg_pre_mean_class[time == "Pre"], na.rm = TRUE),
#     .groups = "drop"
#   )

# Make single lipid name for later matching
# Composition
slope_norm_ch_comp <- slope_norm_ch_comp %>%
  mutate(lipid = paste(lipidClass, lipidComposition, sep = "_")) %>%
  select(-lipidComposition, -lipidClass)

# # Class
# slope_norm_ch_class <- slope_norm_ch_class %>%
#   rename(lipid = lipidClass)

# Combine lipid composition and lipid class data
slope_norm_ch <- slope_norm_ch_comp  #rbind(slope_norm_ch_class, slope_norm_ch_comp)

# Spread the data for each group to be a separate column
slope_norm_ch_wide <- slope_norm_ch %>%
  pivot_wider(names_from = group, values_from = norm_ch)

# Calculate the difference between slope changes and make pct.
# This makes the values differences in "percentage points"
slope_ch_pp <- slope_norm_ch_wide %>%
  mutate(`Pre - Post : HED - WLEX` = (WLEX - HED)*100,
         `Pre - Post : HED - DIWL` = (DIWL - HED)*100,
         `Pre - Post : DIWL - WLEX` = (WLEX - DIWL)*100)

# Remove the cols with differences between pre and post
slope_ch_pp <- slope_ch_pp %>%
  select(-WLEX, -HED, -DIWL)

# Replace slope values in the estimates data frame
# Join the dataframes based on 'lipid' to align rows
joined_df <- estimates_df_log2ch %>%
  left_join(slope_ch_pp, by = "lipid", suffix = c("", ".normch"))

# Replace values in the original columns with values from the joined columns
estimates_df_plotData <- joined_df %>%
  mutate(`Pre - Post : HED - DIWL` = `Pre - Post : HED - DIWL.normch`,
         `Pre - Post : HED - WLEX` = `Pre - Post : HED - WLEX.normch`,
         `Pre - Post : DIWL - WLEX` = `Pre - Post : DIWL - WLEX.normch`) %>%
  select(-ends_with(".normch"))


# Convert tibble to dataframe for later naming
estimates_df_plotData <- as.data.frame(estimates_df_plotData)

# Select pre - post: DIWL-WLEX row and pre DIWL - post DIWL and Pre WLEX - Post WLEX
pvals_df <- pvals_df %>%
  select(
    `lipid`,
    `Pre DIWL - Post DIWL (corrected)`,
    `Pre WLEX - Post WLEX (corrected)`,
    `Pre - Post : DIWL - WLEX (corrected)`
  )

estimates_df_plotData <- estimates_df_plotData %>% 
  select(
    `lipid`,
    `Pre DIWL - Post DIWL`,
    `Pre WLEX - Post WLEX`,
    `Pre - Post : DIWL - WLEX`
  )

# Rename columns 
estimates_df_plotData <- estimates_df_plotData %>%
  rename(
    `group DIWL` = `Pre DIWL - Post DIWL`,
    `group WLEX` = `Pre WLEX - Post WLEX`,
    `DIWL vs WLEX` = `Pre - Post : DIWL - WLEX`
  )

# Rename columns 
pvals_df <- pvals_df %>%
  rename(
    `group DIWL` = `Pre DIWL - Post DIWL (corrected)`,
    `group WLEX` = `Pre WLEX - Post WLEX (corrected)`,
    `DIWL vs WLEX` = `Pre - Post : DIWL - WLEX (corrected)`
  )

```

#### Make heatmap
```{r}
# Set 'lipid' as row names
pvals_df_heatMap <- data.frame(pvals_df, check.names = FALSE)
estimates_df_heatMap <- estimates_df_plotData

rownames(pvals_df_heatMap) <- pvals_df_heatMap$lipid
rownames(estimates_df_heatMap) <- estimates_df_heatMap$lipid

# Remove the 'lipid' column
pvals_df_heatMap <- pvals_df_heatMap[ , !(names(pvals_df_heatMap) %in% c("lipid"))]
estimates_df_heatMap <- estimates_df_heatMap[ , !(names(estimates_df_heatMap) %in% c("lipid"))]

# # Rename columns by removing " (corrected)" from all column names in pvals_df_heatMap
# colnames(pvals_df_heatMap) <- gsub(" \\(corrected\\)", "", colnames(pvals_df_heatMap))

# Sort column names
common_cols <- intersect(colnames(estimates_df_heatMap), colnames(pvals_df_heatMap))
estimates_df_heatMap <- estimates_df_heatMap[, common_cols, drop = FALSE]
pvals_df_heatMap <- pvals_df_heatMap[, common_cols, drop = FALSE]

### Devide dataframe based on lipid groups
# Define lipid groups
lipids_groups <- list(
  gr_tag_ac = c("TAG"),
  gr_1_2_dg = c("1,2-DG"),
  gr_1_3_dg = c("1,3-DG"),
  gr_ac = c("AC"),
  gr_cer = c("Cer"),
  gr_cer_ratio = c("Cer ratio"),
  gr_dhcer = c("dhCer"),
  gr_glucer = c("GluCer"),
  gr_laccer = c("LacCer"),
  gr_sph = c("SPH"),
  gr_spm = c("SPM"),
  gr_pc = c("PC"),
  gr_pe = c("PE"),
  gr_pc_pe = c("PC.PE"),
  gr_pa = c("PA"),
  gr_pg = c("PG"),
  gr_ps = c("PS"),
  gr_pi = c("PI"),
  gr_lpc = c("LPC"),
  gr_lpe = c("LPE"),
  gr_lpg = c("LPG"),
  gr_lpi = c("LPI"),
  gr_lps = c("LPS")
)

# Full names, height, width of output file, legend display (TRUE or FALSE), col or row title, output print
lipids_groups_full_names <- list(
  gr_tag_ac = c("Triacylglycerol", .7, 6, FALSE, "row_title"),
  gr_1_2_dg = c("1,2-diacylglycerol", .85, 6, TRUE,"row_title"),
  gr_1_3_dg = c("1,3-diacylglycerol", .85, 6, FALSE, "row_title"),
  gr_ac = c("Acylcarnitine", 0.7, 2.5, FALSE, "row_title"),
  
  gr_cer = c("Ceramide", .9, 3, FALSE, "row_title"),
  gr_cer_ratio = c("Ceramide ratio", 1, 3, TRUE, "row_title"),
  gr_dhcer = c("Dihydroceramide", .9, 3, TRUE,"row_title"),
  
  gr_glucer = c("Glucosylceramide", .9, 2, FALSE, "row_title"),
  gr_laccer = c("Lactosylceramide", .9, 2, FALSE, "row_title"),
  gr_sph = c("Sphingosine", .9, 2, FALSE, "row_title"),
  gr_spm = c("Sphingomyelin", .9, 2, FALSE, "row_title"),
  
  
  gr_pc = c("Phosphatidylcholine", 1.05, 6, TRUE,"row_title"),
  gr_pe = c("Phosphatidylethanolamine", 1.12, 6, FALSE,"row_title"),
  gr_pc_pe = c("Phosphatidylcholine.Phosphatidylethanolamine", 1, 6, FALSE,"row_title"),
  
  gr_pa = c("Phosphatidic acid", .9, 3, FALSE,"row_title"),
  gr_pg = c("Phosphatidylglycerol", .9, 3, FALSE,"row_title"),
  gr_ps = c("Phosphatidylserine", .9, 3, FALSE,"row_title"),
  gr_pi = c("Phosphatidylinositol", .9, 3, FALSE,"row_title"),
  
  
  gr_lpc = c("Lysophosphatidylcholine", 1, 1.5, FALSE,"col_title"),
  gr_lpe = c("Lysophosphatidylethanolamine", 1, 3, TRUE,"col_title"),
  gr_lpg = c("Lysophosphatidylglycerol", 1, 1.5, FALSE,"col_title"),
  gr_lpi = c("Lysophosphatidylinositol", 1, 1.5, FALSE,"col_title"),
  gr_lps = c("Lysophosphatidylserine", 1, 1.5, FALSE,"col_title")
)




### Divide dataframe based on lipid groups with lipid as row name
filter_lipid_group_row <- function(data_frame, lipid_group) {
  
  # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  
  # Convert row names to a temporary column for sorting and filtering
  data_frame_with_lipid <- tibble::rownames_to_column(data_frame, var = "lipid")
  
  # Filter based on the pattern
  sorted_filtered_data_frame_with_lipid <- data_frame_with_lipid[grepl(pattern, data_frame_with_lipid$lipid), ]
  
  # Drop the temporary lipid column and return to original format
  rownames(sorted_filtered_data_frame_with_lipid) <- sorted_filtered_data_frame_with_lipid$lipid
  sorted_filtered_data_frame <- sorted_filtered_data_frame_with_lipid[ , !colnames(sorted_filtered_data_frame_with_lipid) %in% 'lipid', drop = FALSE]
  return(sorted_filtered_data_frame)
}


# Apply the filter function to each group and store the results in a lists
# p-values
pvals_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = pvals_df_heatMap)

# estimates
estimates_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = estimates_df_heatMap)

# Convert all dataframes to matrices
matrices_pvals <- lapply(pvals_gr_list, function(x) as.matrix(x))
matrices_estimates <- lapply(estimates_gr_list, function(x) as.matrix(x))

# Remove Cer ratio row
matrices_estimates[["gr_cer"]] <- matrices_estimates[["gr_cer"]] [rownames(matrices_estimates[["gr_cer"]] ) != "Cer ratio_16:0 24:0", ]
matrices_pvals[["gr_cer"]] <- matrices_pvals[["gr_cer"]] [rownames(matrices_pvals[["gr_cer"]] ) != "Cer ratio_16:0 24:0", ]

generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims, hm_title, hm_unit) {
  
    # Remove class name from matrix to only show composition
  colnames(hm_matrix) <- sub(".*?_", "", colnames(hm_matrix))
  
  Heatmap(hm_matrix,
          name = hm_unit, # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 5), # Change font size of row labels
          row_names_rot = 0,
          
          #column_split = rep(1:(ncol(hm_matrix) / 3), each = 3), # Splits the columns and names them
          column_title = hm_title,
          column_names_rot = 90, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 5),
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 5.5, fontface = "bold"),
          
          
          heatmap_legend_param = list(
            title = "Percent",   # Legend title
            direction = "vertical",  # Set legend labels vertically
            title_gp = gpar(fontsize = 6, fontface = "bold"),   # Adjust title font size
            labels_gp = gpar(fontsize = 5),  # Adjust label font size
            color_key_height = unit(0.3, "cm"),  # Adjust the color key height
            color_key_width = unit(.8, "cm"),     # Adjust the color key width
            legend_width = unit(2, "cm"),        # Adjust the width of the legend box
            legend_height = unit(1.4, "cm"),      # Adjust the height of the legend box
            title_position = "topcenter"        # Move the title to the top center of the legend
          ),
          show_heatmap_legend = lipids_groups_full_names[[i]][4],
          
          # column_title = NULL, # Removes titles for split (could be adjusted to represent test)
          
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
            
            if (is.na(hm_matrix[i, j])) {
  grid.rect(unit(x, "npc"), unit(y, "npc"), width, height, gp = gpar(fill = "grey", col = NA))
} else if (!is.na(p_val_matrix[i, j])) {
  if (p_val_matrix[i, j] < pLims$p1) {
    grid.text("***", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 6, fontface = "bold", lineheight = 0.35), just = "center")
  } else if (p_val_matrix[i, j] < pLims$p2) {
    grid.text("**", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 6, fontface = "bold", lineheight = 0.35), just = "center")
  } else if (p_val_matrix[i, j] < pLims$p3) {
    grid.text("*", unit(x, "npc"), unit(y, "npc") - unit(0.06, "npc"), gp = gpar(col = "black", fontsize = 6, fontface = "bold", lineheight = 0.35), just = "center")
                  }
            }
          })
}

# Define color map for heatmap
color_mapping_common <- colorRamp2(c(-200, 0, 200), c("blue", "white", "red"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
heatmap_combined <- list()
# hm_slope_list <- list()
# hm_pre_post_list <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)){
  
  print("Plotting: ")
  print(lipids_groups[[i]])
  
  
  hm_slope <- generate_heatmap(t(matrices_estimates[[i]][,3, drop = FALSE]),
                               t(matrices_pvals[[i]][,3, drop = FALSE]),
                               color_mapping_common,
                               p_value_limits,
                               hm_title = "", 
                               hm_unit = "Percent")
  
  hm_pre_post <- generate_heatmap(t(matrices_estimates[[i]][,1:2, drop = FALSE]),
                                  t(matrices_pvals[[i]][,1:2, drop = FALSE]),
                                  color_mapping_common,
                                  p_value_limits,
                                  hm_title = "",
                                  hm_unit = "Percent")
  
  
  # Combine heatmaps vertically and draw
  # savelocation_png <- paste0(getwd(), "/outputs/figures/figure 1/heatmaps/", lipids_groups_full_names[[i]][1], ".png")
  savelocation_svg <- paste0(getwd(), "/outputs/figures/figure 1/heatmaps/", lipids_groups_full_names[[i]][1], ".svg")
  
  
  # Open a png device to save the heatmap
  
  height <- as.double(lipids_groups_full_names[[i]][2])
  width <- as.double(lipids_groups_full_names[[i]][3])
  
  # Define the titles conditionally
  row_title <- if (lipids_groups_full_names[[i]][5] == "row_title") lipids_groups_full_names[[i]][1] else NULL
  column_title <- if (lipids_groups_full_names[[i]][5] == "col_title") lipids_groups_full_names[[i]][1] else NULL
  
  # png(savelocation_png, width = width*300, height = height*300, res = 300) # dimensions in pixels
  pdf(savelocation_svg, width = width, height = height) # dimensions in inches
  
  # Draw the combined heatmap with conditional titles
  # Draw the combined heatmap with conditional titles and adjusted spacing
  draw(hm_slope %v% hm_pre_post, 
       row_title = row_title,
       column_title = column_title,
       heatmap_legend_side = "right", 
       annotation_legend_side = "right",
       column_title_gp = gpar(fontsize = 6, fontface = "bold", lineheight = -5), # Adjust lineheight for spacing
       row_title_gp = gpar(fontsize = 6, fontface = "bold"),
       background = "transparent")
  
  
  # Close the device
  dev.off()
}

```

## Scatter plots
### Lipid composition

Composition scatter plot Data points above ULOQ and below LLOQ are marked with triangles for.

```{r}
# Create a named vector mapping IDs to continuous values for coloring
# color_map <- setNames(mirage_data$gender, mirage_data$id)

plot_lipid <- function(lipidomicsDF, lipid_composition, lipid_class, detection_limits, p_val_df, p_val_df_outlierRM, unit, save_subfolder) {
  
  filtered_data <- filter(lipidomicsDF, lipidClass == lipid_class & lipidComposition == lipid_composition)
  
  # Find the min and max of the y-axis data and add a buffer
  y_min <- min(filtered_data[[unit]], na.rm = TRUE) * 0.95 # 5% buffer reduced
  y_max <- max(filtered_data[[unit]], na.rm = TRUE) * 1.05 # 5% buffer increased
  
  # Find correct p-values
  search_key <- paste(lipid_class, lipid_composition, sep = "_")
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]
  pvalues_to_annotate.outlierRM <- p_val_df_outlierRM [p_val_df_outlierRM[, 1] == search_key, ]
  
  
  # Calculate means for each group and time point using dynamic variable and only non outlier values
  mean_data_comp <- filtered_data %>%
    filter(outlier == FALSE | is.na(outlier)) %>% 
    group_by(group, time) %>%
    summarise(mean_value = mean(!!sym(unit), na.rm = TRUE),
              .groups = 'drop')
  
  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post \np = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "   |   BH p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3),
    "\n----- WITHOUT OUTLIERS -----",
    "\n p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 2:4]), format = "f", digits = 3),
    "   |   BH p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 8:10]), format = "f", digits = 3)
  )
  
  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3),
    "\n----- WITHOUT OUTLIERS -----\n",
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 13]), format = "f", digits = 3)
  )
  
  # Dynamic y-axis label depending on the unit
  
  if("Cer ratio" %in% filtered_data$lipidClass){
    y_label_text <- "Cer 16:0 to 24:0 ratio" }
  else{
    y_label_text <- switch(unit,
                           pmol_mg = expression("Lipid concentration" ~ "(pmol ·" ~ mg^-1 * ")"),
                           pmol_mg_log = expression("Log transformed lipid concentration"),
                           "No label"  # Default case if none of the above
    )}
  
  # Make the plot
  plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
               levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = !!sym(unit), group = interaction(id, group)
  )) +
    geom_line(aes(group = interaction(id, group), color = id), position = position_nudge(x = 0.00)) +
    
    geom_point(aes(color = id), alpha = 0.5, position = position_nudge(x = 0.0)) +
    geom_boxplot(aes(group = interaction(group, time)), color = "black",
                 width = 0.3, alpha = 0.2, outlier.shape = NA,
                 position = position_dodge(width = 0.75)
    ) +
    # Up triangle for values above ULOQ
    geom_point(
      data = subset(filtered_data, within_threshold == 2), aes(y = !!sym(unit), color = id), size = 3, shape = 24,
      alpha = 1, position = position_nudge(x = 0.00), show.legend = FALSE 
    ) +
    # Down triangle for values below LLOQ
    geom_point(
      data = subset(filtered_data, within_threshold == 1), aes(y = !!sym(unit)),color = "darkgrey", size = 3, shape = 25,
      alpha = 1, position = position_nudge(x = 0.00), show.legend = FALSE 
    ) +
    
    # Cross to signal outlier
    geom_point(
      data = subset(filtered_data, outlier == TRUE), aes(y = !!sym(unit)), color = "black", size = 4, shape = 4,
      alpha = 0.5, position = position_nudge(x = 0.00), show.legend = FALSE 
    ) +
    
    geom_line(data = mean_data_comp, aes(x = interaction(group, time, sep = " "), y = mean_value, group = group), color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
    
    # scale_color_manual(values = c("M" = "blue", "F" = "red"), name = "Gender") +
    labs(
      title = paste(lipid_class, lipid_composition),
      subtitle = annotation_pvals_slope,
      y = y_label_text,
      x = ""
    ) +
    
    # Insert P-values pre post
    annotate("text",
             x = c(1.5, 3.5, 5.5), y = max(filtered_data[[unit]]) * 1.02,
             label = annotation_pvals_pre_post, size = 1.75
    ) +
    theme_minimal() +
    theme(
      axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
      legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
      legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), ,
      plot.subtitle = element_text(size = 5, hjust = 0.5)
    )
  
  
  # Define the filename and save the plot
  filename <- paste0(
    getwd(), "/outputs/pre_post/scatter composition/", save_subfolder,"/",
    gsub("/", "_", gsub(":", ",", paste(lipid_class, lipid_composition, sep = " "))), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)
  
  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each combination of lipid_class and lipid_composition
unique_lipid_classes <- unique(lipidomicsDF$lipidClass[!lipidomicsDF$lipidClass == "PC.PE"])

for (lipid_class in unique_lipid_classes) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    plot_lipid(lipidomicsDF = lipidomicsDF,
               lipid_composition = lipid_composition,
               lipid_class = lipid_class,
               detection_limits = detection_limits,
               p_val_df = est_and_p_lipid_comp$p.vals,
               p_val_df_outlierRM = est_and_p_lipid_comp.outlierRM$p.vals,
               unit = "pmol_mg",
               save_subfolder = "")
    
    
    # Log tranformed   
    #   plot_lipid(lipidomicsDF,
    #              lipid_composition,
    #              lipid_class, detection_limits,
    #              est_and_p_lipid_class_and_comp$p.vals,
    #              unit = "pmol_mg_log",
    #              save_subfolder = "log_transformed")
  }
}


```

### Lipid class

Scatter plot for each lipid class based on absolute lipid class concentration

```{r}
plot_lipid_class <- function(lipidomicsDF, lipid_class, detection_limits, p_val_df, p_val_df.outlierRM, unit, save_subfolder) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))
  
  
  # MAKE SUM FOR EACH ID
  pmol_mg_class_sum <- filtered_data %>%
    group_by(lipidClass, group, id, time) %>%
    summarize(
      sum_pmol_mg = sum(pmol_mg_imp, na.rm = TRUE),
      sum_log_transformed = log(sum_pmol_mg + 1), #Add one to avoid 0 failure during transform
      .groups = "drop"  # Drop the grouping
    )
  
  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]
  pvalues_to_annotate.outlierRM <- p_val_df.outlierRM[p_val_df.outlierRM[, 1] == search_key, ]
  
  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post \np = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "   |   BH p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3),
    "\n----- WITHOUT OUTLIERS -----\n",
    "p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 2:4]), format = "f", digits = 3),
    "   |   BH p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 8:10]), format = "f", digits = 3)
  )
  
  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3),
    "\n----- WITHOUT OUTLIERS -----\n",
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
  mean_data_class <- pmol_mg_class_sum %>%
    group_by(group, time) %>%
    summarise(mean_class = mean(!!sym(unit), na.rm = TRUE), .groups = 'drop')
  
  # Dynamic Y-labels
  if("PC.PE" %in% filtered_data$lipidClass) {
    y_label <- "PE/PC ratio"
  }
  else {
    y_label <- switch(unit,
                      sum_pmol_mg = expression("Lipid concentration" ~ "(pmol ·" ~ mg^-1 * ")"),
                      sum_log_transformed = expression("Log transformed concentration"),
                      "Default Label"  # This is a fallback if neither of the above cases are true
    )
  }
  
  # Set label height
  label_height <- max(pmol_mg_class_sum[[unit]])*1
  
  # Create the plot
  plot <- ggplot(pmol_mg_class_sum, aes(
    x = factor(interaction(group, time, sep = " "),
               levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = !!sym(unit), group = interaction(id, group)
  )) +
    geom_line(aes(group = interaction(id, group), color = id), alpha = 0.9, linewidth = 0.1, position = position_nudge(x = 0.03)) +
    geom_point(aes(color = id), alpha = 0.5, position = position_nudge(x = 0.03)) +
    
    geom_boxplot(aes(group = interaction(group, time)),
                 width = 0.3, alpha = 0.2, outlier.shape = NA,
                 position = position_dodge(width = 0.75), color = "black"
    ) +
    geom_line(data = mean_data_class, aes(x = interaction(group, time, sep = " "), y = mean_class, group = group),color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
    scale_color_manual(values = rainbow(length(unique(filtered_data$id)))) +
    labs(title = lipid_class, 
         subtitle = annotation_pvals_slope, 
         y = y_label,
         x = "") +
    annotate("text", x = c(1.5, 3.5, 5.5), y = label_height, label = annotation_pvals_pre_post, size = 1.75) +
    theme_minimal() +
    theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
          legend.title = element_text(hjust = 0.5, size = 6), legend.text = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),plot.title = element_text(hjust = 0.5), 
          #legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
          plot.subtitle = element_text(size = 5, hjust = 0.5))
  
  
  # Define the filename and save the plot
  filename <- paste0(
    getwd() ,"/outputs/pre_post/scatter class/", save_subfolder, "/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)
  
  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each lipid class
unique_lipid_classes <- unique(lipidomicsDF$lipidClass[!lipidomicsDF$lipidClass == "Cer ratio"])

# ONLY TEMP WITH NO OUTLIER P-VALS
est_and_p_pvals_lipid_class <- est_and_p_pvals_lipid_class.outlierRM

for (lipid_class in  unique_lipid_classes) {
  plot_lipid_class(lipidomicsDF = lipidomicsDF,
                   lipid_class = lipid_class,
                   detection_limits = detection_limits,
                   p_val_df = est_and_p_pvals_lipid_class$p.vals,
                   p_val_df.outlierRM = est_and_p_pvals_lipid_class.outlierRM$p.vals,
                   unit = "sum_pmol_mg",
                   save_subfolder = "")
  
  
  
  
  # plot_lipid_class(lipidomicsDF = lipidomicsDF,
  #                  lipid_class = lipid_class,
  #                  detection_limits = detection_limits,
  #                  p_val_df = est_and_p_lipid_class_and_comp$p.vals,
  #                  unit = "sum_log_transformed",
  #                  save_subfolder = "log_transformed")   
  
}
```

### Z-score lipidClass

Scatter plots of Z-score for each lipid class with lipid classes shown in different colors

```{r}
plot_lipid_class_z_score <- function(lipidomicsDF, lipid_class, detection_limits, p_val_df) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))
  
  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]
  
  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )
  
  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
  mean_data_class_zscore <- filtered_data %>%
    group_by(group, time) %>%
    summarise(mean_pmol_mg_znorm = mean(pmol_mg_znorm, na.rm = TRUE), .groups = 'drop')
  
  # Create the plot
  plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
               levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = pmol_mg_znorm, group = interaction(id, group)
  )) +
    geom_line(aes(group = interaction(id, group, lipidComposition), color = lipidComposition), alpha = 0.9, size = 0.1, position = position_nudge(x = 0.03)) +
    geom_point(aes(color = lipidComposition), alpha = 0.5, position = position_nudge(x = 0.03)) +
    geom_line(data = mean_data_class_zscore, aes(x = interaction(group, time, sep = " "), y = mean_pmol_mg_znorm, group = group),color = "black", size = 1, position = position_nudge(x = 0.03)) +
    scale_color_manual(values = rainbow(length(unique(filtered_data$lipidComposition)))) +
    labs(title = lipid_class, subtitle = annotation_pvals_slope, y = "Lipid concentration, Z norm [comp within group]", x = "") +
    annotate("text", x = c(1.5, 3.5, 5.5), y = 3.0, label = annotation_pvals_pre_post, size = 2) +
    theme_minimal() +
    theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
          legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
          legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
          plot.subtitle = element_text(size = 5, hjust = 0.5))
  
  
  # Filter the LLOQ and ULOQ for the current lipid_class and set y-axis limits
  y_min <- min(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 0.95 # Adjusted
  y_max <- max(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 1.05 # Adjusted
  plot <- plot + coord_cartesian(ylim = c(y_min, y_max))
  
  # Define the filename and save the plot
  filename <- paste0(
    getwd(), "/outputs/pre_post/plot, scatter class, z_score/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)
  
  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each lipid class
for (lipid_class in unique_lipid_classes) {
  plot_lipid_class_z_score(lipidomicsDF, lipid_class, detection_limits, est_and_p_pvals_lipid_class$p.vals)
}
```

## Heatmap & volcano plot

### Prepare data

```{r}
# When class and composition is analysed together, merge p-values and correlations
pvals_df <- rbind(est_and_p_pvals_lipid_class.outlierRM$p.vals, est_and_p_lipid_comp.outlierRM$p.vals)
estimates_df <- rbind(est_and_p_pvals_lipid_class.outlierRM$estimates, est_and_p_lipid_comp.outlierRM$estimates)

# Select the specified columns for hm_data.p-vals matrix
pvals_df <- pvals_df[ , c("lipid", "Pre HED - Post HED (corrected)", "Pre DIWL - Post DIWL (corrected)", 
                          "Pre WLEX - Post WLEX (corrected)", "Pre - Post : HED - DIWL (corrected)",
                          "Pre - Post : HED - WLEX (corrected)", "Pre - Post : DIWL - WLEX (corrected)")]


### Calculate log2 change
# Composition
log2fold_ch_comp <- lipidomicsDF %>%
  filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidClass, lipidComposition, group) %>%
  summarize(
    log2fCh = log2(mean(pmol_mg[time == "Post"], na.rm = TRUE) / 
                     mean(pmol_mg[time == "Pre"], na.rm = TRUE)),
    .groups = "drop"
  )

# Class
log2fold_ch_class <- lipidomicsDF %>%
  group_by(lipidClass, group) %>%
  summarize(
    log2fCh = log2(mean(pmol_mg_imp[time == "Post"], na.rm = TRUE) / 
                     mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE)),
    .groups = "drop"
  )

# Make names to match lipid
# Composition
log2fold_ch_comp <- log2fold_ch_comp %>%
  mutate(lipid = paste(lipidClass, lipidComposition, sep = "_")) %>%
  select(-lipidComposition, -lipidClass)

# Class
log2fold_ch_class <- log2fold_ch_class %>%
  rename(lipid = lipidClass)

# Combine lipid composition and lipid class data
log2fold_ch <- rbind(log2fold_ch_class, log2fold_ch_comp)

# Rename col names to match the ones on the DF
log2fold_ch <- log2fold_ch %>%
  mutate(group = case_when(
    group == "HED"  ~ "Pre HED - Post HED",
    group == "DIWL" ~ "Pre DIWL - Post DIWL",
    group == "WLEX" ~ "Pre WLEX - Post WLEX",
    TRUE ~ group  # Keeps the original value if none of the above conditions are met
  ))

### Replace the model change values with the log2change
# Reshape estimates_df from wide to long format to make replacement
estimates_long <- estimates_df %>%
  pivot_longer(
    cols = c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX"),
    names_to = "group",
    values_to = "value"
  )
# perform replacement based on lipid and group
estimates_long_log2ch <- estimates_long %>%
  left_join(log2fold_ch, by = c("lipid", "group")) %>%
  mutate(value = if_else(!is.na(log2fCh), log2fCh, value)) %>%
  select(-log2fCh)

# pivot back to wide format
estimates_df_log2ch <- estimates_long_log2ch %>%
  pivot_wider(
    names_from = group,
    values_from = value
  )

### Slope: Relative changes
# Calculate the mean at time Pre for every lipidComposition within lipidClass and for lipidClass across all groups to use for normalization
lipidomicsDF <- lipidomicsDF %>%
  # Class only
  group_by(lipidClass) %>%
  mutate(pmol_mg_pre_mean_class = ifelse(time == "Pre", mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE), NA)) %>%
  ungroup() %>% 
  # Add the mean for composition
  filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidComposition, lipidClass) %>%
  mutate(pmol_mg_pre_mean_comp = ifelse(time == "Pre", mean(pmol_mg[time == "Pre"], na.rm = TRUE), NA)) %>%
  ungroup()


# Calculate absolute pre-post changes
# Composition
slope_norm_ch_comp <- lipidomicsDF %>%
  filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidClass, lipidComposition, group) %>%
  summarize(
    norm_ch = (mean(pmol_mg[time == "Post"], na.rm = TRUE) - 
                 mean(pmol_mg[time == "Pre"], na.rm = TRUE)) /
      mean(pmol_mg_pre_mean_comp[time == "Pre"], na.rm = TRUE),
    .groups = "drop"
  )

# Class
slope_norm_ch_class <- lipidomicsDF %>%
  group_by(lipidClass, group) %>%
  summarize(
    norm_ch = (mean(pmol_mg_imp[time == "Post"], na.rm = TRUE) - 
                 mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE)) / 
      mean(pmol_mg_pre_mean_class[time == "Pre"], na.rm = TRUE),
    .groups = "drop"
  )


# Make single lipid name for later matching
# Composition
slope_norm_ch_comp <- slope_norm_ch_comp %>%
  mutate(lipid = paste(lipidClass, lipidComposition, sep = "_")) %>%
  select(-lipidComposition, -lipidClass)

# Class
slope_norm_ch_class <- slope_norm_ch_class %>%
  rename(lipid = lipidClass)

# Combine lipid composition and lipid class data
slope_norm_ch <- rbind(slope_norm_ch_class, slope_norm_ch_comp)

# Spread the data for each group to be a separate column
slope_norm_ch_wide <- slope_norm_ch %>%
  pivot_wider(names_from = group, values_from = norm_ch)

# Calculate the difference between slope changes and make pct.
# This makes the values differences in "percentage points"
slope_ch_pp <- slope_norm_ch_wide %>%
  mutate(`Pre - Post : HED - WLEX` = (WLEX - HED)*100,
         `Pre - Post : HED - DIWL` = (DIWL - HED)*100,
         `Pre - Post : DIWL - WLEX` = (WLEX - DIWL)*100)

# Remove the cols with differences between pre and post
slope_ch_pp <- slope_ch_pp %>%
  select(-WLEX, -HED, -DIWL)

# Replace slope values in the estimates data frame
# Join the dataframes based on 'lipid' to align rows
joined_df <- estimates_df_log2ch %>%
  left_join(slope_ch_pp, by = "lipid", suffix = c("", ".normch"))

# Replace values in the original columns with values from the joined columns
estimates_df_plotData <- joined_df %>%
  mutate(`Pre - Post : HED - DIWL` = `Pre - Post : HED - DIWL.normch`,
         `Pre - Post : HED - WLEX` = `Pre - Post : HED - WLEX.normch`,
         `Pre - Post : DIWL - WLEX` = `Pre - Post : DIWL - WLEX.normch`) %>%
  select(-ends_with(".normch"))


# Convert tibble to dataframe for later naming
estimates_df_plotData <- as.data.frame(estimates_df_plotData)
```

### volcano
```{r}
# Turn into two dataframes:
# First: Slope, test_against
# Selecting the relevant columns for transformation
estimates_df_slope <- estimates_df_plotData %>%
  select(lipid, `Pre - Post : HED - DIWL`, `Pre - Post : HED - WLEX`, `Pre - Post : DIWL - WLEX`)

# Transforming into long format
vulc_slope <- estimates_df_slope %>%
  pivot_longer(
    cols = -lipid, # Exclude the 'lipid' column from the reshaping process
    names_to = "test_against", # New column for the original column names
    values_to = "ch_pp" # New column for the values from the reshaped columns
  )

# Second: Pre/post, test_against, p_value
# Selecting the relevant columns for transformation
estimates_df_prePost <- estimates_df_plotData %>%
  select(lipid, `Pre HED - Post HED`, `Pre DIWL - Post DIWL`, `Pre WLEX - Post WLEX`)

# Transforming into long format
vulc_prePost <- estimates_df_prePost %>%
  pivot_longer(
    cols = -lipid, # Exclude the 'lipid' column from the reshaping process
    names_to = "test_against", # New column for the original column names
    values_to = "log2foldch" # New column for the values from the reshaped columns
  )

## Add p-values
# Adjust the names in pvals_df to match those in vulc_slope and vulc_prePost
# First copy pvals_df to not alter
pvals_df_mod <- pvals_df
# then change names
names(pvals_df_mod) <- sub(" \\(corrected\\)", "", names(pvals_df))

# Transform pvals_df into long format
pvals_long <- pvals_df_mod %>%
  pivot_longer(
    cols = -lipid, # Exclude 'lipid'
    names_to = "test_against", # New column for the original column names
    values_to = "p_value" # New column for the p-values
  )

# Join p-values to the dataframes to plot
# Joining p-values to vulc_prePost
vulc_prePost <- left_join(vulc_prePost, pvals_long, by = c("lipid", "test_against"))

# Joining p-values to vulc_slope
vulc_slope <- left_join(vulc_slope, pvals_long, by = c("lipid", "test_against"))

### Make identifier columns based on lipid name and test_against 
# Adding 'identifier' column to vulc_prePost
vulc_prePost <- vulc_prePost %>%
  mutate(identifier = paste(lipid, test_against, sep = " ~ "))

# Adding 'identifier' column to vulc_slope
vulc_slope <- vulc_slope %>%
  mutate(identifier = paste(lipid, test_against, sep = " ~ "))
```

#### Slope

```{r}
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_slope$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)


### Create plot
vulc_plot <- ggplot(vulc_slope, aes(x = ch_pp, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", size = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) + # TRUE for significant, FALSE for not; 1 not translucent; 0.12 very translucent
  geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(ch_pp) > threshold_rho, lipid, "")),
                  box.padding = 0.35, point.padding = 0.5,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  labs(title = "Differences in pre-to-post slopes between groups", x = "Delta slope (pp)", y = "-log10 P-value") +
  xlim(-200,200)+
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) # Hide the alpha legend and fix the color legend

## Display the plot
print(vulc_plot)

# Save the plot
ggsave( paste0(getwd(), "/outputs/pre_post/volcano/slope_volcano.jpg"), plot = vulc_plot, width = 8, height = 10, dpi = 400)
```

#### Pre-post

```{r}
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_prePost$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)


### Create plot
vulc_plot <- ggplot(vulc_prePost, aes(x = log2foldch, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", size = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) + # TRUE for significant, FALSE for not; 1 not translucent; 0.12 very translucent
  geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(log2foldch) > threshold_rho, lipid, "")),
                  box.padding = 0.35, point.padding = 0.5,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  labs(title = "Differences in pre-to-post", x = "log2fc", y = "-log10 P-value") +
  xlim(-2.5,2.5) +
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) # Hide the alpha legend and fix the color legend

## Display the plot
print(vulc_plot)

# Save the plot
ggsave( paste0( getwd(), "/outputs/pre_post/volcano/prePost_volcano.jpg"), plot = vulc_plot, width = 8, height = 10, dpi = 300)
```

### Heatmap

```{r}
# Set 'lipid' as row names
pvals_df_heatMap <- data.frame(pvals_df, check.names = FALSE)
estimates_df_heatMap <- estimates_df_plotData

rownames(pvals_df_heatMap) <- pvals_df_heatMap$lipid
rownames(estimates_df_heatMap) <- estimates_df_heatMap$lipid

# Remove the 'lipid' column
pvals_df_heatMap <- pvals_df_heatMap[ , !(names(pvals_df_heatMap) %in% c("lipid"))]
estimates_df_heatMap <- estimates_df_heatMap[ , !(names(estimates_df_heatMap) %in% c("lipid"))]

# Rename columns by removing " (corrected)" from all column names in pvals_df_heatMap
colnames(pvals_df_heatMap) <- gsub(" \\(corrected\\)", "", colnames(pvals_df_heatMap))

# Sort column names
common_cols <- intersect(colnames(estimates_df_heatMap), colnames(pvals_df_heatMap))
estimates_df_heatMap <- estimates_df_heatMap[, common_cols, drop = FALSE]
pvals_df_heatMap <- pvals_df_heatMap[, common_cols, drop = FALSE]

### Devide dataframe based on lipid groups
# Define lipid groups
lipids_groups <- list(
  gr_tag = c("TAG"),  # Triacylglycerols
  gr_dg_ac = c("1,2-DG", "1,3-DG", "AC"),  # Diglycerides and Acyl carnitines
  gr_pc = c("PC", "PC.PE"),  # Phosphatidylcholines and ratio
  gr_pe = c("PE"),  # Phosphatidylethanolamines
  gr_sphingolipids = c("SPM", "SPH", "Cer", "Cer ratio", "dhCer", "GluCer", "LacCer", "GalCer"),  # Sphingolipids: Sphingomyelins, Sphingosines, Ceramides and derivatives
  gr_lyso = c("LPC", "LPE", "LPG", "LPI", "LPS"),  # Lysophospholipids
  gr_pa_ps = c("PA", "PS"),  # Group combining Phosphatidic acids and Phosphatidylserines
  gr_pg_pi = c("PG", "PI")  # Group combining Phosphatidylglycerols and Phosphatidylinositols
)

### Divide dataframe based on lipid groups with lipid as row name
filter_lipid_group_row <- function(data_frame, lipid_group) {
  
  # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  
  # Convert row names to a temporary column for sorting and filtering
  data_frame_with_lipid <- tibble::rownames_to_column(data_frame, var = "lipid")
  
  # Sort the dataframe by the temporary lipid column
  sorted_data_frame_with_lipid <- data_frame_with_lipid[order(data_frame_with_lipid$lipid), ]
  
  # Filter based on the pattern
  sorted_filtered_data_frame_with_lipid <- sorted_data_frame_with_lipid[grepl(pattern, sorted_data_frame_with_lipid$lipid), ]
  
  # Drop the temporary lipid column and return to original format
  rownames(sorted_filtered_data_frame_with_lipid) <- sorted_filtered_data_frame_with_lipid$lipid
  sorted_filtered_data_frame <- sorted_filtered_data_frame_with_lipid[ , !colnames(sorted_filtered_data_frame_with_lipid) %in% 'lipid', drop = FALSE]
  return(sorted_filtered_data_frame)
}


# Apply the filter function to each group and store the results in a lists
# p-values
pvals_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = pvals_df_heatMap)

# estimates
estimates_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = estimates_df_heatMap)

# Convert all dataframes to matrices
matrices_pvals <- lapply(pvals_gr_list, function(x) as.matrix(x))
matrices_estimates <- lapply(estimates_gr_list, function(x) as.matrix(x))


generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims, hm_title, hm_unit) {
  # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
  # Extract test_against by removing the first part (treatment group) and the first underscore
  # This joins back the remaining parts to form the full 'test_against' label
  colTitles <- c("Slope", "Pre vs Post")
  
  Heatmap(hm_matrix,
          name = hm_unit, # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 7.5 ), # Change font size of row labels
          
          #column_split = rep(1:(ncol(hm_matrix) / 3), each = 3), # Splits the columns and names them
          column_title = hm_title,
          column_names_rot = 45, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 8, fontface = "bold"),
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 10, fontface = "bold"),
          #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
          
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
            if (!is.na(p_val_matrix[i, j])) {
              if (p_val_matrix[i, j] < pLims$p1) {
                grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
              } else if (p_val_matrix[i, j] < pLims$p2) {
                grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
              } else if (p_val_matrix[i, j] < pLims$p3) {
                grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
              }
            }
          })
}

# Define color map for heatmap
color_mapping_slope <- colorRamp2(c(-300, 0, 300), c("blue", "white", "red"))
color_mapping_pre_post <- colorRamp2(c(-3, 0, 3), c("darkgreen", "white", "orange"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
hm <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)) {
  # Generate slope and pre/post hm
  
  hm_slope <- generate_heatmap(matrices_estimates[[i]][,1:3],
                               matrices_pvals[[i]][,1:3],
                               color_mapping_slope,
                               p_value_limits,
                               hm_title = "Slope ", 
                               hm_unit = "pp")
  
  hm_pre_post <- generate_heatmap(matrices_estimates[[i]][,4:6],
                                  matrices_pvals[[i]][,4:6],
                                  color_mapping_pre_post,
                                  p_value_limits,
                                  hm_title = "Pre vs Post",
                                  hm_unit = "log2foldch")
  
  # Combine heat maps and store in list
  hm[[i]] <- hm_slope + hm_pre_post
  # Generate heatmap and store it in the list
}

# Define the path and name of your PDF file
pdf_path <- paste0( getwd(), "/outputs/pre_post/heatmap/heatmap.pdf")

# Open a PDF device
pdf(pdf_path, width = 8, height = 10)

# Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
for (i in 1:length (hm)){
  draw(hm[[i]])
}

# Don't forget to close the device
dev.off()

```

## p-value plots

Make plots of p-values sorted highest to lowest for lipid classes and lipid compositions within each lipid class

```{r}
generate_barplot <- function(data, col_index_non_corrected, col_index_corrected, output_base_path, data_name) {
  # Extract test names based on indices
  test_name_non_corrected <- names(data)[col_index_non_corrected]
  test_name_corrected <- names(data)[col_index_corrected]
  
  # Use output_base_path directly, no sub-folders created
  output_path <- output_base_path
  
  # Prepare and sort data for plotting
  data$lipid <- factor(data$lipid, levels = unique(data$lipid))
  
  # Define common sizes for axis titles and plot title
  axis_title_size <- 13
  plot_title_size <- 10
  
  # Dynamic adjustment of the label size based on the number of bars (lipids)
  num_bars <- length(unique(data$lipid))
  label_size <- max(2, min(11, 50 / sqrt(num_bars))) # Adjusted dynamically
  
  # Generate plot for non-corrected p-values
  p1 <- ggplot(data, aes(x = reorder(lipid, .data[[test_name_non_corrected]]), y = .data[[test_name_non_corrected]])) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
    labs(y = "P-value", x = "lipid", title = test_name_non_corrected) +
    theme_minimal() +
    theme(
      axis.title.y = element_text(size = axis_title_size, face = "bold"),
      axis.title.x = element_text(size = axis_title_size, face = "bold"),
      plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = label_size)
    )
  
  # Generate plot for corrected p-values
  p2 <- ggplot(data, aes(x = reorder(lipid, .data[[test_name_corrected]]), y = .data[[test_name_corrected]])) +
    geom_bar(stat = "identity", fill = "darkgreen") +
    coord_flip() +
    geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
    labs(y = "Corrected P-value", x = "lipid", title = test_name_corrected) +
    theme_minimal() +
    theme(
      axis.title.y = element_text(size = axis_title_size, face = "bold"),
      axis.title.x = element_text(size = axis_title_size, face = "bold"),
      plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = label_size)
    )
  
  # Combine the two plots
  subplot <- p1 + p2
  
  # Construct the plot filename
  plot_filename <- paste0(data_name, " ", gsub("[ :()]", " ", test_name_non_corrected), ".jpeg")
  
  # Save the subplot
  ggsave(file.path(output_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
}

# Define output path
output_base_path <- paste0( getwd(), "/outputs/pre_post/plot, p-value sorted pre-post")

# Column indices to plot against one another; non-corrected vs corrected p-values
cols_to_plot <- matrix(c(2, 8, 3, 9, 4, 10, 5, 11, 6, 12, 7, 13), ncol = 2, byrow = TRUE)

# Loop through each pair of columns and generate the plots
# Lipid class
dataframe_name <- "lipid class"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_pvals_lipid_class$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/class"), dataframe_name)
}

# Lipid class and composition
dataframe_name_comp <- "lipid comp"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_lipid_comp$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/composition"), dataframe_name_comp)
}

# Lipid class and composition
dataframe_name_comp_and_class <- "lipid class and comp"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_lipid_class_and_comp$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/comp_and_class"), dataframe_name_comp)
}

```

# Quality control

### Outlier identification plots

#### Everything grouped within lipid comp and class

```{r}

for (i in 1:nrow(unique_combinations)) {
  class <- unique_combinations$lipidClass[i]
  comp <- unique_combinations$lipidComposition[i]
  
  # Filter data based on lipid class and composition
  subset_lipidomicsDF <- lipidomicsDF[lipidomicsDF$lipidClass == class & lipidomicsDF$lipidComposition == comp,]
  
  # Compute log transformation for plotting
  subset_lipidomicsDF$pmol_mg_log <- log10(subset_lipidomicsDF$pmol_mg + 1)
  
  # Plot for pmol_mg as a boxplot
  plot_mg_box <- ggplot(data = subset_lipidomicsDF, aes(x = factor(1), y = pmol_mg)) +
    geom_boxplot(outlier.shape = 4, outlier.size = 5, coef = outlier_IQR_factor) +
    geom_point(aes(color = id), position = position_jitter(width = 0.1), alpha = 0.6) +
    geom_point(data = subset(subset_lipidomicsDF, outlier == TRUE), aes(y = pmol_mg), shape = 4, color = "red", size = 5) +
    labs(y = "pmol_mg") +
    theme(axis.title.y = element_text(face = "bold", size = 14), axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
  # Plot for pmol_mg_log as a boxplot
  plot_mg_log_box <- ggplot(data = subset_lipidomicsDF, aes(x = factor(1), y = pmol_mg_log)) +
    geom_boxplot(outlier.shape = 4, outlier.size = 5, coef = outlier_IQR_factor) +
    geom_point(data = subset(subset_lipidomicsDF, outlier_log == TRUE), aes(y = pmol_mg), shape = 4, color = "red", size = 5) +
    geom_point(aes(color = id), position = position_jitter(width = 0.1), alpha = 0.6) +
    labs(y = "pmol_mg_log") +
    theme(axis.title.y = element_text(face = "bold", size = 14), axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
  # Histogram for pmol_mg
  plot_mg_hist <- ggplot(data = subset_lipidomicsDF, aes(x = pmol_mg)) +
    geom_histogram(bins = 8, fill = 'skyblue', color = 'black') +
    labs(x = "pmol_mg", y = "Count") +
    theme_minimal()
  
  # Histogram for pmol_mg_log
  plot_mg_log_hist <- ggplot(data = subset_lipidomicsDF, aes(x = pmol_mg_log)) +
    geom_histogram(bins = 8, fill = 'skyblue', color = 'black') +
    labs(x = "Log Transformed pmol_mg", y = "Count") +
    theme_minimal()
  
  combined_plot <- (plot_mg_box | plot_mg_hist) /
    (plot_mg_log_box | plot_mg_log_hist) +
    plot_layout(guides = 'collect', widths = c(1, 1), heights = c(1, 1)) +
    plot_annotation(title = paste(class, comp), 
                    theme = theme(plot.title = element_text(hjust = 0.5, size = 20, face = "bold")))
  
  
  # Create output directory if it doesn't exist
  sanitized_class_comp <- gsub("/", "_", gsub(":", ",", paste(class, comp)))
  output_dir <- paste0(getwd(), "/outputs/", "QC/", "outliers/", "absolute within comp and class/")
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  }
  
  # Define filename and save the combined plot with sanitized filename
  filename <- paste0(output_dir, sanitized_class_comp, ".png")
  ggsave(filename, plot = combined_plot, width = 12, height = 12, dpi = 300)
  
  cat("Plot saved as:", filename, "\n")
}

```

#### Based on change between pre and post

```{r}
calculate_differences <- function(df) {
  # Assuming there is an 'id' column to uniquely identify rows that should be paired
  pre <- df %>% filter(time == "Pre")
  post <- df %>% filter(time == "Post")
  
  # Join pre and post data to calculate differences
  combined <- left_join(pre, post, by = "id", suffix = c(".pre", ".post"))
  
  # Calculate differences for raw and log-transformed data
  combined$difference <- abs(combined$pmol_mg.post - combined$pmol_mg.pre)
  combined$difference_log <- abs(log(combined$pmol_mg.post + 1) -  log(combined$pmol_mg.pre + 1))
  
  return(combined)
}

plot_differences <- function(df, class, comp, log_transform) {
  
  y_var <- if(log_transform) "difference_log" else "difference"
  y_lab <- if(log_transform) "Difference of log transformed values" else "pmol_mg (Post - Pre)"
  
  # Create a boxplot
  plot_box <- ggplot(df, aes(x = factor(1), y = !!sym(y_var))) +
    geom_boxplot(outlier.shape = 4, outlier.size = 5, coef = outlier_IQR_factor) +
    geom_point(aes(color = id), position = position_jitter(width = 0.1), alpha = 0.6) +
    labs( y = y_lab) +
    theme_minimal() +
    theme(axis.title.y = element_text(face = "bold", size = 14),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          plot.title = element_text(hjust = 0.5))
  
  # Create a histogram
  plot_hist <- ggplot(df, aes(x = !!sym(y_var))) +
    geom_histogram(bins = 8, fill = 'skyblue', color = 'black') +
    labs(x = y_lab, y = "Count") +
    theme_minimal()
  
  return(list(box = plot_box, hist = plot_hist))
}


for (i in 1:nrow(unique_combinations)) {
  class <- unique_combinations$lipidClass[i]
  comp <- unique_combinations$lipidComposition[i]
  
  print(paste0(class, " ", comp))
  # Filter data based on lipid class and composition, for both Pre and Post
  subset_lipidomicsDF <- lipidomicsDF[lipidomicsDF$lipidClass == class & lipidomicsDF$lipidComposition == comp,]
  
  # Calculate differences
  differences_df <- calculate_differences(subset_lipidomicsDF)
  
  # Get plots without and with log transformation
  plots_raw <- plot_differences(differences_df, class, comp, log_transform = FALSE)
  plots_log <- plot_differences(differences_df, class, comp, log_transform = TRUE)
  
  # Combine plots into a 2x2 grid
  combined_plot <- (plots_raw$box | plots_raw$hist) / (plots_log$box | plots_log$hist) +
    plot_layout(guides = 'collect') +
    plot_annotation(title = paste("Changes, ", class, comp), 
                    theme = theme(plot.title = element_text(hjust = 0.5, size = 20, face = "bold")))
  
  # Define filename using sanitized strings and updated save path
  sanitized_class_comp <- gsub("/", "_", gsub(":", ",", paste(class, comp)))
  output_dir <- paste0(getwd(), "/outputs/QC/outliers/changes within comp and class/")
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  }
  filename <- paste0(output_dir, sanitized_class_comp, ".png")
  
  # Save the combined plot with sanitized filename
  ggsave(filename, plot = combined_plot, width = 12, height = 12, dpi = 300)
  
  cat("Plot saved as:", filename, "\n")
}

```

#### QQ plots

```{r}
# Define output directory and ensure it exists
output_dir <- file.path(getwd(), "outputs", "QC", "qq")
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Iterate over each unique combination of lipidClass and lipidComposition
for (i in 1:nrow(unique_combinations)) {  
  # is this needed? [unique_combinations$lipidClass != c("Cer ratio", "PC.PE")
  class <- unique_combinations$lipidClass[i]
  comp <- unique_combinations$lipidComposition[i]
  
  print( paste0("Analysing ",class, " ", comp))
  
  # class <- "PC.PE"
  # comp <- "ratio"
  
  # Initialize the plotting layout before saving the plots
  png(file.path(output_dir, paste0(gsub("[/:]", "_", paste(class, comp)), ".png")), width = 1200, height = 800)
  par(mfrow = c(6, 2))
  
  # Iterate over groups and times
  for (group in c("HED", "DIWL", "WLEX")){
    for (time in c("Pre", "Post")){
      
      print(group); print(time)
      
      # Load data subset
      class_comp <- lipidomicsDF[
        lipidomicsDF$lipidClass == class &
          lipidomicsDF$lipidComposition == comp &
          lipidomicsDF$time == time &
          lipidomicsDF$group == group &
          (lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier))
        ,]
      
      ## Non-transformed Data QQ Plots
      if (length(class_comp$pmol_mg) >= 3 && length(unique(class_comp$pmol_mg)) > 1)  {
        shapiro_result_nonTransformed <- shapiro.test(class_comp$pmol_mg)
        shapiro_p_value_nonTransformed <- sprintf("%.4f", shapiro_result_nonTransformed$p.value)
      } else {
        shapiro_p_value_nonTransformed <- "NA"
      }
      
      # Q-Q plot for non-transformed data
      qqnorm(class_comp$pmol_mg, main = paste0(group, " ", time, " Non-Transformed"))
      qqline(class_comp$pmol_mg, col = "red")
      mtext(sprintf("Shapiro-Wilk p=%s", shapiro_p_value_nonTransformed), side = 3, adj = 0.05, line = 2, cex = 0.8)
      
      ## Log-transformed Data QQ Plots
      if (
        length(class_comp$pmol_mg_log) >= 3 && 
        length(unique(class_comp$pmol_mg_log)) > 1 &&
        !is.na(class_comp$pmol_mg_log[1])) {
        shapiro_result_logTransformed <- shapiro.test(class_comp$pmol_mg_log)
        shapiro_p_value_logTransformed <- sprintf("%.4f", shapiro_result_logTransformed$p.value)
      } else {
        shapiro_p_value_logTransformed <- "NA"
      }
      
      if (
        length(class_comp$pmol_mg_log) >= 3 && 
        !is.na(class_comp$pmol_mg_log[1]))
      {
        qqnorm(class_comp$pmol_mg_log, main = paste0(group, " ", time, " Log-Transformed"))
        qqline(class_comp$pmol_mg_log, col = "red")
        mtext(sprintf("Shapiro-Wilk p=%s", shapiro_p_value_logTransformed), side = 3, adj = 0.05, line = 2, cex = 0.8)
      } else {
        plot(1, type="n", main = paste0(group, " ", time, " Insufficient Data for Log Transformation"))
        mtext("Log transformed data insufficient", side=3, line=3)
      }
    }
  }
  
  # Reset to default plotting layout and close the device
  par(mfrow = c(1, 1))
  dev.off()
  
}

```
