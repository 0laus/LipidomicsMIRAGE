---
title: "MIRAGEdata"   
purpose: To load, merge, explore, and plot lipidomics data and look for correlations with cardiometabolic endpoints the MIRAGE dataset.
output:
html_notebook: default
author: Ole Emil Andersen
date created: March 2024
editor_options: 
chunk_output_type: console
---

**Packages**

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(readxl) # reads Excel files
library(dplyr) # to manipulate data
library(tidyr) # facilitates tidy data transformation.
library(purrr) # enhances programming capabilities
library(tibble) # to make columns into row-names
library(janitor) # to clean column names
library(ggplot2) # for plots
library(grid) # to draw and annotate outside plots in figures
library(GGally) # makes pairwise plots
library(patchwork) # to make ggplot subplots
library(lme4) # for mixed models
library(emmeans) # for p-values and confidence intervals
library(lmerTest) # p-values for mixed models
library(correlation) # to analyse data for correlations
library(ComplexHeatmap); library(circlize) # to make complex heatmaps
library(ggrepel) # to avoid overlapping labels
```

# Project settings

Cut offs and values to be used throughout the analysis

```{r message=TRUE, warning=FALSE}
# Number of points above 0 needed for an analysis to take place. The number is the number of id's within class across all intervention groups.
analysis_cutoff <- 12

# Outlier threshold: The factor to multiply by the IQR to define outliers to remove.
# Default in many software is 1.5
outlier_IQR_factor <- 4

# Factor above LLOQ to discard a value NB currently not used
LLOQ_discard_factor <- 2
```

# Load and prepare data

## Lipidomics data

Load data into long format and clean the data by replacing \<0 with 0 and N/A with 0.

```{r message=FALSE}
# Define the path to the Excel file
file_path <- paste0( getwd(), "/data-raw/2022Mar Goodpaster Results With Name Spaces.xlsx")

# List sheet names to load from excel file
sheet_names <- c("SPM SPH AC", "PG", "PI", "PS", "PA", "PE", "PC", "1,3-DAGs", "1,2-DAGs", "Cer dHCer GluCer LacCer GalCer", "TAG")

load_sheets_in_long_format <- function(file_path, sheet_names) {
  map_df(sheet_names, ~ {
    # Read the measurement names from the first row
    measurement_names <- read_excel(file_path, sheet = .x, n_max = 1) %>%
      colnames()

    # Read the data, skipping the first two rows
    data <- read_excel(file_path, sheet = .x, skip = 2, col_names = FALSE)

    # Limit the data to match the number of columns in the column names
    num_cols_in_names <- length(measurement_names)
    data_trimmed <- data[, 1:num_cols_in_names]

    # Assign column names to the data
    colnames(data_trimmed) <- c("Sample Name", measurement_names[-1])

    # Adjusting the replacement for "< 0" with 0 (as numeric) and "N/A" with NA
    data_cleaned <- data_trimmed %>%
      mutate(across(everything(), ~ case_when(
        .x == "< 0" ~ "0", # Replace "< 0" with "0"
        .x == "N/A" ~ "0", # Replace "N/A" with "0"
        TRUE ~ as.character(.x) # Keep other values as-is, converting to character to ensure type consistency
      ))) %>%
      type.convert(as.is = TRUE) # Convert back to original type where possible

    # Rename "Sample Name" to "sampleNumber"
    colnames(data_cleaned)[1] <- "sampleNumber"

    # Transform to long format
    data_long <- pivot_longer(data_cleaned, -sampleNumber, names_to = "measurement", values_to = "pmol")

    # Split the measurement into class and structure based on space
    data_long <- data_long %>%
      separate(measurement, into = c("lipidComposition", "lipidClass"), sep = " ", extra = "merge")

    return(data_long)
  }, .id = "sheet")
}

# Load all specified sheets into a single data frame in long format
lipidomicsDF <- load_sheets_in_long_format(file_path, sheet_names)

# Remove sheet column
lipidomicsDF <- select(lipidomicsDF, -sheet)
```

### Identifiers, samples and PBIS

**Load identifiers and sample weights** and merge with the data frame and split the pid into pre/post and id.

```{r}
# path to file
filePathIdentifiers <- paste0( getwd(), "/data-raw/Lipidomics Key and Weights Goodpaster KZB_identifiable.xlsx")

# load file
identifiersDF <- read_excel(filePathIdentifiers)

# clean names to rename columns to be R friendly
identifiersDF <- clean_names(identifiersDF)

# Make tube_id character
identifiersDF$tube_id <- as.character(identifiersDF$tube_id)

# Combine identifiers with data
lipidomicsDF <- left_join(lipidomicsDF, identifiersDF, by = c("sampleNumber" = "tube_id"))

# Split pid column into an id and a time column
lipidomicsDF <- separate(lipidomicsDF, pid, into = c("id", "time"), sep = " ", extra = "merge")

# Make time, lipidClass, id and group categorical variables
lipidomicsDF$time <- factor(lipidomicsDF$time, levels = c("Pre", "Post")) # sort by pre and post
lipidomicsDF$lipidClass <- factor(lipidomicsDF$lipidClass)
lipidomicsDF$id <- factor(lipidomicsDF$id)
lipidomicsDF$group <- factor(lipidomicsDF$group)
lipidomicsDF$lipidComposition <- factor(lipidomicsDF$lipidComposition)

# Remove PBIS rows
lipidomicsDF <- lipidomicsDF %>%
  filter(id != "PBIS")
```

### Quantification limits

Values are copied from the lipidomics Excel file, "2022Mar Goodpaster Results.xlsx"

```{r}
detection_limits <- data.frame(
  lipidclasses = c("SPH", "AC", "SPM", "PG", "LPG", "PI", "LPI", "PS", "LPS", "PA", "PE", "LPE", "PC", "LPC", "1,3-DG", "1,2-DG", "Cer", "dhCer", "GluCer", "LacCer", "GalCer", "TAG"),
  LLOQ = c(0.08, 0.16, 1.2, 0.6, 0.03, 2.5, 1, 2.5, 0.05, 0.1, 2.5, 1, 7, 3, 0.34, 0.68, 0.25, 0.05, 0.1, 0.2, 0.1, 10),
  ULOQ = c(320, 640, 4800, 2400, 100, 10000, 4000, 10000, 200, 400, 10000, 4000, 28000, 12000, 1360, 2720, 1000, 200, 400, 800, 400, 40000)
)
```

Make column to denote if measurement is within (0), below LLOQ (1), above ULOQ (2) or above ULOQ \* the defined discard factor (3). Values that are discarded are made Na.

```{r}
limitFunction <- function(lipidomicsDF, detection_limits){
# Initialize the 'within_threshold' column
lipidomicsDF$within_threshold <- NA

# Loop through each row in lipidomicsDF
for (i in 1:nrow(lipidomicsDF)) {
  # Retrieve the current lipidClass and pmol value
  current_lipidClass <- lipidomicsDF$lipidClass[i]
  current_pmol <- lipidomicsDF$pmol[i]

  # Find matching LLOQ and ULOQ values from detection_limits
  current_LLOQ <- detection_limits$LLOQ[detection_limits$lipidclasses == current_lipidClass]
  current_ULOQ <- detection_limits$ULOQ[detection_limits$lipidclasses == current_lipidClass]
  
  # Check the pmol value against LLOQ and ULOQ and assign the 'within_threshold'
  if (is.na(current_pmol) | length(current_LLOQ) == 0 | length(current_ULOQ) == 0) {
    lipidomicsDF$within_threshold[i] <- NA # Assign NA if there's an NA value in pmol or LLOQ/ULOQ cannot be found
  } else if (current_pmol < current_LLOQ) {
    lipidomicsDF$within_threshold[i] <- 1 # Below LLOQ
  } else if (current_pmol > (current_ULOQ * LLOQ_discard_factor)) { # Above value to be discarded
    lipidomicsDF$within_threshold[i] <- 2
    # lipidomicsDF$pmol[i] <- NA 
  } else if (current_pmol > current_ULOQ) {
    lipidomicsDF$within_threshold[i] <- 2 # Above ULOQ
  } else {
    lipidomicsDF$within_threshold[i] <- 0 # Within the threshold
  }
}
return (lipidomicsDF)
}

lipidomicsDF <- limitFunction(lipidomicsDF, detection_limits)
```

### Normalization and transformation

**Weight normalization**

```{r}
lipidomicsDF$pmol_mg <- lipidomicsDF$pmol / lipidomicsDF$equiv_weight_extracted
```

**Log transform** Log transform the weight normalized lipidomics data. 1 is added to all values to avoid zores

```{r}
# Transform and add a small constant (+1) to avoid log(0)
lipidomicsDF <- lipidomicsDF %>%
  mutate(pmol_mg_log = log(pmol_mg + 1))
```

### Outlier handling

Outliers are defined based on two criteria: 1) Outside "outlier_IQR_factor" x the IQR for all *non-zero* measurements for a lipidcomposition within a lipidclass. 2) Outside "outlier_IQR_factor" x the IQR for the post - pre change for all measurements within lipidcomposition and lipidclass.

A new column called "... \_imp" is created, where outlier values are replaced with the median for all values within lipidcomposition and class.

```{r}
define_outliers <- function(df, value_col, outlier_col_name){
  
  # Make a outlier col name for change and for composition
  composition_outlier_name <- paste0(outlier_col_name, "_composition")
  change_outlier_name <- paste0(outlier_col_name, "_change")
  
  # Make dynamic column name for difference
  dyn_difference_name <- paste0(value_col, "_abs_delta")
  
  # Make column name for imputed data
  dyn_imputed_name <- paste0(value_col, "_imp")
  
  
  # Calculate the abseloute differences to treat an increase and a decrease similarily
  difference_df <- lipidomicsDF %>%
    select(id, lipidClass, lipidComposition, time, !!sym(value_col)) %>%
    group_by(id, lipidClass, lipidComposition) %>%
    spread(key = time, value = !!sym(value_col)) %>%
    mutate(!!dyn_difference_name := abs(Post - Pre)) %>%
    # Select only the necessary columns for the join
    select(id, lipidClass, lipidComposition, !!sym(dyn_difference_name))
  
  # Join the differences back to the original dataframe
  df <- lipidomicsDF %>%
    left_join(difference_df, by = c("id", "lipidClass", "lipidComposition"))
  
  # Create NA columns
  df[[outlier_col_name]] <- NA
  df[[change_outlier_name]] <- NA
  df[[composition_outlier_name]] <- NA
  
  # Loop through each unique class and composition
  for (class in unique(df$lipidClass)){
    for (comp in unique(df$lipidComposition)){
      
      # Used as an imputation for outlier
      median_value <- median(df[[value_col]][df$lipidClass == class & df$lipidComposition == comp],na.rm = TRUE)
      
      # Identify indices for current class and composition
      indices <- which(df$lipidClass == class & df$lipidComposition == comp & df$pmol_mg > 0)
      
      # To not double count the same values for change pre to post, only pre is used
      indices_change <- which(df$lipidClass == class & df$lipidComposition == comp & df$time == "Pre")
      
      # Calculate the Q1, Q3, and IQR for the current subgroup
      Q1 <- quantile(df[[value_col]][indices], 0.25, na.rm = TRUE)
      Q3 <- quantile(df[[value_col]][indices], 0.75, na.rm = TRUE)
      IQR <- Q3 - Q1
      
      Q1_change <- quantile(df[[dyn_difference_name]][indices_change], 0.25, na.rm = TRUE)
      Q3_change <- quantile(df[[dyn_difference_name]][indices_change], 0.75, na.rm = TRUE)
      IQR_change <- Q3_change - Q1_change
      
      
      # Define upper bounds
      upper_bound <- Q3 + (outlier_IQR_factor * IQR)
      upper_bound_change <- Q3_change + (outlier_IQR_factor * IQR_change)
      
      # Update the 'outlier' column based on calculated bounds
      df[[composition_outlier_name]][indices] <- df[[value_col]][indices] > upper_bound
      
      df[[change_outlier_name]][indices] <- df[[dyn_difference_name]][indices] > upper_bound_change
      
    
      # Add a outlier column with TRUE values if both of the above outlier cols are TRUE and if it's the highest index to maximally make 1 data point as an outlier.
      for (ind in indices){
        
        df[[outlier_col_name]][ind] <- df[[composition_outlier_name]][ind] & df[[change_outlier_name]][ind]
        
        # Add col with imputed values to fill in outliers
        
        ifelse(df[[outlier_col_name]][ind] == TRUE,
               df[[dyn_imputed_name]][ind] <- median_value,
               df[[dyn_imputed_name]][ind] <- df[[value_col]][ind])
      }
    }
  }
  
 # Only make highest value within each composition and class stay TRUE as an outlier
 df <- df %>%
   filter(sampleNumber != 66) %>% # Filter out sample 66, as it is removed
   group_by(lipidComposition, lipidClass) %>%
   mutate(
     max_value = max(.data[[value_col]], na.rm = TRUE),
     outlier = if_else(.data[[value_col]] == max_value, outlier, FALSE)  # Set outlier to FALSE if not max
   ) %>%
   select(-max_value)  # Remove the max_value column
  
  return(df)
}

## Run function

lipidomicsDF <- define_outliers(df = lipidomicsDF,
                                value_col = "pmol_mg",
                                outlier_col_name = "outlier")

# On log adjusted
 lipidomicsDF <- define_outliers(df = lipidomicsDF,
                                 value_col = "pmol_mg_log",
                                 outlier_col_name = "outlier_log")

 
```

### Sample removal

```{r}
##### Manual removal #####

# Subject MG034 POST (Tube 66)
# Reason: Removed as TAG values are unnaturally high strongly suggesting IMAT contamination in the sample. As other lipids either directly or through the weight normalization would be affected, the post-measurement point is removed.

lipidomicsDF <- lipidomicsDF[!lipidomicsDF$sampleNumber == 66,]
```



### Ratios and saturation

Make saturation columns, where first column is defined by the number of double bonds in the first lipid, and the second column is defined by the number of double bonds in the second lipid. Also make a column to define ether bonds in the lipidcomposition.

```{r}
# Make saturation columns and ether bond column
lipidomicsDF <- lipidomicsDF %>%
  # Convert factors to character if not already
  mutate(lipidComposition = as.character(lipidComposition)) %>%
  # Create new columns for sat_level_1, sat_level_2, and count of 'e'
  mutate(
    sat_level_1 = sapply(regmatches(lipidComposition, gregexpr("(?<=:)(\\d+)", lipidComposition, perl = TRUE)), `[`, 1),
    sat_level_2 = sapply(regmatches(lipidComposition, gregexpr("(?<=:)(\\d+)", lipidComposition, perl = TRUE)), `[`, 2),
    ether_bond = sapply(lipidComposition, function(x) sum(gregexpr("e", x)[[1]] > 0))  # Correctly count occurrences of 'e'
  ) %>%
  # Handle cases where "di" is present in lipidComposition
  mutate(
    sat_level_2 = ifelse(grepl("di", lipidComposition) & is.na(sat_level_2), sat_level_1, sat_level_2)
  ) %>%
  # Ensure sat_level_2 is NA where there is no second match and no "di"
  mutate(sat_level_2 = ifelse(is.na(sat_level_2), NA, sat_level_2))

# Summarize saturation levels by id and lipidClass for each level of saturation.
summarized_saturations <- lipidomicsDF %>%
  group_by(id, time, lipidClass) %>%
  summarize(
    class_sat_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 0 & (sat_level_2 == 0 | is.na(sat_level_2))], na.rm = TRUE),
    class_unsat1_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 1 & (sat_level_2 <= 1 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 == 0 & sat_level_2 == 1], na.rm = TRUE),
    class_unsat2_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 2 & (sat_level_2 <= 2 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 2 & sat_level_2 == 2], na.rm = TRUE),
        class_unsat3_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 3 & (sat_level_2 <= 3 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 3 & sat_level_2 == 3], na.rm = TRUE),
    class_unsat4_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 4 & (sat_level_2 <= 4 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 4 & sat_level_2 == 4], na.rm = TRUE),
      class_unsat5_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 5 & (sat_level_2 <= 5 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 5 & sat_level_2 == 5], na.rm = TRUE),
    class_unsat6_pmol_mg = sum(pmol_mg_imp[sat_level_1 == 6 & (sat_level_2 <= 6 | is.na(sat_level_2))], na.rm = TRUE) +
      sum(pmol_mg_imp[sat_level_1 < 6 & sat_level_2 == 6], na.rm = TRUE),
    
    class_no_ether_pmol_mg = sum(pmol_mg_imp[ether_bond == 0], na.rm = TRUE),
    class_ether_pmol_mg = sum(pmol_mg_imp[ether_bond == 1], na.rm = TRUE),
    
    .groups = 'drop'
  )

# Prepare the main data for joining
lipidomicsDF_saturation <- lipidomicsDF %>%
  select(id, time, lipidClass, group) %>%
  left_join(summarized_saturations, by = c("id", "time", "lipidClass")) %>% 
   distinct(id, time, lipidClass, group, class_sat_pmol_mg, class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, class_no_ether_pmol_mg, class_ether_pmol_mg)

# Calculate ratios
lipidomicsDF_saturation <- lipidomicsDF_saturation %>%
  rowwise() %>% 
  mutate(
    unsat_proportion = sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, na.rm = TRUE) / sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg,class_sat_pmol_mg, na.rm = TRUE),
    
    sat_proportion = sum(class_sat_pmol_mg, na.rm = TRUE) / sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, class_sat_pmol_mg, na.rm = TRUE),
    
    unsat_mono_proportion = sum(class_unsat1_pmol_mg, na.rm = TRUE) / sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, class_sat_pmol_mg, na.rm = TRUE),
    
    unsat_poly_proportion = sum(class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, na.rm = TRUE) / sum(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, class_sat_pmol_mg, na.rm = TRUE),
    
    
    ether_bond_proportion = sum(class_ether_pmol_mg, rm.na = TRUE) / sum(class_no_ether_pmol_mg, class_ether_pmol_mg, na.rm = TRUE)
  )

         
# # Check sum of pmol_mg
# lipidomicsDF_saturation_sum <- lipidomicsDF_saturation %>%
#   rowwise() %>%
#   mutate(sum_pmol_mg = sum(c(class_unsat1_pmol_mg, class_unsat2_pmol_mg, class_unsat3_pmol_mg, 
#                                class_unsat4_pmol_mg, class_unsat5_pmol_mg, class_unsat6_pmol_mg, 
#                                class_sat_pmol_mg), na.rm = TRUE)) %>%
#   ungroup()
# 
  #View(lipidomicsDF_saturation)
```

**Add PE/PC ratio** Outliers are handled by calculating from imputed values as the PE and PC classes are summed. As they are analysed on a lipid class level, Outlier status is therefore set to FALSE.

```{r}
add_ratio_lipidomics <- function (lipidomicsDF)
{
  
    # Filter for PE and PC lipid classes and summarize their pmol values
sums_df <- lipidomicsDF %>%
  filter(lipidClass %in% c("PE", "PC")) %>%
  group_by(id, time, sampleNumber, group, wet_weight, lyphilized_weight, volume_of_homogenate_ul, equiv_weight_extracted, lipidClass) %>%
  summarise(
    sum_pmol_mg = sum(pmol_mg_imp),
    .groups = "drop"
  )

# Pivot the data to wide format after summarization
sums_wide <- sums_df %>%
  pivot_wider(names_from = lipidClass, values_from = sum_pmol_mg)

# Calculate the PC/PE ratio
ratios_df <- sums_wide %>%
  mutate(lipidClass = "PC.PE",
         lipidComposition = "ratio",
         pmol = NA_real_,
         pmol_mg = PC / PE,
         within_threshold = NA) %>%
  select(-PE, -PC)# Remove intermediate PE and PC columns

# Ensure matching column structure with the original dataframe
# For columns not included in ratios_df, add them as NAs
missing_cols <- setdiff(names(lipidomicsDF), names(ratios_df))
for(col in missing_cols) {
  ratios_df[[col]] <- NA
}

# Reorder columns to match the original dataframe exactly
ratios_df <- ratios_df[names(lipidomicsDF)]

# Fill in the imputed column
ratios_df$pmol_mg_imp <- ratios_df$pmol_mg

# Set outlier status to FALSE as calculated from non-outliers
ratios_df$outlier <- FALSE

# Bind the rows to include PE:PC ratio ratios in the original dataframe
lipidomicsDF <- bind_rows(lipidomicsDF, ratios_df)

return(lipidomicsDF)
}

lipidomicsDF <- add_ratio_lipidomics(lipidomicsDF = lipidomicsDF)
```

**Add Cer 16:0 / Cer 24:0 ratio** Outliers are handled by filtering out outlier data in the function below

```{r}
add_ratio_lipidomics <- function (lipidomicsDF)
{
  workingDF <- lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),] %>%
  filter(lipidClass %in% c("Cer") & lipidComposition %in% c("16:0", "24:0"))

  # Set irrelevant columns to NA before pivoting
#workingDF <- workingDF %>%
#  mutate(pmol = NA_real_,
#         pmol_mg_PrePost_delta = NA_real_,
#         pmol_mg_imp = NA_real_)
  
# Update the outlier information within the workingDF without summarizing
workingDF <- workingDF %>%
  group_by(id, time, group) %>%
  mutate(
    outlier = any(outlier, na.rm = TRUE),
    outlier_change = any(outlier_change, na.rm = TRUE),
    outlier_composition = any(outlier_composition, na.rm = TRUE),
    outlier_log = any(outlier, na.rm = TRUE),
    outlier_change_log = any(outlier_change, na.rm = TRUE),
    outlier_composition_log = any(outlier_composition, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  select(outlier, outlier_change, outlier_composition, outlier_log, outlier_change_log, 
         outlier_composition_log, pmol_mg, group, time, id, sampleNumber, 
         lipidClass, lipidComposition)


# Pivot the data to wide format
wideDF <- workingDF %>%
  group_by(id, time, group, lipidComposition) %>%
  pivot_wider(
    names_from = lipidComposition,
    values_from = pmol_mg,
    values_fill = list(pmol_mg = NA)  # Fills missing data
  )

# Calculate the ratio
ratios_df <- wideDF %>%
  mutate(lipidClass = "Cer ratio",
         lipidComposition = "16:0 24:0",
         pmol = NA_real_,
         pmol_mg = `16:0` / `24:0`,
         within_threshold = NA) %>%
   select(sampleNumber, lipidComposition, lipidClass, id, time, group, pmol_mg, outlier_composition, outlier_change, outlier)# Remove intermediate PE and PC columns

# Ensure matching column structure with the original dataframe
# For columns not included in ratios_df, add them as NAs
missing_cols <- setdiff(names(lipidomicsDF), names(ratios_df))
for(col in missing_cols) {
  ratios_df[[col]] <- NA
}

# Reorder columns to match the original dataframe exactly
ratios_df <- ratios_df[names(lipidomicsDF)]

# Fill out imputed col (no outliers exist, as input data is cleaned)
ratios_df$pmol_mg_imp <- ratios_df$pmol_mg

# Bind the rows to the end of the lipidomicsDF
lipidomicsDF <- bind_rows(lipidomicsDF, ratios_df)

return(lipidomicsDF)
}
# Run function; nb. only non-outlier values are used
lipidomicsDF <- add_ratio_lipidomics(lipidomicsDF = lipidomicsDF)
```

**Sort data**

```{r}
# Sort the dataframe by 'id' and 'time'
lipidomicsDF <- lipidomicsDF %>%
  arrange(id, time)

# Find all lipidClass-lipidComposition
unique_combinations <- lipidomicsDF %>%
  distinct(lipidClass, lipidComposition) %>%
  arrange(lipidClass, lipidComposition)
```

**Define unique lipid classes**

```{r}
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
```

## Mirage data

**Load from "FINAL MIRAGE DATASET.xlsx"**

!!! DUPLICATE IDS: "MG023" and "MG019" both are duplicates that appear with same group as in id from Pittsburg and TRI. Assumption: All samples are from TRI if not specified otherwise. Therefore, the Excel file "FINAL MIRAGE DATASET.xlsx", sheet "Not Imputed-Clean" was changed to make the merge work. All changes are marked with red text.

```{r}
# path to file
file_path_endpoints <- paste0( getwd(), "/data-raw/FINAL MIRAGE DATASET.xlsx")

# load file
mirage_data <- read_excel(file_path_endpoints, sheet = "Not Imputed-Clean")

# clean names
mirage_data <- clean_names(mirage_data)

# separate pid into id and site
mirage_data <- separate(mirage_data, pid, into = c("id", "site"), sep = "-", extra = "merge")

# Remove redundant columns
mirage_data <- select(mirage_data, -study_center)


# Adjust column names, and move pre and post to the end of the name
# Loop through each column name in mirage_data
new_col_names <- sapply(names(mirage_data), function(col_name) {
  # Check if "_pre" is in the column name
  if (grepl("_pre", col_name)) {
    col_name <- gsub("_pre", "", col_name) # Remove "_pre"
    col_name <- paste0(col_name, "_pre") # Add "_pre" to the end
  }
  # Check if "_post" is in the column name
  if (grepl("_post", col_name)) {
    col_name <- gsub("_post", "", col_name) # Remove "_post"
    col_name <- paste0(col_name, "_post") # Add "_post" to the end
  }
  return(col_name)
})

# Update the column names of mirage_data
names(mirage_data) <- new_col_names
```

**Calculate additional rows**

```{r}
mirage_data$tdee_kcal_24hr_ffm_pre <- mirage_data$tdee_kcal_24hr_pre / mirage_data$lean_mass_dxa_pre

# Asses moderate to vigorous physical activity by combining minutes in moderate (mpa) with vigerous activity (vpa) 
mirage_data$mvpa_mins_day_pre <- mirage_data$mpa_mins_day_pre + mirage_data$vpa_mins_day_pre
mirage_data$mvpa_mins_day_post <- mirage_data$mpa_mins_day_post + mirage_data$vpa_mins_day_post

```

### Select variables & long format

**pre-post variables** Define variables of interest for pre-post delta correlations against lipids.

```{r}
# List with pre-post variables of interest
glycemicControl <- list(
  c("rd_ss1kg_ffm_insulin_pre", "rd_ss1kg_ffm_insulin_post", "Glucose RD per FFM and insulin (?)"),
  c("rd_ss2kg_ffm_insulin_pre", "rd_ss2kg_ffm_insulin_post", "Glucose RD per FFM and insulin (?)"),
  c("hgb_a1c_pre", "hgb_a1c_post", "HbA1c (mmol / mol?)"),
  c("homair_pre", "homair_post", "HOMAIR (abr unit)"),
  c("egp0kg_ffm_pre", "egp0kg_ffm_post", "Endogenous glucose production (?)"),
  c("egpss1kg_ffm_pre", "egpss1kg_ffm_post", "Endogenous glucose production (?)"),
  c("egpss2kg_ffm_pre", "egpss2kg_ffm_post", "Endogenous glucose production (?)")
  )

mitochondria <- list(
  c("at_pmax_p_mrs_pre", "at_pmax_p_mrs_post", "ATP max (?)"),
  c("pcr_p_mrs_pre", "pcr_p_mrs_post", "PCR recovery? (?)"),
  c("max_oxphos_pre", "max_oxphos_post", "Max oxidative phosphorylation (?)"),
  c("max_ets_pre", "max_ets_post", "Max ETS? (?)"),
  c("le_pre", "le_post", "Leak? (?)"),
  c("pe_pre", "pe_post", "PE? (?)")
  )

bodycomposition <- list( # SHOULD FFM ETC. WEIGHTs BE NORMALISED TO TOTAL WEIGHT?
  c("weight_pre", "weight_post", "Body mass (kg)" ),
  c("leg_lean_mass_pre", "leg_lean_mass_post", "Leg lean mass (kg?)" ),
  c("fat_mass_dxa_pre", "fat_mass_dxa_post", "Fat mass (kg?)"),
  c("lean_mass_dxa_pre", "lean_mass_dxa_post", "Lean body mass (kg?)"),
  c("ffm_dxa_pre", "ffm_dxa_post", "Fat free mass (kg?)"),
  c("thigh_sat_g_pre", "thigh_sat_g_post", "Thigh SAT, (g)"),
  c("thigh_imat_g_pre", "thigh_imat_g_post", "IMAT (g)"),
  c("percent_imat_pre", "percent_imat_post", "IMAT fraction (%)"),
  c("thigh_muscle_g_pre", "thigh_muscle_g_post", "Thigh muscle (g)"),
  c("abdomen_vat_g_pre", "abdomen_vat_g_post", "Adbominal VAT (g)"),
  c("type_iia_iix_pre", "type_iia_iix_post", "Fibertype? (?)")
  )

blood <-  list(
  c("vldl_pre", "vldl_post", "VLDL (mmol / l)"),
  c("ldl_pre", "ldl_post", "LDL (mmol / l"),
  c("hdl_pre", "hdl_post", "HDL (mmol / l)"),
  c("cholesterol_pre", "cholesterol_post", "Total cholesterol (mmol / l)"),
  c("triglycerides_pre", "triglycerides_post", "Triglycerides (mmol / l)"),
  c("plasma_ffabg_pre", "plasma_ffabg_post", "FFA (mmol / l)")
  )
  
  physicalActivity <- list(
  c("daily_steps_steps_24hr_pre", "daily_steps_steps_24hr_post", "Activity (steps / day)"),
  c("mvpa_mins_day_pre", "mvpa_mins_day_post", "Time per day (min / day)"),
  c("vo2abs_pre", "vo2abs_post", "Oxygen uptake (l / min)"),
  c("vo2kg_ffm_pre", "vo2kg_ffm_post", "Oxygen uptake (l / min / kgFFM) "),
  c("x4m_walk_pre", "x4m_walk_post", "Time? (s)"),
  c("step_test_pre", "step_test_post", "Steps? (?)"),
  c("x1rm_pre", "x1rm_post", "Stength (?)"),
  c("peak_torque120_pre", "peak_torque120_post", "Torque (Nm?)"),
  c("age_pre", "age_post", "Age (years)")
  )
  
  mirage_ch_vars <- list(
    glycemicControl = glycemicControl,
    mitochondria = mitochondria,
    bodycomposition = bodycomposition,
    blood = blood,
    physicalActivity = physicalActivity
  )
  
  
```

**Cross-sectional variables** Define variables of interest to compare between all individuals at pre

```{r}
# Glycemic Control
glycemicControl <- c("rd_ss1kg_ffm_insulin_pre", "rd_ss2kg_ffm_insulin_pre", "hgb_a1c_pre", "homair_pre", "egp0kg_ffm_pre", "egpss1kg_ffm_pre", "egpss2kg_ffm_pre")

# Mitochondria
mitochondria <- c("at_pmax_p_mrs_pre", "pcr_p_mrs_pre", "max_oxphos_pre", "max_ets_pre", "le_pre", "pe_pre")

bodycomposition <- c("weight_pre", "leg_lean_mass_pre", "fat_mass_dxa_pre", "lean_mass_dxa_pre", "ffm_dxa_pre", "thigh_sat_g_pre", "thigh_imat_g_pre", "percent_imat_pre", "thigh_muscle_g_pre", "abdomen_vat_g_pre", "type_iia_iix_pre")

# Blood
blood <- c("vldl_pre", "ldl_pre", "hdl_pre", "cholesterol_pre", "triglycerides_pre", "plasma_ffabg_pre")

# Physical Activity + Age
physicalActivity <- c("daily_steps_steps_24hr_pre", "mvpa_mins_day_pre", "vo2abs_pre", "vo2kg_ffm_pre", "x4m_walk_pre", "step_test_pre", "x1rm_pre", "age_pre")


# Combining all the "_pre" variables into a single list for mirage_crossSectional_vars, excluding "age_pre" from all but the physicalActivity list
mirage_crossSectional_vars <- list(
  glycemicControl = glycemicControl,
  mitochondria = mitochondria,
  bodycomposition = bodycomposition,
  blood = blood,
  physicalActivity = physicalActivity
)
```

**Mirage long format** Convert Mirage dataset with selected variables into long format with selected Pre\|Post varibles

```{r}
# Flatten the lists into a single vector
columns_to_merge <- mirage_ch_vars_flat <- unlist(unlist(lapply(mirage_ch_vars, function(category) {
  lapply(category, function(item) item[1:2])
}), recursive = FALSE), use.names = FALSE)


# Select columns from 'mirage_data' including the 'id' column
mirage_data_subset <- mirage_data[c("id", columns_to_merge)]

# Filter out the ids based on the ids in lipidomicsDF
mirage_data_subset <- mirage_data_subset %>%
  filter(id %in% lipidomicsDF$id)

# Transform 'mirage_data_subset' to long format
mirage_data_long_ch <- pivot_longer(
  mirage_data_subset,
  cols = -id, # Exclude 'id' from the pivoting
  names_to = c(".value", "time"), # Separate original column name into variable name and time
  names_pattern = "(.+)_(pre|post)" # Pattern to split the variable names and time
)

# Adjust the 'time' column in 'mirage_data_long_ch' to match 'Pre' and 'Post'
mirage_data_long_ch <- mirage_data_long_ch %>%
  mutate(time = case_when(
    time == "pre" ~ "Pre",
    time == "post" ~ "Post",
    TRUE ~ time # Keeps the original value if it's neither 'pre' nor 'post'
  ))

# Remove rows where all measurements are NA
mirage_data_long_ch <- mirage_data_long_ch %>%
  group_by(id, time) %>%
  filter(!all(is.na(age)))
```

# Saturation analysis

## Pre-post

### Mixed model

Should be identical to how statistics are calculated for lipidclass. Data must be condensed to not include lipidComp, as this will give duplicates

```{r}
# Set the max number of observations that the emmeans package will handle. Lower number shorter computation times, larger number, more precise CI and p-value estimates
emm_options(pbkrtest.limit = 6000) # change to 5000 after code works

mixedmodel_pre_post_sat <- function(dataset, response_var, lipidclass, lipidcomposition = NULL) {
  
  print( paste0("Analysing ", lipidclass, "..."))
  
  # Filter dataset
  data_to_model <- filter(dataset, lipidClass == lipidclass)
  
    # Check number of non-zero rows
  non_zero_rows <- data_to_model %>% 
    filter(!!sym(response_var) > 0) %>% 
    nrow()
  
  # only proceed if number of non zero rows is above cutoff
  if (non_zero_rows < analysis_cutoff){
          results_list <- list(
        lipidClass = as.character(lipidclass),
        lipidComposition = as.character(lipidcomposition),
        slope_results = NA_real_,
        prepost_results = NA_real_)
      
      results_list <- setNames(list(results_list), lipidclass)
      
      return(results_list)
  } else {
  
  
  # Prepare factors
  data_to_model$group <- factor(data_to_model$group, levels = c("HED", "DIWL", "WLEX"))
  data_to_model$time <- factor(data_to_model$time, levels = c("Pre", "Post"))

  # Make forumula
    model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id)"))

  # Try-catch block for model fitting
  tryCatch(
    {
      model <- lmer(model_formula,
                    data = data_to_model,
                    na.action = na.exclude)
      # Estimated marginal of means to get out slope and between groups statistics
      emm <- emmeans(model, ~ time * group)

      # Contrasts for differences in slopes between groups
      model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")

      model.slope.contrasts.results <- summary(model.slope.contrasts)

      # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
      model.slope.contrasts.results <- model.slope.contrasts.results %>%
        mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
        select(contrast, estimate, SE, df, t.ratio, p.value)

      # Pre, Post between group comparisons
      prepost.contrasts <- pairs(emm, adjust = "none")

      # Get results
      prepost.contrasts.results <- summary(prepost.contrasts)
      
      # Create results list
      results_list <- list(
        lipidClass = as.character(lipidclass),
        lipidComposition = as.character(lipidcomposition),
        slope_results = model.slope.contrasts.results,
        prepost_results = prepost.contrasts.results)
      
      # Name results list
             results_list <- setNames(list(results_list), lipidclass)
      
             return(results_list)
    },
      error = function(e) {
      results_list <- list(
        lipidClass = as.character(lipidclass),
        lipidComposition = as.character(lipidcomposition),
        slope_results = NA_real_,
        prepost_results = NA_real_)
      
      results_list <- setNames(list(results_list), lipidclass)
      
      return(results_list)
    }
  )
  }
  }
  # RUN FUNCTION
# Use map to iterate over lipid classes

unique_lipid_classes.noRatios <- unique_lipid_classes[!unique_lipid_classes == c("PC.PE", "Cer ratio")]

# Saturated
result.lipid.pre_post_sat <- map(unique_lipid_classes.noRatios, ~ mixedmodel_pre_post_sat(lipidomicsDF_saturation, "sat_proportion", .x))
# Unsaturated
result.lipid.pre_post_unsat <- map(unique_lipid_classes.noRatios, ~ mixedmodel_pre_post_sat(lipidomicsDF_saturation, "unsat_proportion", .x))
# Mono unsaturated
result.lipid.pre_post_mono_unsat <- map(unique_lipid_classes.noRatios, ~ mixedmodel_pre_post_sat(lipidomicsDF_saturation, "unsat_mono_proportion", .x))
# Poly unsaturated
result.lipid.pre_post_poly_unsat <- map(unique_lipid_classes.noRatios, ~ mixedmodel_pre_post_sat(lipidomicsDF_saturation, "unsat_poly_proportion", .x))

# Flatten list to make list appear with class names
result.lipid.pre_post_sat <- flatten(result.lipid.pre_post_sat)
result.lipid.pre_post_unsat <- flatten(result.lipid.pre_post_unsat)
result.lipid.pre_post_mono_unsat <- flatten(result.lipid.pre_post_mono_unsat)
result.lipid.pre_post_poly_unsat <- flatten(result.lipid.pre_post_poly_unsat)






####### Make data ready for plotting


prepare_sat_data_for_plotting <- function(result_data) {
  pvals_df <- data.frame()
  est_df <- data.frame()

  contrasts_prepost <- c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX")
  contrasts_slope <- c("Pre - Post : HED - DIWL", "Pre - Post : HED - WLEX", "Pre - Post : DIWL - WLEX")

  for (test_name in names(result_data)) {
    # Check if prepost_results and slope_results are not NA
    if (!is.na(result_data[[test_name]]$prepost_results[[1]][1])) {
      prepost_results <- result_data[[test_name]]$prepost_results
    } else {
      prepost_results <- data.frame(contrast = character(), p.value = numeric())
    }

    if (!is.na(result_data[[test_name]]$slope_results[[1]][1])) {
      slope_results <- result_data[[test_name]]$slope_results
    } else {
      slope_results <- data.frame(contrast = character(), p.value = numeric())
    }

    # Proceed with extraction
    prepost_pvals <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)

    slope_pvals <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)

        prepost_est <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    slope_est <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    
    # Combine values into single data
    # p-values
    combined_pvals <- c(prepost_pvals, slope_pvals)
    combined_pvals <- setNames(combined_pvals, c(contrasts_prepost, contrasts_slope))
    pvals_df <- rbind(pvals_df, cbind(lipid = test_name, t(as.data.frame(list(combined_pvals)))))
    
    # Estimates
    combined_est <- c(prepost_est, slope_est)
    combined_est <- setNames(combined_est, c(contrasts_prepost, contrasts_slope))
    est_df <- rbind(est_df, cbind(lipid = test_name, t(as.data.frame(list(combined_est)))))
  }

  # Select all columns after the first one to exclude lipid column
  corrected_cols <- names(pvals_df)[-1]

     # Remove rows where every column from the second column onwards contains NA
   pvals_df <- pvals_df[rowSums(is.na(pvals_df[, -1])) < (ncol(pvals_df) - 1), ]
   
  # Apply Benjamini-Hochberg correction and create new columns with the suffix "_BH_corrected"
  for (col in corrected_cols) {
    pvals_df[[paste0(col, " (corrected)")]] <- p.adjust(pvals_df[[col]], method = "BH")
  }
   
  # Reset row names to simple sequential numbers
  rownames(pvals_df) <- NULL
  rownames(est_df) <- NULL

   # Only keep rows in est_df where the lipid values match those in pvals_df
est_df <- est_df[est_df$lipid %in% pvals_df$lipid, ]
  
  # Convert the columns to numeric
 # p-vals
   for (i in 2:ncol(pvals_df)) {
    if (!is.numeric(pvals_df[[i]])) {
      pvals_df[[i]] <- as.numeric(pvals_df[[i]])
    }
  }
  # estimates 
   for (i in 2:ncol(est_df)) {
    if (!is.numeric(est_df[[i]])) {
      est_df[[i]] <- as.numeric(est_df[[i]])
    }
  }

  # Combine the est and pvals dataframes into a list to be returned
  est_and_pvals <- list(p.vals = pvals_df, estimates = est_df)
  return(est_and_pvals)
}

# Prepare data for plotting lipid classes
est_and_p_sat <- prepare_sat_data_for_plotting(result.lipid.pre_post_sat)
est_and_p_unsat <- prepare_sat_data_for_plotting(result.lipid.pre_post_unsat)
est_and_p_mono_unsat <- prepare_sat_data_for_plotting(result.lipid.pre_post_mono_unsat)
est_and_p_poly_unsat <- prepare_sat_data_for_plotting(result.lipid.pre_post_poly_unsat)

```

### Scatter

```{r}
plot_pre_post_sat <- function(lipidomicsDF_saturation, lipid_class, p_val_df, y_label, save_folder, col_name) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF_saturation %>%
    filter(lipidClass == lipid_class & !is.na(time))
  
  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )

  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )

  # Calculate means for each group and time point
mean_data_class <- filtered_data %>%
  group_by(group, time) %>%
  summarise(mean_proportion = mean(!!sym(col_name), na.rm = TRUE), .groups = 'drop')

# Create the plot
plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = !!sym(col_name), group = interaction(id, group)
  )) +
  geom_line(aes(group = interaction(id, group), color = id), alpha = 0.9, linewidth = 0.1, position = position_nudge(x = 0.03)) +
  geom_point(aes(color = id), alpha = 0.5, position = position_nudge(x = 0.03)) +

    geom_boxplot(aes(group = interaction(group, time)),
      width = 0.3, alpha = 0.2, outlier.shape = NA,
      position = position_dodge(width = 0.75), color = "black"
    ) +
  geom_line(data = mean_data_class, aes(x = interaction(group, time, sep = " "), y = mean_proportion, group = group),color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
  scale_color_manual(values = rainbow(length(unique(filtered_data$id)))) +
  labs(title = lipid_class, 
       subtitle = annotation_pvals_slope, 
       y = y_label,
       x = "") +
  annotate("text", x = c(1.5, 3.5, 5.5), y = 1.1, label = annotation_pvals_pre_post, size = 2) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
        legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
        legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
        plot.subtitle = element_text(size = 5, hjust = 0.5))

  # Filter the LLOQ and ULOQ for the current lipid_class and set y-axis limits
  #y_min <- min(pmol_mg_class_sum$sum_pmol_mg, na.rm = TRUE) * 0.95 # Adjusted
  #y_max <- max(pmol_mg_class_sum$pmol_mg_znorm, na.rm = TRUE) * 1.05 # Adjusted
  # plot <- plot + coord_cartesian(ylim = c(y_min, y_max))

  # Define the filename and save the plot
  filename <- paste0(
    getwd() ,"/outputs/saturation/pre-post/scatter/",
    save_folder, "/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

  # RUN FUNCTION
# Loop to call the plotting function for each lipid class
unique_lipid_classes.noRatios <- unique_lipid_classes[!unique_lipid_classes == c("PC.PE", "Cer ratio")]

for (lipid_class in unique_lipid_classes.noRatios) {
# Saturated
    plot_pre_post_sat(lipidomicsDF_saturation = lipidomicsDF_saturation, lipid_class = lipid_class, p_val_df = est_and_p_sat$p.vals, y_label = "Proportion of saturated lipids", save_folder = "saturated", col_name = "sat_proportion")
  # Unsaturated
  plot_pre_post_sat(lipidomicsDF_saturation = lipidomicsDF_saturation, lipid_class = lipid_class, p_val_df = est_and_p_unsat$p.vals, y_label = "Proportion of unsaturated lipids", save_folder = "unsaturated", col_name = "unsat_proportion")
  # Monounsaturated
  plot_pre_post_sat(lipidomicsDF_saturation = lipidomicsDF_saturation, lipid_class = lipid_class, p_val_df = est_and_p_mono_unsat$p.vals, y_label = "Proportion of mono unsaturated lipids", save_folder = "unsaturated_mono", col_name = "unsat_mono_proportion")
  # polyunsaturated
  plot_pre_post_sat(lipidomicsDF_saturation = lipidomicsDF_saturation, lipid_class = lipid_class, p_val_df = est_and_p_poly_unsat$p.vals, y_label = "Proportion of poly unsaturated lipids", save_folder = "unsaturated_poly", col_name = "unsat_poly_proportion")
}

```

### Heatmap

```{r}
heatmap_pre_post_sat <- function(result_data, overall_title){

  pvals_df <- result_data$p.vals
  estimates_df <- result_data$estimates
  
# Select the specified columns for hm_data.p-vals matrix
pvals_df <- pvals_df[ , c("lipid", "Pre HED - Post HED (corrected)", "Pre DIWL - Post DIWL (corrected)", 
                               "Pre WLEX - Post WLEX (corrected)", "Pre - Post : HED - DIWL (corrected)",
                               "Pre - Post : HED - WLEX (corrected)", "Pre - Post : DIWL - WLEX (corrected)")]

# Set 'lipid' as row names
rownames(pvals_df) <- pvals_df$lipid
rownames(estimates_df) <- estimates_df$lipid

# Remove the 'lipid' column
pvals_df <- pvals_df[ , !(names(pvals_df) %in% c("lipid"))]
estimates_df <- estimates_df[ , !(names(estimates_df) %in% c("lipid"))]

# Rename columns by removing " (corrected)" from all column names in pvals_df
colnames(pvals_df) <- gsub(" \\(corrected\\)", "", colnames(pvals_df))

# Sort column names
common_cols <- intersect(colnames(estimates_df), colnames(pvals_df))
estimates_df <- estimates_df[, common_cols, drop = FALSE]
pvals_df <- pvals_df[, common_cols, drop = FALSE]

### Divide dataframe based on lipid groups
# Define lipid groups
lipids_groups <- list(
  gr_all = c("TAG", "1,2-DG", "1,3-DG", "AC", "PC", "PC.PE ratio", "PE", "SPM", "SPH", "Cer", "dhCer", "GluCer", "LacCer", "GalCer", "LPC", "LPE", "LPG", "LPI", "LPS", "PA", "PS", "PG", "PI")
)

### Divide dataframe based on lipid groups with lipid as row name
filter_lipid_group_row <- function(data_frame, lipid_group) {
 
   # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  
  # Convert row names to a temporary column for sorting and filtering
  data_frame_with_lipid <- tibble::rownames_to_column(data_frame, var = "lipid")
  
  # Sort the dataframe by the temporary lipid column
  sorted_data_frame_with_lipid <- data_frame_with_lipid[order(data_frame_with_lipid$lipid), ]
  
  # Filter based on the pattern
  sorted_filtered_data_frame_with_lipid <- sorted_data_frame_with_lipid[grepl(pattern, sorted_data_frame_with_lipid$lipid), ]
  
  # Drop the temporary lipid column and return to original format
  rownames(sorted_filtered_data_frame_with_lipid) <- sorted_filtered_data_frame_with_lipid$lipid
  sorted_filtered_data_frame <- sorted_filtered_data_frame_with_lipid[ , !colnames(sorted_filtered_data_frame_with_lipid) %in% 'lipid', drop = FALSE]
  return(sorted_filtered_data_frame)
}


# Apply the filter function to each group and store the results in a lists
# p-values
pvals_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = pvals_df)

# estimates
estimates_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = estimates_df)

# Convert all dataframes to matrices
matrices_pvals <- lapply(pvals_gr_list, function(x) as.matrix(x))
matrices_estimates <- lapply(estimates_gr_list, function(x) as.matrix(x))


generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims, hm_title, hm_unit) {
  # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
# Extract test_against by removing the first part (treatment group) and the first underscore
# This joins back the remaining parts to form the full 'test_against' label
colTitles <- c("Slope", "Pre vs Post")

  Heatmap(hm_matrix,
          name = hm_unit, # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 7.5 ), # Change font size of row labels
          
          #column_split = rep(1:(ncol(hm_matrix) / 3), each = 3), # Splits the columns and names them
          column_title = hm_title,
          column_names_rot = 45, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 8, fontface = "bold"),
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 10, fontface = "bold"),
          #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
      
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                  if (p_val_matrix[i, j] < pLims$p1) {
                      grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p2) {
                      grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p3) {
                      grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  }
              }
          })
}

# Define color map for heatmap
color_mapping_slope <- colorRamp2(c(-50, 0, 50), c("blue", "white", "red"))
color_mapping_pre_post <- colorRamp2(c(-50, 0, 50), c("darkgreen", "white", "orange"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
hm <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)) {
  # Generate slope and pre/post hm
  
  hm_slope <- generate_heatmap(matrices_estimates[[i]][,4:6]*100, matrices_pvals[[i]][,4:6], color_mapping_slope, p_value_limits, hm_title = "Slope ", hm_unit = "pp")
  hm_pre_post <- generate_heatmap(matrices_estimates[[i]][,1:3]*100, matrices_pvals[[i]][,1:3], color_mapping_pre_post, p_value_limits, hm_title = "Pre vs Post", hm_unit = "pp ")
  
  # Combine heat maps and store in list
  hm[[i]] <- hm_slope + hm_pre_post
  # Generate heatmap and store it in the list
}

# Define the path and name of your PDF file
pdf_path <- paste0( getwd(), "/outputs/saturation/pre-post/heatmap/", overall_title, ".pdf")

# Open a PDF device
pdf(pdf_path, width = 8, height = 10)

# Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
for (i in 1:length (hm)){
  draw(hm[[i]], padding = unit(c(0, 0, 10, 0), "mm"))
}

# Add a common title
grid.text(overall_title, x = unit(0.5, "npc"), y = unit(0.98, "npc"), 
          gp = gpar(fontsize = 14, fontface = "bold"))

# Don't forget to close the device
dev.off()
}

# Run function
heatmap_pre_post_sat (result_data = est_and_p_sat, overall_title = "Saturated")
heatmap_pre_post_sat (result_data = est_and_p_unsat, overall_title = "Unsaturated")
heatmap_pre_post_sat (result_data = est_and_p_mono_unsat, overall_title = "Mono unsaturated")
heatmap_pre_post_sat (result_data = est_and_p_poly_unsat, overall_title = "Poly unsaturated")
```

## Change correlations

```{r}
# Function to prepare data
prepare_and_combine_data <- function(lipidomicsData, pre_post_cols, mirageData, lipidclass, saturation_col) {
  
# Filter lipidomics data
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, all_of(saturation_col))

  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = all_of(saturation_col), names_prefix = "proportion_of_") %>%
    relocate(id, .before = everything()) # Moves id to front

  # Calculate delta value
  lipidomics_wide$pp_change <- (lipidomics_wide$proportion_of_Post - lipidomics_wide$proportion_of_Pre) * 100
  
  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")
  
    # Loop through all lists
    for (j in 1:length(pre_post_cols)){
      for (g in 1:length (pre_post_cols[[j]])){
      pre_col <- pre_post_cols[[j]][[g]][1]
      post_col <- pre_post_cols[[j]][[g]][2]
      delta_col_name <- paste0(sub("_pre", "", pre_col), "_ch")
    
    # Calculate deltas
    combined_df <- combined_df %>%
      mutate(!!sym(delta_col_name) := as.numeric(.[[post_col]]) - as.numeric(.[[pre_col]]))
      }
      }
# }
  # Convert specified columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))
  
return(combined_df)
}

################### STATISTICS

# Define a function to compute correlations of change
correlation_of_change <- function(correlation_df, lipidomicsData, mirage_data_long_ch, mirage_variables_of_interest, lipidclass, saturation_type) {

# Define lipidname
  lipidName <- lipidclass
  
# Define lipid unit
  lipid_unit <- "pp_change"
  
  # Only run code if correlation df is not NA.
  # If, Na, assign NA values to all correlation results
  if (sum( !is.na(correlation_df[[lipid_unit]])) < analysis_cutoff){
    
       # Assign NA to all results
  correlation_results <- data.frame(
    lipid = lipidName,
    test_against = NA,
    pearson_r_all = NA,
    pearson_p_all = NA,
    spearman_rho_all = NA,
    spearman_p_all = NA,
    mixed_cor_all = NA,
    mixed_p_all = NA,
    pearson_r_HED = NA,
    pearson_p_HED = NA,
    spearman_rho_HED = NA,
    spearman_p_HED = NA,
    pearson_r_DIWL = NA,
    pearson_p_DIWL = NA,
    spearman_rho_DIWL = NA,
    spearman_p_DIWL = NA,
    pearson_r_WLEX = NA,
    pearson_p_WLEX = NA,
    spearman_rho_WLEX = NA,
    spearman_p_WLEX = NA
  )
  } else {
      
   # Initialize an empty data frame to store correlation results
  correlation_results <- data.frame(
    lipid = character(),
    test_against = character(),
    pearson_r_all = numeric(),
    pearson_p_all = numeric(),
    spearman_rho_all = numeric(),
    spearman_p_all = numeric(),
    mixed_cor_all = numeric(),
    mixed_p_all = numeric(),
    pearson_r_HED = numeric(),
    pearson_p_HED = numeric(),
    spearman_rho_HED = numeric(),
    spearman_p_HED = numeric(),
    pearson_r_DIWL = numeric(),
    pearson_p_DIWL = numeric(),
    spearman_rho_DIWL = numeric(),
    spearman_p_DIWL = numeric(),
    pearson_r_WLEX = numeric(),
    pearson_p_WLEX = numeric(),
    spearman_rho_WLEX = numeric(),
    spearman_p_WLEX = numeric()
  )
  
  # Loop over every mirage variables of interest
    for (j in 1:length(mirage_variables_of_interest)){
      for (g in 1:length (mirage_variables_of_interest[[j]])){
        test_against_name <- mirage_variables_of_interest[[j]][[g]][[1]]
        test_against_name_clean <- sub("_pre$", "", test_against_name)
        test_against_name <- sub("pre$", "ch", test_against_name)
        

    # Add new row to output df
    correlation_results <- add_row(correlation_results)

    # Identify the index of the current row
    current_row_index <- nrow(correlation_results)

    # Assign lipid name and test against to last row
    correlation_results$lipid[current_row_index] <- lipidName
    correlation_results$test_against[current_row_index] <- test_against_name
      
    # Perform Pearson and Spearman correlations for all data
    result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
    result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)

    # Assign results the the results df
    correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
    correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
    correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
    correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p

    # Calculate correlations for each group
    for (current_group in unique(correlation_df$group)) {
      # Filter the dataframe for the current group
      correlation_df_group <- filter(correlation_df, group == current_group)

      # Perform Pearson and Spearman correlations for the current group
      result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
      result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)

      # Dynamic assignment of results based on the current group
      pearson_r_col <- paste0("pearson_r_", current_group)
      pearson_p_col <- paste0("pearson_p_", current_group)
      spearman_rho_col <- paste0("spearman_rho_", current_group)
      spearman_p_col <- paste0("spearman_p_", current_group)

      correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
      correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
      correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
      correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
    }

    ### Below transformation to mixed model compatible format. Model is not run, as it does not work as intended, but structure may be relevant for future analysis.
    # Merge this transformed subset with 'lipidomicsData' based on 'id' and 'time'
    merged_data <- left_join(lipidomicsData, mirage_data_long_ch, by = c("id", "time"))

    # Prepare lipidomics data
    merged_data_filtered <- filter(merged_data, lipidClass == lipidclass)
    
    # Ensure 'time' and 'group' are factors
    merged_data_filtered$time <- as.factor(merged_data_filtered$time)
    merged_data_filtered$group <- as.factor(merged_data_filtered$group)

    # Re-level 'time' so 'Pre' is the reference level
    merged_data_filtered$time <- relevel(merged_data_filtered$time, ref = "Pre")

    # Relevel 'group' so 'HED' is the reference level
    merged_data_filtered$group <- relevel(merged_data_filtered$group, ref = "HED")

    correlation_results$mixed_cor_all[current_row_index] <- NA
    correlation_results$mixed_p_all[current_row_index] <- NA
    
  }
    }
  }

  return(correlation_results)
}


#################### Scatter plot
correlation_change_plot <- function(correlation_df, mirage_ch_vars, correlation_results, lipidclass, saturation_type) {
  
  # Make lipid name
    lipidName <- lipidclass
  
  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pp_change))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_ch_vars, function(category) {
    lapply(category, function(item) sub("_pre", "_ch", item[1]))
    }), recursive = FALSE), use.names = FALSE)

      plotVars <- c("pp_change", plotVars)

      # Add lipid variable to plotVars
      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars
      )
    
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }

    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)
      
      
      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
                                        x = Inf, y = Inf,
                                        label = paste0(
          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
          
          "All: Spearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
          #"\nHED: Pearson, p = ", formatC(correlation_row$pearson_p_HED, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_HED, format = "f", digits = 3),
          "\nHED: Spearman, p = ", formatC(correlation_row$spearman_p_HED, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_HED, format = "f", digits = 3),
          #"\nDIWL: Pearson, p = ", formatC(correlation_row$pearson_p_DIWL, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_DIWL, format = "f", digits = 3),
          "\nDIWL: Spearman, p = ", formatC(correlation_row$spearman_p_DIWL, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_DIWL, format = "f", digits = 3),
          #"\nWLEX: Pearson, p = ", formatC(correlation_row$pearson_p_WLEX, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_WLEX, format = "f", digits = 3),
          "\nWLEX: Spearman, p = ", formatC(correlation_row$spearman_p_WLEX, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_WLEX, format = "f", digits = 3),
          "\n*****p-values are not adjusted*****"
        ),
        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }

    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }

    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }

    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }

    savePath <- paste0(getwd(), "/outputs/saturation/change, correlations/scatter/", saturation_type, "/")
    
  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )

  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
}


#################### RUN FUNCTION
# intialize empty list
correlation_values_ch_saturation_list <- list()

######## IN LOOP
for (saturation_type in c("sat_proportion", "unsat_proportion", "unsat_mono_proportion", "unsat_poly_proportion")){

    # Initialize the dataframe to be able to store as saturation_type
  correlation_values_ch_saturation <- data.frame()
  
 #Loop over each lipid class and make plots
 for (lipid_class in unique_lipid_classes[unique_lipid_classes != c("PC.PE", "Cer ratio")]) {
   print( paste0("Analysing ",lipid_class, " - ", saturation_type, "..."))
   
   # Organize data
   correlation_df <- prepare_and_combine_data(
     lipidomicsData = lipidomicsDF_saturation,
     pre_post_cols = mirage_ch_vars,
     mirageData = mirage_data,
     lipidclass = lipid_class,
     saturation_col = saturation_type)
 
   # Calculate correlations for changes
  correlation_values_ch_saturation <- rbind(correlation_values_ch_saturation, correlation_of_change(
  correlation_df = correlation_df,
  lipidomicsData = lipidomicsDF_saturation,
  mirage_data_long_ch = mirage_data_long_ch,
  mirage_variables_of_interest = mirage_ch_vars,
  lipidclass = lipid_class))
  
  # Store the dataframe in the list under a dynamically named key
  correlation_values_ch_saturation_list[[saturation_type]] <- correlation_values_ch_saturation
   
 ## Plot data
   correlation_change_plot(
     correlation_df = correlation_df,
     mirage_ch_vars = mirage_ch_vars,
     correlation_results = correlation_values_ch_saturation,
     lipidclass = lipid_class,
     saturation_type = saturation_type

   )
 }}
```

### Heatmap

```{r}
heatmap_changes_saturation <- function (saturation_type, overall_title){
  
  
####### Data preparation
#Gather the Spearman p-value columns
long_format_p_adj.non <- correlation_values_ch_saturation_list[[saturation_type]] %>% 
  select(all_of(c("lipid", "test_against", "spearman_p_all"))) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")


#Gather the Spearman rho columns
long_format_cor <- correlation_values_ch_saturation_list[[saturation_type]] %>%
  select(all_of(c("lipid", "test_against", "spearman_rho_all"))) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")


# Capitalize all to ALL
long_format_p_adj.non$spearman_type <- gsub("all", "ALL", long_format_p_adj.non$spearman_type)
long_format_cor$spearman_type <- gsub("all", "ALL", long_format_cor$spearman_type)

# Remove Na rows based on NA in correlation
long_format_cor <- long_format_cor %>%
  filter(!is.na(rho_value))

# Use the 'lipid' values to filter long_format_p_adj.non
long_format_p_adj.non <- long_format_p_adj.non %>%
  filter(lipid  %in% long_format_cor$lipid)

# Adjust p-values by group
long_format_p_adj.gr <- long_format_p_adj.non %>%
  group_by(test_against, spearman_type) %>%
  mutate(p_value = p.adjust(p_value, method = "BH"))%>%
  ungroup()

# adjust p-values by group and lipidClass
long_format_p_adj.gr.class <- long_format_p_adj.non %>%
  mutate(lipidClass = sub("^(\\S+)\\s.*$", "\\1", lipid)) %>%
  group_by(test_against, spearman_type, lipidClass) %>%
  mutate(p_value = p.adjust(p_value, method = "BH")) %>%
  ungroup()


######### PLOT HEATMAP ##########
heatmap_changes_sat <- function(test_against_input, save_name){
  
# Group lipidclasses to make multiple, clean heatmaps
lipids_groups <- list(
  gr_all = c("TAG", "1,2-DG", "1,3-DG", "AC", "PC", "PC.PE ratio", "PE", "SPM", "SPH", "Cer", "dhCer", "GluCer", "LacCer", "GalCer", "LPC", "LPE", "LPG", "LPI", "LPS", "PA", "PS", "PG", "PI")
)

# Define function to filter and sort lipids based on group names
filter_lipid_group_base <- function(data_frame, lipid_group) {
  # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  # Sort the data_frame by lipid column
  sorted_data_frame <- data_frame[order(data_frame$lipid), ]
  # Filter based on the pattern and return the sorted & filtered data frame
  sorted_filtered_data_frame <- sorted_data_frame[grepl(pattern, sorted_data_frame$lipid), ]
  return(sorted_filtered_data_frame)
}

# Select specific test against
long_format_p_adj_selected.non <- long_format_p_adj.non[long_format_p_adj.non$test_against %in% test_against_input,]
long_format_p_adj_selected.gr <- long_format_p_adj.gr[long_format_p_adj.gr$test_against %in% test_against_input,]
long_format_p_adj_selected.gr.class <- long_format_p_adj.gr.class[long_format_p_adj.gr.class$test_against %in% test_against_input,]

long_format_corr_selected <- long_format_cor[long_format_cor$test_against %in% test_against_input,] 

# Apply the filter function to each group and store the results in a lists
# p-values
long_format_p_adj_groups.non <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.non)
long_format_p_adj_groups.gr <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr)
long_format_p_adj_groups.all <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr.class)
# correlations
long_format_corr_groups <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_corr_selected)


# Function to create 'unique_test_against' column for p-value df
mutate_unique_column_p <- function(data_frame) {
  data_frame %>%
    mutate(unique_test_against = paste0(sub("spearman_p_", "", spearman_type), "_", test_against))
}

# Adjust the function for correlation df
mutate_unique_column_corr <- function(data_frame) {
  data_frame %>%
    mutate(unique_test_against = paste0(sub("spearman_rho_", "", spearman_type), "_", test_against))
}

# Apply the mutation function to each group's data frames for p-values
long_format_p_adj_groups.non <- lapply(long_format_p_adj_groups.non, mutate_unique_column_p)
long_format_p_adj_groups.gr <- lapply(long_format_p_adj_groups.gr, mutate_unique_column_p)
long_format_p_adj_groups.all <- lapply(long_format_p_adj_groups.all, mutate_unique_column_p)

# Apply the mutation function to each group's data frames for correlations
long_format_corr_groups <- lapply(long_format_corr_groups, mutate_unique_column_corr)


# Function to perform negative log10 transformation and remove p_value column
transform_p_values <- function(df) {
  df %>%
    mutate(p_log10 = -log10(p_value)) %>%
    select(-p_value)
}

# Apply the transformation to each list
long_format_p_adj_log10.non <- lapply(long_format_p_adj_groups.non, transform_p_values)
long_format_p_adj_log10.gr <- lapply(long_format_p_adj_groups.gr, transform_p_values)
long_format_p_adj_log10.all <- lapply(long_format_p_adj_groups.all, transform_p_values)


# Define a function to spread the data and convert it to a matrix
spread_and_convert_matrix <- function(df, unitName) {
  result_matrix <- df %>%
    select(lipid, unique_test_against, all_of(unitName)) %>%
    pivot_wider(names_from = unique_test_against, 
                values_from = unitName, 
                values_fill = setNames(list(NA), unitName)) %>%
    column_to_rownames(var = "lipid") %>%
    as.matrix()
  return(result_matrix)
}



# Apply the function to each list
matrices_p_adj_non <- lapply(long_format_p_adj_groups.non, function(x) spread_and_convert_matrix(x, "p_value"))
matrices_p_adj_gr <- lapply(long_format_p_adj_groups.gr, function(x) spread_and_convert_matrix(x, "p_value"))
matrices_p_adj_all <- lapply(long_format_p_adj_groups.all, function(x) spread_and_convert_matrix(x, "p_value"))
# To correlation values
matrices_rho <- lapply(long_format_corr_groups, function(x) spread_and_convert_matrix(x, "rho_value"))

#### Should return a double - not a list when indexed like this [[1]]

generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims) {
  # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
# Extract test_against by removing the first part (treatment group) and the first underscore
# This joins back the remaining parts to form the full 'test_against' label
colTitles <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) paste(x[-1], collapse = "_"))
colTitles <- unique(colTitles)
  
  
# Modify the column names to only show the group
colnames(hm_matrix) <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) {
  # Concatenate the first part with the first four letters of the second part and "..."
  paste0(x[1], "", substr(x[2], 1, 0), "")
})


  Heatmap(hm_matrix,
          name = "rho", # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 11), # Change font size of row labels
          column_split = rep(1:(ncol(hm_matrix) / 1), each = 1), # Splits the columns and names them
          column_title = colTitles, # Custom titles for each split
          column_title_rot = 45,
          column_names_rot = 0, # Rotate column names to 0 degrees (horizontal)
          column_names_gp = gpar(col = "white", fontsize = 0), # Make column names invisible
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 8, fontface = "bold"),
          
          #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
      
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                  if (p_val_matrix[i, j] < pLims$p1) {
                      grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p2) {
                      grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p3) {
                      grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  }
              }
          })
}

# Define color map for heatmap
color_mapping <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
hm <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)) {
  # Generate heatmap and store it in the list
  hm[[i]] <- generate_heatmap(matrices_rho[[i]], matrices_p_adj_gr[[i]], color_mapping, p_value_limits)
}

# Define the path and name of your PDF file
pdf_path <- paste0(getwd(), "/outputs/saturation/change, correlations/heatmap/", saturation_type, "/",save_name, ".pdf")

# Open a PDF device
pdf(pdf_path, width = 8, height = 10)

# Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
for (i in 1:length (hm)){
  draw(hm[[i]], padding = unit(c(0, 0, 10, 0), "mm"))
  
  # Add a common title
grid.text(overall_title, x = unit(0.5, "npc"), y = unit(0.98, "npc"), 
          gp = gpar(fontsize = 14, fontface = "bold"))
}
dev.off()
}

# Loop over every group within the compositions
    for (i in seq_along(mirage_ch_vars)) {
        # Print the name of the current list being processed
        list_name <- names(mirage_ch_vars)[i]
        print(paste("Processing list:", list_name))
    
     test_against_input <- unlist(lapply(mirage_ch_vars[[i]], function(sublist) {
            # Check if the sublist is long enough to have at least the first element
            if(length(sublist) >= 1) {
                # Replace '_pre' with '_ch' in the first element
                return(gsub("_pre", "_ch", sublist[1]))
            }}))
      heatmap_changes_sat(test_against_input = test_against_input, save_name = list_name)
     }
}

######## Run functions
heatmap_changes_saturation(
  saturation_type = "sat_proportion",
  overall_title = "Correlations based on changes: Saturated lipids")

heatmap_changes_saturation(
  saturation_type = "unsat_proportion",
  overall_title = "Correlations based on changes: Unsaturated lipids")

heatmap_changes_saturation(
  saturation_type = "unsat_mono_proportion",
  overall_title = "Correlations based on changes: Mono unsaturated lipids")

heatmap_changes_saturation(
  saturation_type = "unsat_poly_proportion",
  overall_title = "Correlations based on changes: Poly unsaturated lipids")
```

## CrossSection analysis

```{r}
# run function test
# Function to prepare data
prepare_and_combine_crossSection_sat <- function(lipidomicsData, mirageData, lipidclass, sat_type) {
  
  # Filter and prepare lipidomics data
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
  
  # Select columns of interest
  lipidomics_filtered <- lipidomics_selected %>%
    select( all_of( c("id", "group", "time", "lipidClass", sat_type)))

  # Pivot to wide format
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = sat_type, names_prefix = "lipid_percent_") %>%
    relocate(id, .before = everything()) # Moves id to front
  

  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")

  # Convert certain columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))
  
      return(combined_df)
}


################ SATISTICS ################

# Define a function to compute correlations of change
correlation_cross_sectional_sat <- function(correlation_df, lipidomicsDF, mirage_variables_of_interest, lipidclass, sat_type) {

 # Determine the lipid name based on the presence of lipid composition   

    lipidName <- lipidclass
  
  # Make Na if too few values determined from prepare data function
 
    if (sum( !is.na(correlation_df$lipid_percent_Pre)) < analysis_cutoff)
    {
      correlation_results <- data.frame(
    lipid = lipidName,
    test_against = NA,
    pearson_r_all = NA,
    pearson_p_all = NA,
    spearman_rho_all = NA,
    spearman_p_all = NA,
    pearson_r_HED = NA,
    pearson_p_HED = NA,
    spearman_rho_HED = NA,
    spearman_p_HED = NA,
    pearson_r_DIWL = NA,
    pearson_p_DIWL = NA,
    spearman_rho_DIWL = NA,
    spearman_p_DIWL = NA,
    pearson_r_WLEX = NA,
    pearson_p_WLEX = NA,
    spearman_rho_WLEX = NA,
    spearman_p_WLEX = NA
  )
  } else {
  
    # Initialize an empty data frame to store correlation results
  correlation_results <- data.frame(
    lipid = character(),
    test_against = character(),
    pearson_r_all = numeric(),
    pearson_p_all = numeric(),
    spearman_rho_all = numeric(),
    spearman_p_all = numeric(),
    pearson_r_HED = numeric(),
    pearson_p_HED = numeric(),
    spearman_rho_HED = numeric(),
    spearman_p_HED = numeric(),
    pearson_r_DIWL = numeric(),
    pearson_p_DIWL = numeric(),
    spearman_rho_DIWL = numeric(),
    spearman_p_DIWL = numeric(),
    pearson_r_WLEX = numeric(),
    pearson_p_WLEX = numeric(),
    spearman_rho_WLEX = numeric(),
    spearman_p_WLEX = numeric()
  )
  
  # Loop over every mirage variables of interest
  for (i in seq_along(mirage_variables_of_interest)) {
    for (j in seq_along(mirage_variables_of_interest[[i]])){
    
      # Manipulate current variable name
      test_against_name <- mirage_variables_of_interest[[i]][[j]][1]
      test_against_name_clean <- sub("_pre$", "", test_against_name)

      # Add new row to output df
      correlation_results <- add_row(correlation_results)
  
      # Identify the index of current row to be able to append data to it
      current_row_index <- nrow(correlation_results)
  
      # Assign lipid name and test against to last row
      correlation_results$lipid[current_row_index] <- lipidName
      correlation_results$test_against[current_row_index] <- test_against_name
  
      # Lipid unit
    lipid_unit <- "lipid_percent_Pre"

      
      # Perform Pearson and Spearman correlations for all data
      result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
      result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
  
  
      # Assign results the the results df
      correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
      correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
      correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
      correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p
  
      # Calculate correlations for each group
      for (current_group in unique(correlation_df$group)) {
        # Filter the dataframe for the current group
        correlation_df_group <- filter(correlation_df, group == current_group)
  
  
        # Perform Pearson and Spearman correlations for the current group
        result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
        result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
  
        # Dynamic assignment of results based on the current group
        pearson_r_col <- paste0("pearson_r_", current_group)
        pearson_p_col <- paste0("pearson_p_", current_group)
        spearman_rho_col <- paste0("spearman_rho_", current_group)
        spearman_p_col <- paste0("spearman_p_", current_group)
  
        correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
        correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
        correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
        correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
    }
  }
  }
  }
  return(correlation_results)
}



####### Scatter plot #######

correlation_crossSectional_plot <- function(correlation_df, mirage_crossSectional_vars, correlation_results, lipidclass, sat_type) {
  # Make lipid name
    lipidName <- lipidclass
    
  # Only plot if there's data to plot
      if (sum( !is.na(correlation_df$lipid_percent_Pre)) >= analysis_cutoff)
    {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_crossSectional_vars, function(category) {
    lapply(category, function(item) item[1])
    }), recursive = FALSE), use.names = FALSE)
    
    # If lipidcomposition is null, then only plot class
    
    # Filter and prepare lipidomics data
    # Add lipid variable to plotVars
      plotVars <- c("lipid_percent_Pre", plotVars)

      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars
      )

      
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }

    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)

      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
        x = Inf, y = Inf,
        label = paste0(
          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
         # ", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
          "\nSpearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
          ", rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
          "\n***** Non-adjusted *****"
        ),
        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }

    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }

    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }


    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }

  savePath <- paste0(getwd(), "/outputs/saturation/cross section/scatter/", sat_type, "/")
    
  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )

  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
  
}

```

### Run functions

```{r}
#Run functions

# Initialize list to store data  
  correlation_values_crossSection_saturation_list <- list()
  
  ######## IN LOOP
for (sat_type in c("sat_proportion", "unsat_proportion", "unsat_mono_proportion", "unsat_poly_proportion")){

    # Initialize the dataframe to be able to store as saturation_type
  corrrelation_results_crossSection_sat <- data.frame()
  
 #Loop over each lipid class and make plots
 for (lipid_class in unique_lipid_classes[unique_lipid_classes != c("PC.PE", "Cer ratio")]) {
   
   print( paste0( "Analysing ", lipid_class, " - ", sat_type, "..."))
   
   # Organize data
  correlation_crossSection_df <- prepare_and_combine_crossSection_sat(
    lipidomicsData = lipidomicsDF_saturation,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    sat_type = sat_type)
 
   # Calculate correlations for changes
corrrelation_results_crossSection_sat <- rbind(corrrelation_results_crossSection_sat, correlation_cross_sectional_sat(
  correlation_df = correlation_crossSection_df,
  lipidomicsDF = lipidomicsDF_saturation,
  mirage_variables_of_interest = mirage_crossSectional_vars,
  lipidclass = lipid_class,
  sat_type = sat_type))

  # Store the dataframe in the list under a dynamically named key
  correlation_values_crossSection_saturation_list[[sat_type]] <- corrrelation_results_crossSection_sat
   
  # Plot data
    correlation_crossSectional_plot(
    correlation_df = correlation_crossSection_df,
    mirage_crossSectional_vars = mirage_crossSectional_vars,
    correlation_results = corrrelation_results_crossSection_sat,
    lipidclass = lipid_class,
    sat_type = sat_type)
}}
```

### volcano plot

```{r}
volcano_crossSection <- function(input_vars, save_sub_path, correlation_results, plot_title, save_folder){

# Remove NA rows
correlation_results <- correlation_results[!is.na(correlation_results$spearman_rho_all), ]

# Select columns: Rho and p-value
vulc_data_crossSection <- correlation_results %>% 
  select("lipid", "test_against", "spearman_rho_all", "spearman_p_all")
  
# Filter rows where 'test_against' column values are in 'input_vars'
vulc_data_crossSection <- vulc_data_crossSection[vulc_data_crossSection$test_against %in% input_vars, ]

# Adjust the p-value column based test_against.
vulc_data_crossSection <- vulc_data_crossSection %>%
    group_by(test_against) %>%
    mutate(across("spearman_p_all", ~ p.adjust(.x, method = "BH"), .names = "p_value")) %>%
    ungroup()

# Make a identifier column that combines lipid and test_against
vulc_data_crossSection$identifier <- paste0(vulc_data_crossSection$lipid, " ~ ", vulc_data_crossSection$test_against)


### Plot settings
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_data_crossSection$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)

### Create plot
vulc_plot <- ggplot(vulc_data_crossSection, aes(x = spearman_rho_all, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", linewidth = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12), guide = FALSE) + # TRUE for significant, FALSE for not
  geom_text_repel(aes(label = ifelse(p_value < 0.06 & abs(spearman_rho_all) > threshold_rho, identifier, "")),
                  box.padding = .3, point.padding = .3,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  xlim(-1,1) +
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) + # Hide the alpha legend and fix the color legend
  labs(title = paste0("Correlations at baseline: ", plot_title, " - ", save_sub_path), x = "Spearman rho", y = "-log10 P-value")+
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))
1
    # Save path
  save_path <- paste0( getwd(), "/outputs/saturation/cross section/volcano", "/", save_folder,"/" ,save_sub_path, ".jpeg")
    
# Save the plot
ggsave(save_path , plot = vulc_plot, width = 12, height = 8, dpi = 400)
}

# Run function

# Loop through each main category in mirage_crossSection_vars
for (i in seq_along(mirage_crossSectional_vars)) {
    # Print the name of the current list being processed
    list_name <- names(mirage_crossSectional_vars)[i]
    print(paste("Processing list:", list_name))

    # Use lapply to iterate over each sublist in the current category
    names_to_use <- unlist(lapply(mirage_crossSectional_vars[[i]], function(sublist) {
        # Check if the sublist is long enough to have at least the first element
        if(length(sublist) >= 1) {
            # Replace '_pre' with '_ch' in the first element
            return( sublist[1])
        } else {
            return(NA)  # Return NA if the sublist does not have at least one element
        }
        }))
    
         volcano_crossSection(input_vars = names_to_use,
                              save_sub_path = list_name,
                              correlation_results = correlation_values_crossSection_saturation_list$sat_proportion,
                              plot_title = "saturated proportion",
                              save_folder = "saturated")
                  
         volcano_crossSection(input_vars = names_to_use,
                              save_sub_path = list_name,
                              correlation_results = correlation_values_crossSection_saturation_list$unsat_proportion,
                              plot_title = "unsaturated proportion",
                              save_folder = "unsaturated")
         
         
         volcano_crossSection(input_vars = names_to_use,
                              save_sub_path = list_name,
                              correlation_results = correlation_values_crossSection_saturation_list$unsat_mono_proportion,
                              plot_title = "mono unsaturated proportion",
                              save_folder = "mono unsaturated")
         
         
         volcano_crossSection(input_vars = names_to_use,
                              save_sub_path = list_name,
                              correlation_results = correlation_values_crossSection_saturation_list$unsat_poly_proportion,
                              plot_title = "poly unsaturated proportion",
                              save_folder = "poly unsaturated")
}

```

# Mirage pre-post analysis w plot

```{r}
## Make function for the analysis
mirage_analysis_and_plot <- function(endpoint_variable, y_label, save_folder){
  
# Turn MIRAGE data into long format to be able to plot data
# Combine all variables of interest
subset_variables <- c("id", "group", "gender", endpoint_variable)

# Rename the endpoint variable to match the name in long format 
endpoint_variable <- gsub("_pre", "", endpoint_variable[1])

# Subset 'mirage_data' to include only the variables of interest
mirage_subset <- mirage_data[, subset_variables]

# Transform 'mirage_data_subset' to long format
mirage_plot_long <- pivot_longer(
  mirage_subset,
  cols = -c(id, group, gender),  # exclude cols from the pivot
  names_to = c(".value", "time"),
  names_pattern = "(.+)_(pre|post)"
)

### Make a column called in_lipidomics to filter out values that are present in that dataset
# Make id columns strings to be able to search
mirage_plot_long$id <- as.character(mirage_plot_long$id)
lipidomicsDF$id <- as.character(lipidomicsDF$id)

# Create the new column 'in_lipidomics' based on 'id' existence in lipidomicsDF
mirage_plot_long <- mirage_plot_long %>%
  mutate(in_lipidomics = if_else(id %in% lipidomicsDF$id, TRUE, FALSE))


# Adjust the 'time' column in 'mirage_data_long_ch' to match 'Pre' and 'Post'
mirage_plot_long <- mirage_plot_long %>%
  mutate(time = case_when(
    time == "pre" ~ "Pre",
    time == "post" ~ "Post",
    TRUE ~ time # Keeps the original value if it's neither 'pre' nor 'post'
  ))


##### MIXED MODEL

mirage_lmer <- function(modelData, endpoint_variable){
# Writing out formula allows dynamic naming
    model_formula <- as.formula(paste(
      endpoint_variable,
      "~ time * group +
      (1 | id)"))

      model <- lmer(model_formula,
                    data = modelData,
                    na.action = na.exclude)
      
      # Estimated marginal of means to get out slope and between groups statistics
      emm <- emmeans(model, ~ time * group)

      # Contrasts for differences in slopes between groups
      model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")

      model.slope.contrasts.results <- summary(model.slope.contrasts)

      # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
      model.slope.contrasts.results <- model.slope.contrasts.results %>%
        mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
        select(contrast, estimate, SE, df, t.ratio, p.value)

      # Pre, Post between group comparisons
      prepost.contrasts <- pairs(emm, adjust = "none")

      # Get results
      prepost.contrasts.results <- summary(prepost.contrasts)

      return(list(enpoint = as.character(endpoint_variable), slope_results = model.slope.contrasts.results, prepost_results = prepost.contrasts.results))
}

# Run function
lmer_results.mirage <- mirage_lmer(mirage_plot_long, endpoint_variable)
lmer_results.lipidomics <- mirage_lmer(mirage_plot_long[mirage_plot_long$in_lipidomics==TRUE,], endpoint_variable)

##### PLOT DATA

# Function to extract p-value based on contrast
extract_p_value <- function(results, contrast_name) {
  results$p.value[results$contrast == contrast_name]
}

# In lipidomics data
p_value.hed <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post HED - Pre HED")
p_value.diwl <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post DIWL - Pre DIWL")
p_value.wlex <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post WLEX - Pre WLEX")
p_value_slope.hed_diwl <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : DIWL - HED")
p_value_slope.diwl_wlex <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : DIWL - WLEX")
p_value_slope.wlex_hed <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : HED - WLEX")
# For whole mirage data
p_value.hed_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post HED - Pre HED")
p_value.diwl_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post DIWL - Pre DIWL")
p_value.wlex_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post WLEX - Pre WLEX")
p_value_slope.hed_diwl_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : DIWL - HED")
p_value_slope.diwl_wlex_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : DIWL - WLEX")
p_value_slope.wlex_hed_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : HED - WLEX")


# Calculate the count (n) for each group and time
# lipidomics data
n_hed_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "HED" & mirage_plot_long$time == "Pre"]))
n_hed_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "HED" & mirage_plot_long$time == "Post"]))
n_diwl_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Pre"]))
n_diwl_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Post"]))
n_wlex_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Pre"]))
n_wlex_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Post"]))

# mirage data
n_hed_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "HED" & mirage_plot_long$time == "Pre"]))
n_hed_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "HED" & mirage_plot_long$time == "Post"]))
n_diwl_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Pre"]))
n_diwl_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Post"]))
n_wlex_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Pre"]))
n_wlex_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Post"]))

  
# Calculate both means for lipidomics ids and mirage ids
mean_data <- mirage_plot_long %>%
  group_by(group, time) %>%
  summarise(
    mean_lipidomics = mean(ifelse(in_lipidomics == TRUE, .data[[endpoint_variable]], NA), na.rm = TRUE),
    mean_mirage = mean(.data[[endpoint_variable]], na.rm = TRUE),
    .groups = 'drop'
  )

# Generate labels with original and corrected p-values including n counts
annotation_hed <- paste0(
  "HED pre (n=", n_hed_pre, ") vs post (n=", n_hed_post,
  "), p = ", formatC(p_value.hed, format = "f", digits = 3), 
  "\n MIRAGE: pre (n=", n_hed_pre_mirage, ") vs post (n=", n_hed_post_mirage,
  "), p = ", formatC(p_value.hed_mirage, format = "f", digits = 3))

annotation_diwl <- paste0(
  "DIWL pre (n=", n_diwl_pre, ") vs post (n=", n_diwl_post, 
  "), p = ", formatC(p_value.diwl, format = "f", digits = 3), 
  "\n MIRAGE: pre (n=", n_diwl_pre_mirage, ") vs post (n=", n_diwl_post_mirage, 
  "), p = ", formatC(p_value.diwl_mirage, format = "f", digits = 3))

annotation_wlex <- paste0(
  "WLEX pre (n=", n_wlex_pre, ") vs post (n=", n_wlex_post, 
  "), p = ", formatC(p_value.wlex, format = "f", digits = 3), 
  "\n MIRAGE: pre (n=", n_wlex_pre_mirage, ") vs post (n=", n_wlex_post_mirage, 
  "), p = ", formatC(p_value.wlex_mirage, format = "f", digits = 3))


annotation_pvals_slope <- paste0(
  "Slope p-values: HED vs DIWL, p = ", formatC(p_value_slope.hed_diwl, format = "f", digits = 3),
  "       |    HED vs WLEX, p = ", formatC(p_value_slope.wlex_hed, format = "f", digits = 3),
  "       |    DIWL vs WLEX, p = ", formatC(p_value_slope.diwl_wlex, format = "f", digits = 3),
  "\n MIRAGE:         HED vs DIWL, p = ", formatC(p_value_slope.hed_diwl_mirage, format = "f", digits = 3),
  "       |    HED vs WLEX, p = ", formatC(p_value_slope.wlex_hed_mirage, format = "f", digits = 3),
  "       |    DIWL vs WLEX, p = ", formatC(p_value_slope.diwl_wlex_mirage, format = "f", digits = 3)
)

# Make the plot
plot <- ggplot(mirage_plot_long, aes(
  x = factor(interaction(group, time, sep = " "),
    levels = c(
      "HED Pre",
      "HED Post", 
      "DIWL Pre", 
      "DIWL Post", 
      "WLEX Pre", 
      "WLEX Post")),
  y = !!sym(endpoint_variable), group = interaction(id, group))) +
  
  # Lines for all, colored conditionally, alpha adjusted directly
  geom_line(aes(color = if_else(in_lipidomics == TRUE, "Lipidomics", "MIRAGE"), 
                alpha = if_else(in_lipidomics == TRUE, 1, 0.95)), 
            position = position_nudge(x = 0.03)) +
  
  # Points for all, colored conditionally, alpha adjusted directly
  geom_point(aes(color = if_else(in_lipidomics == TRUE, "Lipidomics", "MIRAGE"), 
                 alpha = if_else(in_lipidomics == TRUE, 1, 0.95)),  # Adjusted alpha for visibility
             position = position_nudge(x = 0.03)) +
  
  geom_boxplot(data = mirage_plot_long[mirage_plot_long$in_lipidomics == TRUE, ],
               aes(group = interaction(group, time)),
               width = 0.3, alpha = 0.2, outlier.shape = NA,
               position = position_dodge(width = 0.75), color = "black") +
  
  # Mean line lipidomics
  geom_line(data = mean_data, aes(x = interaction(group, time, sep = " "), y = mean_lipidomics, group = group), 
            color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
  
  # Mean line MIRAGE
  geom_line(data = mean_data, aes(x = interaction(group, time, sep = " "), y = mean_mirage, group = group), 
            color = "darkgrey", alpha = 0.95, linewidth = 1, position = position_nudge(x = 0.03)) +
  
  scale_color_manual(values = c("Lipidomics" = "black", "MIRAGE" = "darkgrey"), name = "Data") +
  
  labs(
    title = paste(endpoint_variable, "(p-vals not adj.)"),
    subtitle = annotation_pvals_slope,
    y = y_label,
    x = ""
  ) +
  guides(alpha = FALSE) + # Hide the alpha legend
  # Insert P-values pre post
 annotate("text", x = 1.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
           label = annotation_hed, size = 2.1, hjust = 0.5) +
  annotate("text", x = 3.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
           label = annotation_diwl, size = 2.1, hjust = 0.5) +
  annotate("text", x = 5.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
           label = annotation_wlex, size = 2.1, hjust = 0.5) +
  theme_minimal(base_size = 12) + # Start with a minimal theme
  theme(
    axis.title.x = element_blank(), 
    axis.text.x = element_text(angle = 45, hjust = 1), 
    legend.position = "right",
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"), # Bold and centered title
    plot.subtitle = element_text(hjust = 0.5, size = 8), # Smaller and centered subtitle
    legend.text = element_text(size = 6),
    legend.title = element_text(size = 6, hjust = 0.5), 
    panel.grid.major.x = element_blank(), 
    panel.grid.minor.x = element_blank(),
    plot.caption = element_text(size = 8)
  )

# Define the directory
dir_path <- paste0( getwd(), "/outputs/mirage/", save_folder)

# Create the directory if it does not exist
if (!dir.exists(dir_path)) {
  dir.create(dir_path, recursive = TRUE)
}

# Define the filename
filename <- file.path(dir_path, paste0(endpoint_variable, ".jpg"))

# Save the plot
ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)
 
 }


### Run function
# Loop through each named element of mirage_ch_vars
for (list_name in names(mirage_ch_vars)) {
  # Print the name of the list
  for (i in 1:length(mirage_ch_vars[[list_name]])) {
    mirage_analysis_and_plot(endpoint_variable=mirage_ch_vars[[list_name]][[i]][1:2], y_label=mirage_ch_vars[[list_name]][[i]][3], save_folder = list_name)
  }}
  



# endpoint_variable <- c("mpa_mins_day_pre", "mpa_mins_day_post")
# y_label <- expression("mins/day")





```

# Table 1 statistics

```{r}
# Filter mirage subjects included in this study
mirage_included <- mirage_data %>%
    filter(id %in% lipidomicsDF$id)

# Weight loss
summary(mirage_included[mirage_included$group=="WLEX","weight_post"] - mirage_included[mirage_included$group=="WLEX","weight_pre"])

# SD
sd(mirage_included[mirage_included$group == "WLEX",]$weight_post - 
   mirage_included[mirage_included$group == "WLEX",]$weight_pre)

#DIWL
summary(mirage_included[mirage_included$group=="DIWL","weight_post"] - mirage_included[mirage_included$group=="DIWL","weight_pre"])

# SD
sd(mirage_included[mirage_included$group == "DIWL",]$weight_post - 
   mirage_included[mirage_included$group == "DIWL",]$weight_pre)

#HED
summary(mirage_included[mirage_included$group=="HED","weight_post"] - mirage_included[mirage_included$group=="HED","weight_pre"])

# SD
sd(mirage_included[mirage_included$group == "HED",]$weight_post - 
   mirage_included[mirage_included$group == "HED",]$weight_pre)


### Physical acitivity
summary(mirage_included[mirage_included$group=="WLEX","daily_steps_steps_24hr_post"] - mirage_included[mirage_included$group=="WLEX","daily_steps_steps_24hr_pre"], na.rm = TRUE)

# SD
sd(mirage_included[mirage_included$group == "WLEX",]$daily_steps_steps_24hr_post - 
   mirage_included[mirage_included$group == "WLEX",]$daily_steps_steps_24hr_pre, na.rm = TRUE)

#DIWL
summary(mirage_included[mirage_included$group=="DIWL","daily_steps_steps_24hr_post"] - mirage_included[mirage_included$group=="DIWL","daily_steps_steps_24hr_pre"], na.rm = TRUE)

# SD
sd(mirage_included[mirage_included$group == "DIWL",]$daily_steps_steps_24hr_post - 
   mirage_included[mirage_included$group == "DIWL",]$daily_steps_steps_24hr_pre, na.rm = TRUE)

#HED
summary(mirage_included[mirage_included$group=="HED","daily_steps_steps_24hr_post"] - mirage_included[mirage_included$group=="HED","daily_steps_steps_24hr_pre"], na.rm = TRUE)

# SD
sd(mirage_included[mirage_included$group == "HED",]$daily_steps_steps_24hr_post - 
   mirage_included[mirage_included$group == "HED",]$daily_steps_steps_24hr_pre, na.rm = TRUE)
```

# Analysis based on changes

## Prepare data (function)

Function to prepare and merge data into wide format

Ouliers handling: pmol_mg imputed is used. For composition, only rows that are not outliers are fed to the functions, i.e. imputed col will be equal to the original column. For classes, imputed values are used to not get scewed class sums.

```{r}
# Function to prepare data
prepare_and_combine_data <- function(lipidomicsData, pre_post_cols, mirageData, lipidclass, lipidcomposition) {
   
# Filter and prepare lipidomics data
 if (is.null(lipidcomposition) || lipidcomposition == "ratio") {
  lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
} else {
   lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass, lipidComposition == lipidcomposition) 
}
  
  # Remove lipid composition within lipid class if fewer non-zero values than the analysis_cutoff. Only for lipidComposition. Add new col called to to_analyse in based on number of non_zero_rows
  non_zero_rows <- lipidomics_selected %>%
  filter(pmol_mg > 0)
  

  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, lipidComposition, pmol_mg_imp)

  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = pmol_mg_imp, names_prefix = "pmol_mg_") %>%
    relocate(id, .before = everything()) # Moves id to front
  
  # Calculate delta value
  lipidomics_wide$pmol_mg_ch <- lipidomics_wide$pmol_mg_Post - lipidomics_wide$pmol_mg_Pre

  # Adding a small constant to avoid log2(0) if there are zeros
pseudo_count <- 0.001
# Calculate log2 fold change directly within the dataset
lipidomics_wide <- lipidomics_wide %>%
  mutate(
    lipid_log2fold = if_else(
      is.na(pmol_mg_Post) | is.na(pmol_mg_Pre), 
      NA_real_,  # This ensures the result is NA where either pre or post is NA
      log2((pmol_mg_Post + pseudo_count) / (pmol_mg_Pre + pseudo_count))
    )
  )

# Remove Na rows
lipidomics_wide <- lipidomics_wide[!is.na(lipidomics_wide$pmol_mg_ch), ]

# Calculate the abs change and abs change for each ID, then add them back to the original dataframe
lipidomics_wide <- lipidomics_wide %>%
  group_by(id) %>%
  # Calculate sum of abs fold change for each ID
  mutate(lipid_log2fold_id_avg = mean(lipid_log2fold, na.rm = TRUE),
         # Calculate absolute change for each ID
         pmol_mg_ch_id = sum(pmol_mg_Post, na.rm = TRUE) - sum(pmol_mg_Pre, na.rm = TRUE),
         # Assign row number for each group to identify the first occurrence
         row_num = row_number()) %>%
  # Calculate log2fold change for each ID across all points
  mutate(lipid_log2fold_id = log2((sum(pmol_mg_Post, na.rm = TRUE) + pseudo_count) / 
                                   (sum(pmol_mg_Pre, na.rm = TRUE) + pseudo_count))) %>%
  ungroup() %>%
  # Only retain the calculated values for the first occurrence of each ID
  mutate(lipid_log2fold_id_avg = if_else(row_num == 1, lipid_log2fold_id_avg, NA_real_),
         pmol_mg_ch_id = if_else(row_num == 1, pmol_mg_ch_id, NA_real_),
         lipid_log2fold_id = if_else(row_num == 1, lipid_log2fold_id, NA_real_)) %>%
  # Remove the auxiliary row number column
  select(-row_num)
  
  
  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")
  
    # Loop through all lists
    for (j in 1:length(pre_post_cols)){
      for (g in 1:length (pre_post_cols[[j]])){
      pre_col <- pre_post_cols[[j]][[g]][1]
      post_col <- pre_post_cols[[j]][[g]][2]
      delta_col_name <- paste0(sub("_pre", "", pre_col), "_ch")
    
    # Calculate deltas
    combined_df <- combined_df %>%
      mutate(!!sym(delta_col_name) := as.numeric(.[[post_col]]) - as.numeric(.[[pre_col]]))
      }
      }
# }
  # Convert specified columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))

      # If lipid composition 
  if (!is.null(lipidcomposition) & nrow(non_zero_rows) < analysis_cutoff){
    combined_df$skipAnalysis <- TRUE
  }else{
        combined_df$skipAnalysis <- FALSE
    }
  
  return(combined_df)
}
```

## Statistics (function)

Function to get correlation between changes of defined parameters

```{r}
# Define a function to compute correlations of change
correlation_of_change <- function(correlation_df, lipidomicsDF, mirage_data_long_ch, mirage_variables_of_interest, lipidclass, lipidcomposition) {

# Determine the lipid name based on the presence of lipid composition
if (!is.null(lipidcomposition) && lipidcomposition != "ratio")  {
lipidName <- paste0(lipidclass, " ", lipidcomposition)
} else {
    lipidName <- lipidclass
}
  
  # Only run code if correlation df is not NA. If, Na, assign NA values to all correlation results
  if (correlation_df$skipAnalysis[[1]] == TRUE){
       # Assign NA to all results
  correlation_results <- data.frame(
    lipid = lipidName,
    test_against = NA,
    pearson_r_all = NA,
    pearson_p_all = NA,
    spearman_rho_all = NA,
    spearman_p_all = NA,
    mixed_cor_all = NA,
    mixed_p_all = NA,
    pearson_r_HED = NA,
    pearson_p_HED = NA,
    spearman_rho_HED = NA,
    spearman_p_HED = NA,
    pearson_r_DIWL = NA,
    pearson_p_DIWL = NA,
    spearman_rho_DIWL = NA,
    spearman_p_DIWL = NA,
    pearson_r_WLEX = NA,
    pearson_p_WLEX = NA,
    spearman_rho_WLEX = NA,
    spearman_p_WLEX = NA
  )
  } else {
      
   # Initialize an empty data frame to store correlation results
  correlation_results <- data.frame(
    lipid = character(),
    test_against = character(),
    pearson_r_all = numeric(),
    pearson_p_all = numeric(),
    spearman_rho_all = numeric(),
    spearman_p_all = numeric(),
    mixed_cor_all = numeric(),
    mixed_p_all = numeric(),
    pearson_r_HED = numeric(),
    pearson_p_HED = numeric(),
    spearman_rho_HED = numeric(),
    spearman_p_HED = numeric(),
    pearson_r_DIWL = numeric(),
    pearson_p_DIWL = numeric(),
    spearman_rho_DIWL = numeric(),
    spearman_p_DIWL = numeric(),
    pearson_r_WLEX = numeric(),
    pearson_p_WLEX = numeric(),
    spearman_rho_WLEX = numeric(),
    spearman_p_WLEX = numeric()
  )
  
  # Loop over every mirage variables of interest
    for (j in 1:length(mirage_variables_of_interest)){
      for (g in 1:length (mirage_variables_of_interest[[j]])){
        test_against_name <- mirage_variables_of_interest[[j]][[g]][[1]]
        test_against_name_clean <- sub("_pre$", "", test_against_name)
        test_against_name <- sub("pre$", "ch", test_against_name)
        

    # Add new row to output df
    correlation_results <- add_row(correlation_results)

    # Identify the index of the current row
    current_row_index <- nrow(correlation_results)

    # Assign lipid name and test against to last row
    correlation_results$lipid[current_row_index] <- lipidName
    correlation_results$test_against[current_row_index] <- test_against_name

    # Use pmol_mg_ch for composition within group. Use pmol_mg_ch for all compositions within class.
    if (is.null(lipidcomposition) || lipidcomposition != "ratio") {
      lipid_unit <- "pmol_mg_ch_id"
    } else {
      lipid_unit <- "pmol_mg_ch"
    }

    

    # Perform Pearson and Spearman correlations for all data
    result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
    result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)


    # Assign results the the results df
    correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
    correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
    correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
    correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p

    # Calculate correlations for each group
    for (current_group in unique(correlation_df$group)) {
      # Filter the dataframe for the current group
      correlation_df_group <- filter(correlation_df, group == current_group)

      # Perform Pearson and Spearman correlations for the current group
      result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
      result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)

      # Dynamic assignment of results based on the current group
      pearson_r_col <- paste0("pearson_r_", current_group)
      pearson_p_col <- paste0("pearson_p_", current_group)
      spearman_rho_col <- paste0("spearman_rho_", current_group)
      spearman_p_col <- paste0("spearman_p_", current_group)

      correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
      correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
      correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
      correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
    }

    # Merge this transformed subset with 'lipidomicsDF' based on 'id' and 'time'
    merged_data <- left_join(lipidomicsDF, mirage_data_long_ch, by = c("id", "time"))

    # Prepare lipidomics data
if (!is.null(lipidcomposition)){
      merged_data_filtered <- filter(merged_data, lipidClass == lipidclass, lipidComposition == lipidcomposition)
} else {
    merged_data_filtered <- filter(merged_data, lipidClass == lipidclass)
}
    

    # Ensure 'time' and 'group' are factors
    merged_data_filtered$time <- as.factor(merged_data_filtered$time)
    merged_data_filtered$group <- as.factor(merged_data_filtered$group)

    # Relevel 'time' so 'Pre' is the reference level
    merged_data_filtered$time <- relevel(merged_data_filtered$time, ref = "Pre")

    # Relevel 'group' so 'HED' is the reference level
    merged_data_filtered$group <- relevel(merged_data_filtered$group, ref = "HED")
    
      # Determine if lipidComposition can be a random effect
  if (!is.null(lipidcomposition) ||  length( unique(merged_data_filtered$lipidComposition)) < 2) {
        model_formula_str <- paste0(
          "pmol_mg ~ time * ", test_against_name_clean,
          " + (1|id)"
          )
  } else {
            model_formula_str <- paste0(
          "pmol_mg ~ time * ", test_against_name_clean,
          " + (1|id) + (1 + time | lipidComposition)"
          )
  }
    
    
    # Attempt to construct the formula, fit the model, and extract results
    tryCatch(
      {
  
        model_formula <- as.formula(model_formula_str)

        # Fit the mixed model to the filtered and merged data using the dynamic formula
        model <- lmer(model_formula, data = merged_data_filtered)

        # Model summary
        model_summary <- summary(model)

        # Extract p-value and correlation (assuming correlation here means the same as in the comment, which may be a typo)
        # Construct the Index String Dynamically
        index_string <- paste("timePost:", test_against_name_clean, sep = "")

        correlation_results$mixed_p_all[current_row_index] <- model_summary$coefficients[index_string, "Pr(>|t|)"]
        correlation_results$mixed_cor_all[current_row_index] <- model_summary$coefficients[index_string, "Estimate"]
      },
      error = function(e) {
        # Handle error
        cat("An error occurred: ", e$message, "\n")
      }
    )
  }
    }
  }
  return(correlation_results)
}
```

## Plot, scatter (function)

```{r}
correlation_change_plot <- function(correlation_df, mirage_ch_vars, correlation_results, savePath, lipidclass, lipidcomposition) {
  
  # Make lipid name
if (!is.null(lipidcomposition) && lipidcomposition != "ratio") {
lipidName <- paste0(lipidclass, " ", lipidcomposition)
} else {
    lipidName <- lipidclass
}
  
  
  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pmol_mg_ch))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_ch_vars, function(category) {
    lapply(category, function(item) sub("_pre", "_ch", item[1]))
    }), recursive = FALSE), use.names = FALSE)
    

    
    # If lipidcomposition is null, then only plot class
if (!is.null(lipidcomposition) && lipidcomposition != "ratio") {
    # Add lipid variable to plotVars
      plotVars <- c("pmol_mg_ch", plotVars)

      # Now use ggpairs on the renamed dataframe
      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars,
        lower = list(continuous = wrap("smooth", method = "none", se = FALSE))
      )
} else {
         # Add lipid variable to plotVars
      # Make plot with log2 fold change if only class is available
      plotVars <- c("pmol_mg_ch_id", plotVars)

      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars
      )
}
    
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }

    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)

      
      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
        x = Inf, y = Inf,
        label = paste0(
          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
          
          "All: Spearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
          #"\nHED: Pearson, p = ", formatC(correlation_row$pearson_p_HED, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_HED, format = "f", digits = 3),
          "\nHED: Spearman, p = ", formatC(correlation_row$spearman_p_HED, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_HED, format = "f", digits = 3),
          #"\nDIWL: Pearson, p = ", formatC(correlation_row$pearson_p_DIWL, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_DIWL, format = "f", digits = 3),
          "\nDIWL: Spearman, p = ", formatC(correlation_row$spearman_p_DIWL, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_DIWL, format = "f", digits = 3),
          #"\nWLEX: Pearson, p = ", formatC(correlation_row$pearson_p_WLEX, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_WLEX, format = "f", digits = 3),
          "\nWLEX: Spearman, p = ", formatC(correlation_row$spearman_p_WLEX, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_WLEX, format = "f", digits = 3),
          "\n*****p-values are not adjusted*****"
        ),
        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }


    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }

    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }

    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }

  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )

  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
}
```

## Run functions

```{r}
# Save folder for .jpg output files
savePathClassComp <- paste0(getwd(), "/outputs/correlations in changes/scatter composition/")
                            

savePathClass <- paste0(getwd(), "/outputs/correlations in changes/scatter class/")

# Initialize an empty data frame to hold all correlation values
correlation_values_ch_composition <- data.frame()
correlation_values_ch_class <- data.frame()

# Loop over each lipid composition
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
for (lipid_class in unique_lipid_classes[!unique_lipid_classes == "PC.PE"]) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    
    print( paste0 ("Analysing: ", lipid_class, " ", lipid_composition, "..."))
    # Organize data
    correlation_df <- prepare_and_combine_data(
      lipidomicsData = lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),],
      pre_post_cols = mirage_ch_vars,
      mirageData = mirage_data,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition
    )

    # Calculate correlations for changes
    correlation_values_ch_composition <- rbind(correlation_values_ch_composition, correlation_of_change(
      correlation_df,
      lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),],
      mirage_data_long_ch,
      mirage_ch_vars,
      lipid_class,
      lipid_composition))

   # Plot data - Comment out if to be used
   correlation_change_plot(
     correlation_df,
     mirage_ch_vars,
     correlation_values_ch_composition,
     savePathClassComp,
     lipid_class,
     lipid_composition
  )
  }
}

# Loop over each lipid class and make plots
for (lipid_class in unique_lipid_classes[!unique_lipid_classes == "Cer ratio"]) {
  print( paste0 ("Analysing lipid class: ", lipid_class, "..."))
  # Organize data
  correlation_df <- prepare_and_combine_data(
    lipidomicsData = lipidomicsDF,
    pre_post_cols = mirage_ch_vars,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    lipidcomposition = NULL
  )

  # Calculate correlations for changes
  correlation_values_ch_class <- rbind(correlation_values_ch_class,
                                       correlation_of_change(
    correlation_df,
    lipidomicsDF,
    mirage_data_long_ch,
    mirage_ch_vars,
    lipid_class,
    lipidcomposition = NULL))

# Plot data - un-comment if to be used again
 correlation_change_plot(
   correlation_df,
   mirage_ch_vars,
   correlation_values_ch_class,
   savePathClass,
   lipid_class,
   lipidcomposition = NULL
 )
}

## SAVE AND LOAD VARIABLES TO NOT HAVE TO RERUN ALL THE ANALYSIS
# Define the path to save/load folder
# save_variable_path <- paste0(getwd(), "/outputs/saved variables/")
# 
# # Specify filenames for each variable
# file_correlation_values_ch_composition <- paste0(save_variable_path, "correlation_values_ch_composition.rds")
# file_correlation_values_ch_class <- paste0(save_variable_path, "correlation_values_ch_class.rds")
# 
 # Save the variables
# saveRDS(correlation_values_ch_composition, file = file_correlation_values_ch_composition)
 #saveRDS(correlation_values_ch_class, file = file_correlation_values_ch_class)

# OR LOAD VARIABLES
# correlation_values_ch_composition <- readRDS(file = file_correlation_values_ch_composition)
# correlation_values_ch_class <- readRDS(file = file_correlation_values_ch_class)

```

## Heatmap & volcano plot

### Common data preparation

```{r}
#Gather the Spearman p-value columns
# For composition data
long_format_p_adj_comp <- correlation_values_ch_composition %>%
  select(lipid, test_against, spearman_p_all, spearman_p_HED, spearman_p_DIWL, spearman_p_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")

# For class data
long_format_p_adj_class <- correlation_values_ch_class %>% 
  select(lipid, test_against, spearman_p_all, spearman_p_HED, spearman_p_DIWL, spearman_p_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")

# Combine both into one data frame
long_format_p_adj.non <- rbind(long_format_p_adj_comp, long_format_p_adj_class)

#Gather the Spearman rho columns
# For composition
long_format_cor_comp <- correlation_values_ch_composition %>%
  select(lipid, test_against, spearman_rho_all, spearman_rho_HED, spearman_rho_DIWL, spearman_rho_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")

# For class
long_format_cor_class <- correlation_values_ch_class %>%
  select(lipid, test_against, spearman_rho_all, spearman_rho_HED, spearman_rho_DIWL, spearman_rho_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")

# Combine composition and class into one df
long_format_cor <- rbind(long_format_cor_comp, long_format_cor_class)

# Capitalize all to ALL
long_format_p_adj.non$spearman_type <- gsub("all", "ALL", long_format_p_adj.non$spearman_type)
long_format_cor$spearman_type <- gsub("all", "ALL", long_format_cor$spearman_type)

# Remove Na rows based on NA in correlation
long_format_cor <- long_format_cor %>%
  filter(!is.na(rho_value))

# Use the 'lipid' values to filter long_format_p_adj.non
long_format_p_adj.non <- long_format_p_adj.non %>%
  filter(lipid  %in% long_format_cor$lipid)

# Adjust p-values by group
long_format_p_adj.gr <- long_format_p_adj.non %>%
  group_by(test_against, spearman_type) %>%
  mutate(p_value = p.adjust(p_value, method = "BH"))%>%
  ungroup()

# adjust p-values by group and lipidClass
# First reintroduce lipidclass
long_format_p_adj.gr.class <- long_format_p_adj.non %>%
  mutate(lipidClass = sub("^(\\S+)\\s.*$", "\\1", lipid)) %>%
  group_by(test_against, spearman_type, lipidClass) %>%
  mutate(p_value = p.adjust(p_value, method = "BH")) %>%
  ungroup()
```

### volcano plot

```{r}
volcano_changes <- function(input_vars, save_sub_path, spearman_types_select, sub_folder){
### Join p-values adjusted for all lipid species and join with the rho values
  
# Filter rows where 'test_against' column values are in 'input_vars'
vulc.pvals <- long_format_p_adj.gr[long_format_p_adj.gr$test_against %in% input_vars, ]

# Filter out only the spearman groups specified
vulc.pvals <- vulc.pvals[sub("spearman_p_", "", vulc.pvals$spearman_type) %in% spearman_types_select, ]

vulc.pvals$spearman_type <- gsub("spearman_p_", "", vulc.pvals$spearman_type)

# Correlation df
vulc.cor <- long_format_cor[long_format_cor$test_against %in% input_vars, ]
# Filter out only the spearman groups specified
vulc.cor <- vulc.cor[sub("spearman_rho_", "", vulc.cor$spearman_type) %in% spearman_types_select, ]

vulc.cor$spearman_type <- gsub("spearman_rho_", "", vulc.cor$spearman_type)

# make into single dataframe
vulc_data <- vulc.cor %>%
  left_join(vulc.pvals, by = c("lipid", "test_against", "spearman_type"))

# Make a identifier column that combines lipid, test-against and Spearman_type
vulc_data$identifier <- paste0(vulc_data$lipid, " ~ ", vulc_data$test_against, " | ", vulc_data$spearman_type)

### Plot settings
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_data$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)


### Create plot
vulc_plot <- ggplot(vulc_data, aes(x = rho_value, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", linewidth = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) +
  theme_minimal() +
  labs(title = paste0("Correlation: ", save_sub_path, " within ", sub_folder),
       x = "Spearman rho", y = "-log10 P-value") +
  theme(plot.title = element_text(hjust = 0.5))+
   geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(rho_value) > threshold_rho, identifier, "")),
                  box.padding = 0.45, point.padding = 0.5, max.overlaps = 100,
                  size = 2, segment.color = 'grey50') +

  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) 

# Save the plot
save_path <- paste0(getwd(), "/outputs/correlations in changes/volcano/",sub_folder, "/", save_sub_path, ".jpg")

ggsave(save_path, plot = vulc_plot, width = 14, height = 10, dpi = 400)
}

# Define variables to go into functions
spearman_types_select.all <- c("ALL") # use ALL, HED, DIWL and WLEX
spearman_types_select.groups <- c("ALL", "HED", "DIWL", "WLEX") # use ALL, HED, DIWL, WLEX

# Loop through each main category in mirage_ch_vars
for (i in seq_along(mirage_ch_vars)) {
    # Print the name of the current list being processed
    list_name <- names(mirage_ch_vars)[i]
    print(paste("Processing list:", list_name))

    # Use lapply to iterate over each sublist in the current category
    names_to_use <- unlist(lapply(mirage_ch_vars[[i]], function(sublist) {
        # Check if the sublist is long enough to have at least the first element
        if(length(sublist) >= 1) {
            # Replace '_pre' with '_ch' in the first element
            return(gsub("_pre", "_ch", sublist[1]))
        } else {
            return(NA)  # Return NA if the sublist does not have at least one element
        }
      
    }))
    volcano_changes(input_vars = names_to_use, sub_folder = "all" , save_sub_path = list_name, spearman_types_select = spearman_types_select.all)
    volcano_changes(input_vars = names_to_use, sub_folder = "groups", save_sub_path = list_name, spearman_types_select = spearman_types_select.groups)
}
```

### Heatmap

```{r}

heatmap_changes <- function(test_against_input, save_name)
  {
  
# Group lipidclasses to make multiple, clean heatmaps
lipids_groups <- list(
  gr_tag = c("TAG"),  # Triacylglycerols
  gr_dg_ac = c("1,2-DG", "1,3-DG", "AC"),  # Diglycerides and Acyl carnitines
  gr_pc = c("PC", "PC.PE"),  # Phosphatidylcholines and ratio
  gr_pe = c("PE"),  # Phosphatidylethanolamines
  gr_sphingolipids = c("SPM", "SPH", "Cer", "Cer ratio", "dhCer", "GluCer", "LacCer", "GalCer"),  # Sphingolipids: Sphingomyelins, Sphingosines, Ceramides and derivatives
  gr_lyso = c("LPC", "LPE", "LPG", "LPI", "LPS"),  # Lysophospholipids
  gr_pa_ps = c("PA", "PS"),  # Group combining Phosphatidic acids and Phosphatidylserines
  gr_pg_pi = c("PG", "PI")  # Group combining Phosphatidylglycerols and Phosphatidylinositols
)

# Define function to filter and sort lipids based on group names
filter_lipid_group_base <- function(data_frame, lipid_group) {
  # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  # Sort the data_frame by lipid column
  sorted_data_frame <- data_frame[order(data_frame$lipid), ]
  # Filter based on the pattern and return the sorted & filtered data frame
  sorted_filtered_data_frame <- sorted_data_frame[grepl(pattern, sorted_data_frame$lipid), ]
  return(sorted_filtered_data_frame)
}

# Select specific test against
long_format_p_adj_selected.non <- long_format_p_adj.non[long_format_p_adj.non$test_against %in% test_against_input,]
long_format_p_adj_selected.gr <- long_format_p_adj.gr[long_format_p_adj.gr$test_against %in% test_against_input,]
long_format_p_adj_selected.gr.class <- long_format_p_adj.gr.class[long_format_p_adj.gr.class$test_against %in% test_against_input,]
long_format_corr_selected <- long_format_cor[long_format_cor$test_against %in% test_against_input,]

# Only select ALL and not subgroups
long_format_p_adj_selected.non <- long_format_p_adj_selected.non[long_format_p_adj_selected.non$spearman_type == "spearman_p_ALL", ]
long_format_p_adj_selected.gr <- long_format_p_adj_selected.gr[long_format_p_adj_selected.gr$spearman_type == "spearman_p_ALL", ]
long_format_p_adj_selected.gr.class <- long_format_p_adj_selected.gr.class[long_format_p_adj_selected.gr.class$spearman_type == "spearman_p_ALL", ]
long_format_corr_selected <- long_format_corr_selected[long_format_corr_selected$spearman_type == "spearman_rho_ALL", ]


# Apply the filter function to each group and store the results in a lists
# p-values
long_format_p_adj_groups.non <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.non)
long_format_p_adj_groups.gr <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr.class)
long_format_p_adj_groups.all <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr)
# correlations
long_format_corr_groups <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_corr_selected)


# Function to create 'unique_test_against' column for p-value df
mutate_unique_column_p <- function(data_frame) {
  data_frame %>%
    mutate(unique_test_against = paste0(sub("spearman_p_", "", spearman_type), "_", test_against))
}

# Adjust the function for correlation df
mutate_unique_column_corr <- function(data_frame) {
  data_frame %>%
    mutate(unique_test_against = paste0(sub("spearman_rho_", "", spearman_type), "_", test_against))
}

# Apply the mutation function to each group's data frames for p-values
long_format_p_adj_groups.non <- lapply(long_format_p_adj_groups.non, mutate_unique_column_p)
long_format_p_adj_groups.gr <- lapply(long_format_p_adj_groups.gr, mutate_unique_column_p)
long_format_p_adj_groups.all <- lapply(long_format_p_adj_groups.all, mutate_unique_column_p)

# Apply the mutation function to each group's data frames for correlations
long_format_corr_groups <- lapply(long_format_corr_groups, mutate_unique_column_corr)


# Function to perform negative log10 transformation and remove p_value column
transform_p_values <- function(df) {
  df %>%
    mutate(p_log10 = -log10(p_value)) %>%
    select(-p_value)
}

# Apply the transformation to each list
long_format_p_adj_log10.non <- lapply(long_format_p_adj_groups.non, transform_p_values)
long_format_p_adj_log10.gr <- lapply(long_format_p_adj_groups.gr, transform_p_values)
long_format_p_adj_log10.all <- lapply(long_format_p_adj_groups.all, transform_p_values)
 
# Define a function to spread the data and convert it to a matrix
spread_and_convert_matrix <- function(df, unitName) {
  result_matrix <- df %>%
    select(lipid, unique_test_against, all_of(unitName)) %>%
    pivot_wider(names_from = unique_test_against, 
                values_from = unitName, 
                values_fill = setNames(list(NA), unitName)) %>%
    column_to_rownames(var = "lipid") %>%
    as.matrix()
  return(result_matrix)
}

# Apply the function to each list
matrices_p_adj_non <- lapply(long_format_p_adj_groups.non, function(x) spread_and_convert_matrix(x, "p_value"))
matrices_p_adj_gr <- lapply(long_format_p_adj_groups.gr, function(x) spread_and_convert_matrix(x, "p_value"))
matrices_p_adj_all <- lapply(long_format_p_adj_groups.all, function(x) spread_and_convert_matrix(x, "p_value"))
# To correlation values
matrices_rho <- lapply(long_format_corr_groups, function(x) spread_and_convert_matrix(x, "rho_value"))


generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims) {
  # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
# Extract test_against by removing the first part (treatment group) and the first underscore
# This joins back the remaining parts to form the full 'test_against' label
colTitles <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) paste(x[-1], collapse = "_"))
colTitles <- unique(colTitles)
  
  
# Modify the column names to only show the group
colnames(hm_matrix) <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) {
  # Concatenate the first part with the first four letters of the second part and "..."
  paste0(x[1], "", substr(x[2], 1, 0), "")
})


  Heatmap(hm_matrix,
          name = "rho", # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 9), # Change font size of row labels
          
          column_split = rep(1:(ncol(hm_matrix) / 1), each = 1), # Splits the columns and names them
          column_title = colTitles, # Custom titles for each split
          column_names_rot = 45, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 8, fontface = "bold"),
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 7, fontface = "bold"),
          #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
      
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                  if (p_val_matrix[i, j] < pLims$p1) {
                      grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p2) {
                      grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p3) {
                      grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  }
              }
          })
}

# Define color map for heatmap
color_mapping <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
hm <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)) {
  # Generate heatmap and store it in the list
  hm[[i]] <- generate_heatmap(matrices_rho[[i]], matrices_p_adj_all[[i]], color_mapping, p_value_limits)
}

# Define the path and name of your PDF file
pdf_path <- paste0(getwd(), "/outputs/correlations in changes/heatmap/", save_name, ".pdf")

# Open a PDF device
pdf(pdf_path, width = 12, height = 14)

# Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
for (i in 1:length (hm)){
  draw(hm[[i]])
}
dev.off()

}

# Loop over every group within the compositions
    for (i in seq_along(mirage_ch_vars)) {
        # Print the name of the current list being processed
        list_name <- names(mirage_ch_vars)[i]
        print(paste("Processing list:", list_name))
    
     test_against_input <- unlist(lapply(mirage_ch_vars[[i]], function(sublist) {
            # Check if the sublist is long enough to have at least the first element
            if(length(sublist) >= 1) {
                # Replace '_pre' with '_ch' in the first element
                return(gsub("_pre", "_ch", sublist[1]))
            }}))
      heatmap_changes(test_against_input = test_against_input, save_name = list_name)
     }
    
```

```{r}

```

## Plot p-values sorted

```{r}

# BH correct p-values
# Name the columns that should be adjusted
cols_to_adjust <- c(
  "pearson_p_all", "spearman_p_all", "mixed_p_all",
  "pearson_p_HED", "spearman_p_HED",
  "pearson_p_DIWL", "spearman_p_DIWL",
  "pearson_p_WLEX", "spearman_p_WLEX"
)

# Function to apply BH correction within each "test_against" group
adjust_p_values_within_group <- function(data, cols_to_adjust) {
  data %>%
    group_by(test_against) %>%
    mutate(across(all_of(cols_to_adjust), ~ p.adjust(.x, method = "BH"), .names = "{.col} (corrected)")) %>%
    ungroup()
}

# Apply correct function
# composition
correlation_values_ch_composition <- adjust_p_values_within_group(correlation_values_ch_composition, cols_to_adjust)
# class
correlation_values_ch_class <- adjust_p_values_within_group(correlation_values_ch_class, cols_to_adjust)
# class and composition
# combine data
correlation_values_ch_comp_and_class <- rbind(correlation_values_ch_composition, correlation_values_ch_class)
# Adjust
correlation_values_ch_comp_and_class <- adjust_p_values_within_group(correlation_values_ch_comp_and_class, cols_to_adjust)

### Plot p-values sorted
generate_barplot_ch <- function(data, col_non_corrected, col_corrected, output_base_path, data_name) {
  # Define common sizes for axis titles and plot title
  axis_title_size <- 12
  plot_title_size <- 13

  # Loop over every unique test
  for (test_var in unique(data$test_against)) {
    # Filter based on test variable
    data_test_filtered <- filter(data, test_against == test_var)

    # Remove row if non corrected column is Na
    data_test_filtered <- data_test_filtered[!is.na(data_test_filtered[[col_non_corrected]]), ]

    # Dynamic adjustment of the label size based on the number of bars (lipids)
    num_bars <- length(unique(data_test_filtered$lipid))
    label_size <- max(2, min(10, 50 / sqrt(num_bars))) # Adjusted dynamically


    # Generate plot for non-corrected p-values
    p1 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_non_corrected]]), y = data_test_filtered[[col_non_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_non_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Generate plot for corrected p-values
    p2 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_corrected]]), y = data_test_filtered[[col_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Combine the two plots
    subplot <- p1 + p2

    # Construct the subfolder path based on 'test_var'
    subfolder_path <- file.path(output_base_path, gsub("[ :()]", "_", test_var)) # Replace problematic characters

    # Ensure the subfolder exists
    dir.create(subfolder_path, recursive = TRUE, showWarnings = FALSE)

    # Construct the plot filename, ensuring no problematic characters for file names
    plot_filename <- paste0(gsub("[ :()]", "_", col_non_corrected), ", ", data_name, test_var, ".jpeg") # Replace spaces and special characters with underscores

    # Save the plot
    ggsave(file.path(subfolder_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
  }
}

# RUN FUNCTIONS
# Add a second row to cols_to_adjust with corrected column names
plot_nonadj_vs_adj <- data.frame(original = cols_to_adjust, corrected = paste0(cols_to_adjust, " (corrected)"))

# Just leave empty, as ch already indicates change in file name
dataframe_name_comp <- ""


####### MAKE FOR LIPID COMP AND CLASS!!!

# For lipid class
# Define output path
output_base_path <- paste0( getwd(), "/outputs/correlations in changes/plot, p-value sorted changes/lipid class")

for (i in 1:nrow( plot_nonadj_vs_adj)) {
  generate_barplot_ch(correlation_values_ch_class, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}

# For lipid class
# Define output path
output_base_path <- paste0(getwd(), "/outputs/correlations in changes/plot, p-value sorted changes/lipid class and composition")

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_ch(correlation_values_ch_composition, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}
```

# Cross sectional analysis

Analyse correlation between variables from the mirage dataset and the lipidomics data for all subjects at the time point pre.

## Prepare data (function)

Ouliers handled by using pmol_imputed. For lipid composition, outliers are removed before in the data fed to the dataset

```{r}
# run function test
# Function to prepare data
prepare_and_combine_crossSection <- function(lipidomicsData, mirageData, lipidclass, lipidcomposition) {
  
  # Filter and prepare lipidomics data.
if (!is.null(lipidcomposition) && lipidcomposition != "ratio"){
  lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass, lipidComposition == lipidcomposition)
} else {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
}
  
  
        # Remove lipid composition within lipid class if fewer non-zero values than the analysis_cutoff. Only for lipidComposition
  non_zero_rows <- lipidomics_selected %>%
  filter(pmol_mg > 0)
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, lipidComposition, pmol_mg_imp)

  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = pmol_mg_imp, names_prefix = "pmol_mg_") %>%
    relocate(id, .before = everything()) # Moves id to front

  
  ## Calculate sum within each individual to use for lipid class.
lipidomics_wide <- lipidomics_wide %>%
  group_by(id) %>%
  mutate(pmol_mg_id = if_else(row_number() == 1, sum(pmol_mg_Pre), NA_real_)) %>%
  ungroup()
  
  ### Normalize data
  # Normalization has to be within each lipidclass and composition.
  # Calculate z normalization within each lipid composition
  lipidomics_wide <- lipidomics_wide %>%
    group_by(lipidClass, lipidComposition) %>%
    mutate(lipid_normalized_z = scale(pmol_mg_Pre)[, 1]) %>%
    ungroup()

#  # Calculate the mean z-score for each ID
#  mean_z_score_per_id <- lipidomics_wide %>%
#    group_by(id) %>%
#    summarise(lipid_normalized_z_avg = mean(lipid_normalized_z, na.rm = TRUE)) %>%
#    ungroup()
#
#  # Add the normalized data back to original dataframe for only for the first occurrence of each ID
#  lipidomics_wide <- lipidomics_wide %>%
#    left_join(mean_z_score_per_id, by = "id") %>%
#    group_by(id) %>%
#    mutate(
#      row_num = row_number(),
#      lipid_normalized_z_avg = if_else(row_num == 1, lipid_normalized_z_avg, NA_real_)
#    ) %>%
#    select(-row_num) %>%
#    ungroup()

  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")

  # Convert certain columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))

  
  # output Na
  if (!is.null(lipidcomposition) & nrow(non_zero_rows) < analysis_cutoff){
      combined_df$skipAnalysis <- TRUE
    }else{
      combined_df$skipAnalysis <- FALSE
    }
  
      return(combined_df)
}

```

## Statistics (function)

```{r}
# Define a function to compute correlations of change
correlation_cross_sectional <- function(correlation_df, lipidomicsDF, mirage_variables_of_interest, lipidclass, lipidcomposition) {

 # Determine the lipid name based on the presence of lipid composition   
if (!is.null(lipidcomposition) && lipidcomposition != "ratio") {
  lipidName <- paste0(lipidclass, " ", lipidcomposition)
} else {
    lipidName <- lipidclass
}
  
  # Make Na if too few values determined from prepare data function
  if (correlation_df$skipAnalysis[[1]] == TRUE) {
    
      correlation_results <- data.frame(
    lipid = lipidName,
    test_against = NA,
    pearson_r_all = NA,
    pearson_p_all = NA,
    spearman_rho_all = NA,
    spearman_p_all = NA,
    pearson_r_HED = NA,
    pearson_p_HED = NA,
    spearman_rho_HED = NA,
    spearman_p_HED = NA,
    pearson_r_DIWL = NA,
    pearson_p_DIWL = NA,
    spearman_rho_DIWL = NA,
    spearman_p_DIWL = NA,
    pearson_r_WLEX = NA,
    pearson_p_WLEX = NA,
    spearman_rho_WLEX = NA,
    spearman_p_WLEX = NA
  )
  } else {
  
    # Initialize an empty data frame to store correlation results
  correlation_results <- data.frame(
    lipid = character(),
    test_against = character(),
    pearson_r_all = numeric(),
    pearson_p_all = numeric(),
    spearman_rho_all = numeric(),
    spearman_p_all = numeric(),
    pearson_r_HED = numeric(),
    pearson_p_HED = numeric(),
    spearman_rho_HED = numeric(),
    spearman_p_HED = numeric(),
    pearson_r_DIWL = numeric(),
    pearson_p_DIWL = numeric(),
    spearman_rho_DIWL = numeric(),
    spearman_p_DIWL = numeric(),
    pearson_r_WLEX = numeric(),
    pearson_p_WLEX = numeric(),
    spearman_rho_WLEX = numeric(),
    spearman_p_WLEX = numeric()
  )

  
  # Loop over every mirage variables of interest
  for (i in seq_along(mirage_variables_of_interest)) {
    for (j in seq_along(mirage_variables_of_interest[[i]])){
    
      # Manipulate current variable name
      test_against_name <- mirage_variables_of_interest[[i]][[j]][1]
      test_against_name_clean <- sub("_pre$", "", test_against_name)

      # Add new row to output df
      correlation_results <- add_row(correlation_results)
  
      # Identify the index of current row to be able to append data to it
      current_row_index <- nrow(correlation_results)
  
      # Assign lipid name and test against to last row
      correlation_results$lipid[current_row_index] <- lipidName
      correlation_results$test_against[current_row_index] <- test_against_name
  
      # Choose the correct unit for lipid class and lipid comp
if (!is.null(lipidcomposition) && lipidcomposition != "ratio") {
          lipid_unit <- "pmol_mg_Pre"
} else {
    lipid_unit <- "pmol_mg_id"
}
      
      # Perform Pearson and Spearman correlations for all data
      result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
      result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
  
  
      # Assign results the the results df
      correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
      correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
      correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
      correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p
  
      # Calculate correlations for each group
      for (current_group in unique(correlation_df$group)) {
        # Filter the dataframe for the current group
        correlation_df_group <- filter(correlation_df, group == current_group)
  
  
        # Perform Pearson and Spearman correlations for the current group
        result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
        result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
  
        # Dynamic assignment of results based on the current group
        pearson_r_col <- paste0("pearson_r_", current_group)
        pearson_p_col <- paste0("pearson_p_", current_group)
        spearman_rho_col <- paste0("spearman_rho_", current_group)
        spearman_p_col <- paste0("spearman_p_", current_group)
  
        correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
        correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
        correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
        correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
    }
  }
  }
  }
  return(correlation_results)
}

```

## Plot scatter (function)

```{r}
correlation_crossSectional_plot <- function(correlation_df, mirage_crossSectional_vars, correlation_results, savePath, lipidclass, lipidcomposition) {
  # Make lipid name
if (!is.null(lipidcomposition) && lipidcomposition != "ratio"){
  lipidName <- paste0(lipidclass, " ", lipidcomposition)
} else {
    lipidName <- lipidclass
}
  
  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pmol_mg_Pre))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_crossSectional_vars, function(category) {
    lapply(category, function(item) item[1])
    }), recursive = FALSE), use.names = FALSE)
    

    # If lipidcomposition is null, then only plot class
    
    # Filter and prepare lipidomics data
if (!is.null(lipidcomposition) && lipidcomposition != "ratio"){
      # Add lipid variable to plotVars
      plotVars <- c("pmol_mg_Pre", plotVars)

      # Now use ggpairs on the renamed dataframe
      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars,
        lower = list(continuous = wrap("smooth", method = "none", se = FALSE))
      )
} else {
    # Add lipid variable to plotVars
      # Make plot with log2 fold change if only class is available
      plotVars <- c("pmol_mg_id", plotVars)

      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars
      )
}
    
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }

    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)

      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
        x = Inf, y = Inf,
        label = paste0(
          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
         # ", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
          "\nSpearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
          ", rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
          "\n***** Non-adjusted *****"
        ),
        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }

    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }

    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }


    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }

  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )

  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
}
```

## Run functions

```{r}
# Save folder for .jpg output files
savePathClassComp <- paste0(getwd(), "/outputs/cross section/scatter composition/")
savePathClass <- paste0(getwd(), "/outputs/cross section/scatter class/")

# Initialize an empty data frame to hold all correlation values
correlation_results_crossSection_composition <- data.frame()
correlation_results_crossSection_class <- data.frame()

# Loop over each lipid composition within each lipidclass
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)



for (lipid_class in unique_lipid_classes[!unique_lipid_classes == "PC.PE"]) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  
  for (lipid_composition in lipid_compositions_in_class) {
    print( paste0("Cross sectional analysis; processing ", lipid_class, " ", lipid_composition , "..."))
    # Select and prepare data for analysis
    correlation_crossSection_df <- prepare_and_combine_crossSection(
      lipidomicsData = lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),],
      mirageData = mirage_data,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition
    )

    # Calculate correlation coefficients
    correlation_results_crossSection_composition <- rbind(correlation_results_crossSection_composition, correlation_cross_sectional(
      correlation_df = correlation_crossSection_df, 
      lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),], 
      mirage_variables_of_interest = mirage_crossSectional_vars,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition))


        # Plot data - Comment out if to be used
        correlation_crossSectional_plot(
          correlation_crossSection_df,
          mirage_crossSectional_vars,
          correlation_results_crossSection_composition,
          savePathClassComp,
          lipid_class,
          lipid_composition
        )
  }
}

# Loop over each lipid class and make plots
for (lipid_class in unique_lipid_classes[!unique_lipid_classes == "Cer ratio"]) {
  
  print( paste0("Baseline analysis; processing ", lipid_class, "..."))
  
  # Organize data
  correlation_crossSection_df <- prepare_and_combine_crossSection(
    lipidomicsData = lipidomicsDF,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    lipidcomposition = NULL
  )

  # Calculate correlations for changes
  correlation_results_crossSection_class <- rbind(correlation_results_crossSection_class, correlation_cross_sectional(correlation_crossSection_df, lipidomicsDF, mirage_crossSectional_vars, lipid_class, lipidcomposition = NULL))

# Plot data - un-comment if to be used again
correlation_crossSectional_plot(
  correlation_crossSection_df,
  mirage_crossSectional_vars,
  correlation_results_crossSection_class,
  savePathClass,
  lipid_class,
  lipidcomposition = NULL
)
}



###### SAVE AND LOAD VARIABLES TO NOT HAVE TO RERUN ALL THE ANALYSIS #######
# Define the path to save/load folder
# save_variable_path <- paste0(getwd(), "/outputs/saved variables/")
# 
# # Specify filenames for each variable
# file_correlation_values_crossSection_composition <- paste0(save_variable_path, "correlation_values_crossSection_composition.rds")
# file_correlation_values_crossSection_class <- paste0(save_variable_path, "correlation_values_crossSection_class.rds")
# 
# Save the variables
# saveRDS(correlation_results_crossSection_composition, file = file_correlation_values_crossSection_composition)
# saveRDS(correlation_results_crossSection_class, file = file_correlation_values_crossSection_class)

# OR LOAD VARIABLES
# correlation_results_crossSection_composition <- readRDS(file = file_correlation_values_crossSection_composition)
# correlation_results_crossSection_class <- readRDS(file = file_correlation_values_crossSection_class)

```

## volcano

```{r}
volcano_crossSection <- function(input_vars, save_sub_path){
# Combine class and composition data
correlation_results_crossSection_class_and_comp <- rbind(correlation_results_crossSection_composition, correlation_results_crossSection_class)


# Remove NA rows
correlation_results_crossSection_class_and_comp <- correlation_results_crossSection_class_and_comp[!is.na(correlation_results_crossSection_class_and_comp$spearman_rho_all), ]

# Select columns: Rho and p-value
vulc_data_crossSection <- correlation_results_crossSection_class_and_comp %>% 
  select("lipid", "test_against", "spearman_rho_all", "spearman_p_all")
  
# Filter rows where 'test_against' column values are in 'input_vars'
vulc_data_crossSection <- vulc_data_crossSection[vulc_data_crossSection$test_against %in% input_vars, ]

# ********* P-ADJUST ***********

Adjust the p-value column based test_against and count of all lipids
vulc_data_crossSection <- vulc_data_crossSection %>%
    group_by(test_against) %>%
    mutate(across("spearman_p_all", ~ p.adjust(.x, method = "BH"), .names = "p_value")) %>%
    ungroup()

 # # adjust p-values by count within group and lipidClass
 # # First reintroduce lipidclass
 # vulc_data_crossSection <- vulc_data_crossSection %>%
 #   mutate(lipidClass = sub("^(\\S+)\\s.*$", "\\1", lipid)) %>%
 #   group_by(test_against, lipidClass) %>%
 #   mutate(p_value = p.adjust(spearman_p_all, method = "BH")) %>%
 #   ungroup()

# ********************

# Make a identifier column that combines lipid and test_against
vulc_data_crossSection$identifier <- paste0(vulc_data_crossSection$lipid, " ~ ", vulc_data_crossSection$test_against)


### Plot settings
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_data_crossSection$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)

### Create plot
vulc_plot <- ggplot(vulc_data_crossSection, aes(x = spearman_rho_all, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", linewidth = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12), guide = FALSE) + # TRUE for significant, FALSE for not
  geom_text_repel(aes(label = ifelse(p_value < 0.06 & abs(spearman_rho_all) > threshold_rho, identifier, "")),
                  box.padding = .3, point.padding = .3,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  xlim(-1,1) +
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) + # Hide the alpha legend and fix the color legend
  labs(title = paste0("Correlations at baseline - ", save_sub_path), x = "Spearman rho", y = "-log10 P-value")+
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

    # Save path
  save_path <- paste0( getwd(), "/outputs/cross section/volcano/", save_sub_path, ".jpeg")
    
# Save the plot
ggsave(save_path , plot = vulc_plot, width = 12, height = 8, dpi = 400)

}


# Run function

# Loop through each main category in mirage_crossSection_vars
for (i in seq_along(mirage_crossSectional_vars)) {
    # Print the name of the current list being processed
    list_name <- names(mirage_crossSectional_vars)[i]
    print(paste("Processing list:", list_name))

    # Use lapply to iterate over each sublist in the current category
    names_to_use <- unlist(lapply(mirage_crossSectional_vars[[i]], function(sublist) {
        # Check if the sublist is long enough to have at least the first element
        if(length(sublist) >= 1) {
            # Replace '_pre' with '_ch' in the first element
            return( sublist[1])
        } else {
            return(NA)  # Return NA if the sublist does not have at least one element
        }
        }))
    
         volcano_crossSection(input_vars = names_to_use , save_sub_path = list_name)
}

```

## p-value plots

**Correct p-values based on Bejamini-Hochberg**

```{r}
# BH correct p-values
# Name the columns that should be adjusted
cols_to_adjust <- c(
  "pearson_p_all", "spearman_p_all"
)

# Function to apply BH correction within each "test_against" group
adjust_p_values_within_group <- function(data, cols_to_adjust) {
  data %>%
    group_by(test_against) %>%
    mutate(across(all_of(cols_to_adjust), ~ p.adjust(.x, method = "BH"), .names = "{.col} (corrected)")) %>%
    ungroup()
}


# Apply adjustment function
# Composition and class
# Combine class and composition
correlation_results_crossSection_class_and_comp <- rbind(correlation_results_crossSection_composition, correlation_results_crossSection_class)
# Run adjustment
correlation_results_crossSection_class_and_comp <-
  adjust_p_values_within_group(correlation_results_crossSection_class_and_comp, cols_to_adjust)

# Composition
correlation_results_crossSection_composition <-
  adjust_p_values_within_group(correlation_results_crossSection_composition, cols_to_adjust)

# Class
correlation_results_crossSection_class <-
  adjust_p_values_within_group(correlation_results_crossSection_class, cols_to_adjust)

```

**Plot p-values**

```{r}
generate_barplot_crossSection <- function(data, col_non_corrected, col_corrected, output_base_path, data_name) {
  # Define common sizes for axis titles and plot title
  axis_title_size <- 12
  plot_title_size <- 13

  # Loop over every unique test
  for (test_var in unique(data$test_against)) {
    # Filter based on test variable and columns of interest
    data_test_filtered <- data %>%
      filter(test_against == test_var) %>%
      select(lipid, test_against, pearson_p_all, spearman_p_all, `pearson_p_all (corrected)`, `spearman_p_all (corrected)`)

    # Remove row if non corrected column is Na
    data_test_filtered <- data_test_filtered[!is.na(data_test_filtered[[col_non_corrected]]), ]

    # Dynamic adjustment of the label size based on the number of bars (lipids)
    num_bars <- length(unique(data_test_filtered$lipid))
    label_size <- max(2, min(10, 50 / sqrt(num_bars))) # Adjusted dynamically


    # Generate plot for non-corrected p-values
    p1 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_non_corrected]]), y = data_test_filtered[[col_non_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_non_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Generate plot for corrected p-values
    p2 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_corrected]]), y = data_test_filtered[[col_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Combine the two plots
    subplot <- p1 + p2

    # Construct the subfolder path based on 'test_var'
    subfolder_path <- file.path(output_base_path, gsub("[ :()]", "_", test_var)) # Replace problematic characters

    # Ensure the subfolder exists
    dir.create(subfolder_path, recursive = TRUE, showWarnings = FALSE)

    # Construct the plot filename, ensuring no problematic characters for file names
    plot_filename <- paste0(gsub("[ :()]", "_", col_non_corrected), ", ", data_name, test_var, ".jpeg") # Replace spaces and special characters with underscores

    # Save the plot
    ggsave(file.path(subfolder_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
  }
}


# RUN FUNCTIONS
# Add a second row to cols_to_adjust with corrected column names
plot_nonadj_vs_adj <- data.frame(original = cols_to_adjust, corrected = paste0(cols_to_adjust, " (corrected)"))

# Just leave empty, as ch already indicates change in file name
dataframe_name_comp <- ""


# For lipid class
# Define output path
output_base_path <- paste0(getwd(), "/outputs/cross section/plot, p-value sorted cross section/class")

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_class, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}


# For lipid composition within lipid class
# Define output path
output_base_path <- paste0(getwd(), "/outputs/cross section/plot, p-value sorted cross section/composition")

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_composition, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}

# For lipid composition and lipid class combined
# Define output path
output_base_path <- paste0(getwd(), "/outputs/cross section/plot, p-value sorted cross section/class and composition")

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_class_and_comp, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}
```

# Pre-post analysis

## Mixed models

Insulin sensitivity. Original data was analyzed by one-way ANOVA. So this would be to double check results mixed model for pre-post changes for every lipid composition within all lipid classes and for every lipid class.

```{r}
# Set the max number of observations that the emmeans package will handle. Lower number shorter computation times, larger number, more precise CI and p-value estimates
emm_options(pbkrtest.limit = 6000) # change to 5000 after code works

mixedmodel_pre_post <- function(dataset, response_var, lipidclass, lipidcomposition = NULL) {
  
  # Print progress
  ifelse( is.null(lipidcomposition),
          print (paste0( "Analysing ", lipidclass, "...")),
          print( paste0( "Analysing ", lipidclass, " ", lipidcomposition, "...")))
  
  # Filter dataset based on lipidclass and optionally lipidcomposition
  if (!is.null(lipidcomposition)) {
    data_to_model <- filter(dataset, lipidClass == lipidclass & lipidComposition == lipidcomposition)
  } else {
    data_to_model <- filter(dataset, lipidClass == lipidclass)
  }
  
  # Check number of non-zero rows
  non_zero_rows <- data_to_model %>% 
    filter(pmol_mg > 0) %>% 
    nrow()
  
  # only proceed if number of non zero rows is above cutoff
  if (non_zero_rows < analysis_cutoff){
    
    results_list <- list(
        lipidClass = as.character(lipidclass),
        lipidComposition = as.character(lipidcomposition),
        slope_results = NA_real_,
        prepost_results = NA_real_)
    
    results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
    
    return(results_list)
  } else {
    
  # Prepare factors
  data_to_model$group <- factor(data_to_model$group, levels = c("HED", "DIWL", "WLEX"))
  data_to_model$time <- factor(data_to_model$time, levels = c("Pre", "Post"))

#  # Remove Na rows
#  data_to_model <- data_to_model[!is.na(data_to_model$pmol_mg), ]
#
#
#  # Remove lipidcomposition with only 0
#  data_to_model <- data_to_model %>%
#    group_by(lipidComposition) %>%
#    filter(any(pmol_mg != 0)) %>%
#    ungroup()


  # Determine if lipidComposition can be a random effect
  if (!is.null(lipidcomposition) || length(unique(data_to_model$lipidComposition)) <= 1) {
    model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id)"))
  } else {
    model_formula <- as.formula(paste(response_var, "~ time * group +
                                      (1 | id) + (1 + time | lipidComposition)"))
  }

  # Try-catch block for model fitting
  tryCatch(
    {
      model <- lmer(model_formula,
                    data = data_to_model,
                    na.action = na.exclude)
      # Estimated marginal of means to get out slope and between groups statistics
      emm <- emmeans(model, ~ time * group)

      # Contrasts for differences in slopes between groups
      model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")

      model.slope.contrasts.results <- summary(model.slope.contrasts)

      # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
      model.slope.contrasts.results <- model.slope.contrasts.results %>%
        mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
        select(contrast, estimate, SE, df, t.ratio, p.value)

      # Pre, Post between group comparisons
      prepost.contrasts <- pairs(emm, adjust = "none")

      # Get results
      prepost.contrasts.results <- summary(prepost.contrasts)

      # Create results list
      results_list <- list(
        lipidClass = as.character(lipidclass),
        lipidComposition = as.character(lipidcomposition),
        slope_results = model.slope.contrasts.results,
        prepost_results = prepost.contrasts.results)
      
      # Name results list
     ifelse( is.null(lipidcomposition),
             results_list <- setNames(list(results_list), lipidclass),
             results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
             )
    
      return(results_list)
    },
    error = function(e) {
      results_list <- list(
        lipidClass = as.character(lipidclass),
        lipidComposition = as.character(lipidcomposition),
        slope_results = NA_real_,
        prepost_results = NA_real_)
      
      results_list <- setNames(list(results_list), paste(lipidclass, lipidcomposition, sep = "_"))
      
      return(results_list)
    }
  )
}
  }

# Define lipidclasses and compositions to use by removing the ratios
lipid_classes <- unique(unique_combinations$lipidClass[!unique_combinations$lipidClass == "Cer ratio"])
  
lipid_classes_per_comp <- unique_combinations$lipidClass[!unique_combinations$lipidClass == "PC.PE"]

lipid_compositions <- unique_combinations$lipidComposition[!unique_combinations$lipidClass == "PC.PE"]

# Run function for lipid composition
# PC.PE is not analysed as a composition, but only as class
result.lipid.pre_post.class_comp <- pmap(
  list(lipidClass = lipid_classes_per_comp,
       lipidComposition = lipid_compositions),
  ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", ..1, ..2)
)
# Outlier removed
result.lipid.pre_post.class_comp.outlierRM <- pmap(
  list(lipidClass = lipid_classes_per_comp,
       lipidComposition = lipid_compositions),
  ~ mixedmodel_pre_post(lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),], "pmol_mg", ..1, ..2)
)

# Flatten the list to set the list names to first level
result.lipid.pre_post.class_comp <- flatten(result.lipid.pre_post.class_comp)
result.lipid.pre_post.class_comp.outlierRM <- flatten(result.lipid.pre_post.class_comp.outlierRM)


# Use map to iterate over lipid classes
result.lipid.pre_post.class <- map(lipid_classes, ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", .x))
# With outliers removed - NB. imputed values could be used instead.
result.lipid.pre_post.class.outlierRM <- map(lipid_classes, ~ mixedmodel_pre_post(lipidomicsDF[lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier),], "pmol_mg", .x))

result.lipid.pre_post.class <- flatten(result.lipid.pre_post.class)
result.lipid.pre_post.class.outlierRM <- flatten(result.lipid.pre_post.class.outlierRM)
```

### QC: t-test on class
```{r}
# Calculate class sums for each id
class_sums <- lipidomicsDF %>% 
  group_by(id, lipidClass, time, group) %>% 
  summarize( class_sum = sum(pmol_mg)) %>% 
ungroup()

# Imputed
class_sums_outlier.imp <- lipidomicsDF %>% 
  group_by(id, lipidClass, time, group) %>% 
  summarize( class_sum = sum(pmol_mg_imp)) %>% 
ungroup()



# Calculate pre-post delta
class_deltas <- class_sums %>%
  filter(time %in% c("Pre", "Post")) %>%
  pivot_wider(
    names_from = time, 
    values_from = class_sum, 
    names_prefix = "class_sum_"
  ) %>%
  group_by(id, lipidClass, group) %>%
  summarize(
    class_delta = class_sum_Post - class_sum_Pre,
    .groups = "drop"
  ) %>%
  ungroup()

# Calculate pre-post delta
class_deltas.imp <- class_sums_outlier.imp %>%
  filter(time %in% c("Pre", "Post")) %>%
  pivot_wider(
    names_from = time, 
    values_from = class_sum, 
    names_prefix = "class_sum_"
  ) %>%
  group_by(id, lipidClass, group) %>%
  summarize(
    class_delta = class_sum_Post - class_sum_Pre,
    .groups = "drop"
  ) %>%
  ungroup()


# Calculate t-tests based on delta
results_ttest <- class_deltas %>%
  filter(group %in% c("DIWL", "WLEX")) %>%
  group_by(lipidClass) %>%
  do(tidy(t.test(class_delta ~ group, data = .))) %>%
  ungroup()

# Calculate t-tests based on delta
results_ttest.imp <- class_deltas.imp %>%
  filter(group %in% c("DIWL", "WLEX")) %>%
  group_by(lipidClass) %>%
  do(tidy(t.test(class_delta ~ group, data = .))) %>%
  ungroup()


# Create table with lipid classes and p-values
p_value_table <- results_ttest %>%
select(lipidClass, p.value)

# Imputed
p_value_table.imp <- results_ttest.imp %>%
select(lipidClass, p.value)

# Renaming the p.value column
p_value_table <- p_value_table %>%
  rename(p.value.ttest = p.value)

# For imputed
p_value_table.imp <- p_value_table.imp %>%
  rename(p.value.ttest.imp = p.value)

# Join imputed ttest p-values
p_value_table <- p_value_table.imp %>%
  left_join(p_value_table, by = "lipidClass")

# Extract p-values from mixed model
# Function to extract the third p-value from each lipid class results
extract_p_value <- function(lipid_class_results) {
  if (!is.null(lipid_class_results$slope_results$p.value) && length(lipid_class_results$slope_results$p.value) >= 3) {
    return(lipid_class_results$slope_results$p.value[[3]])
  } else {
    return(NA)  # Return NA if the p-value does not exist or the structure is incorrect
  }
}
# Apply the function to each lipidClass and create a data frame
p_value_mixed <- sapply(result.lipid.pre_post.class, extract_p_value, USE.NAMES = TRUE)
p_value_mixed_df <- data.frame(lipidClass = names(p_value_mixed), p.value.mixed = p_value_mixed, stringsAsFactors = FALSE)

# without outliers
p_value_mixed.noOutliers <- sapply(result.lipid.pre_post.class.outlierRM, extract_p_value, USE.NAMES = TRUE)
p_value_mixed_df.noOutliers <- data.frame(lipidClass = names(p_value_mixed.noOutliers), p.value.mixed.noOutliers = p_value_mixed.noOutliers, stringsAsFactors = FALSE)


# Join mixed model p-values
p_value_table <- p_value_mixed_df %>%
  left_join(p_value_table, by = "lipidClass")

p_value_table <- p_value_mixed_df.noOutliers %>%
  left_join(p_value_table, by = "lipidClass")

# Make with correct decimals
p_value_table <- p_value_table %>%
  mutate(
    p.value.ttest = round(p.value.ttest, digits = 5),
    p.value.ttest.imp = round(p.value.ttest.imp, digits = 5),
    p.value.mixed = round(p.value.mixed, digits = 5),
    p.value.mixed.noOutliers = round(p.value.mixed.noOutliers, digits = 5)
  )

# Add a sorting order based on p.value.mixed.noOutliers
p_value_table_ordered <- p_value_table %>%
  mutate(ordering = rank(p.value.mixed.noOutliers, ties.method = "first")) %>%
  arrange(ordering)

# Reshape data from wide to long, preserving the ordering
p_value_long <- p_value_table_ordered %>%
  pivot_longer(
    cols = starts_with("p.value"),
    names_to = "p_value_type",
    values_to = "p_value"
  )

# Factor the lipidClass with levels specified by the ordering to ensure ggplot uses this order
p_value_long$lipidClass <- factor(p_value_long$lipidClass, levels = unique(p_value_long$lipidClass))

# Create a grouped bar plot with ordered lipidClass
ggplot(p_value_long, aes(x = lipidClass, y = p_value, fill = p_value_type)) +
  geom_col(position = position_dodge(width = 0.8), alpha = 0.8) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") + 
  labs(title = "Comparison of P-values: Mixed models vs t-tests on delta values",
       x = "Lipid Class",
       y = "P-value",
       fill = "P-value Type") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x labels for better readability

```


## Prepare data

Sort, adjust by Benjamini-Hochberg for lipid composition within lipid class

```{r}
prepare_lipid_data_for_plotting <- function(result_data) {
  pvals_df <- data.frame()
  est_df <- data.frame()
  
  contrasts_prepost <- c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX")
  contrasts_slope <- c("Pre - Post : HED - DIWL", "Pre - Post : HED - WLEX", "Pre - Post : DIWL - WLEX")

  for (test_name in names(result_data)) {
    # Check if prepost_results and slope_results are not NULL
    if (!is.na(result_data[[test_name]]$prepost_results[[1]][1])) {
      prepost_results <- result_data[[test_name]]$prepost_results
    } else {
      prepost_results <- data.frame(contrast = character(), p.value = numeric())
    }

    if (!is.na(result_data[[test_name]]$slope_results[[1]][1])) {
      slope_results <- result_data[[test_name]]$slope_results
    } else {
      slope_results <- data.frame(contrast = character(), p.value = numeric())
    }

    # Proceed with extraction using the ensured data frames
    prepost_pvals <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)

    slope_pvals <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)

        prepost_est <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    slope_est <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    
    # Combine values  %>%  single data
    # p-values
    combined_pvals <- c(prepost_pvals, slope_pvals)
    combined_pvals <- setNames(combined_pvals, c(contrasts_prepost, contrasts_slope))
    pvals_df <- rbind(pvals_df, cbind(lipid = test_name, t(as.data.frame(list(combined_pvals)))))
    
    # Estimates
    combined_est <- c(prepost_est, slope_est)
    combined_est <- setNames(combined_est, c(contrasts_prepost, contrasts_slope))
    est_df <- rbind(est_df, cbind(lipid = test_name, t(as.data.frame(list(combined_est)))))
    
  }
  
  # Select all columns after the first one to exclude lipid column
  corrected_cols <- names(pvals_df)[-1]

     # Remove rows where every column from the second column onwards contains NA
   pvals_df <- pvals_df[rowSums(is.na(pvals_df[, -1])) < (ncol(pvals_df) - 1), ]
  
  # Apply Benjamini-Hochberg correction and create new columns with the suffix "_BH_corrected"
  for (col in corrected_cols) {
    
    # ********** P ADJUSTMENT ***********
    
 # adjust p-values by group and lipidClass
     # P-values based on test counts within lipid class.
 pvals_df <- pvals_df %>%
   mutate(lipidClass = sub("([^_]+)_.*", "\\1", lipid)) %>%
   group_by(lipidClass) %>%
   mutate(
     !!paste0(col, " (corrected)") := p.adjust(.data[[col]], method = "BH")
   ) %>%
   ungroup() %>%
   select(-lipidClass)  # Remove the lipidClass column

#    # P-values based on all test count
 #   pvals_df[[paste0(col, " (corrected)")]] <- p.adjust(pvals_df[[col]], method = "BH")
  }

   # ********** P ADJUSTMENT ***********
   
  # Reset row names to simple sequential numbers
  rownames(pvals_df) <- NULL
  rownames(est_df) <- NULL

   # Only keep rows in est_df where the lipid values match those in pvals_df
est_df <- est_df[est_df$lipid %in% pvals_df$lipid, ]
  
  # Convert the columns to numeric
 # p-vals
   for (i in 2:ncol(pvals_df)) {
    if (!is.numeric(pvals_df[[i]])) {
      pvals_df[[i]] <- as.numeric(pvals_df[[i]])
    }
  }
  # estimates 
   for (i in 2:ncol(est_df)) {
    if (!is.numeric(est_df[[i]])) {
      est_df[[i]] <- as.numeric(est_df[[i]])
    }
  }

  # Combine the est and pvals dataframes into a list to be returned
  est_and_pvals <- list(p.vals = pvals_df, estimates = est_df)
  return(est_and_pvals)
}


## Code from when class and composition was seperated
# Prepare data for plotting lipid composition within each lipid class
est_and_p_lipid_comp <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_comp)
# Outlier rm
est_and_p_lipid_comp.outlierRM <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_comp.outlierRM)  


# Prepare data for plotting lipid classes
est_and_p_pvals_lipid_class <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class)
# Outlier rm
est_and_p_pvals_lipid_class.outlierRM <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class.outlierRM)



# ### Code for when class and composition were combined
# # Combine lists
# result.lipid.pre_post.class_and_comp <- c(result.lipid.pre_post.class_comp, result.lipid.pre_post.class)
# # Outlier removed
# result.lipid.pre_post.class_and_comp.outlierRM <- c(result.lipid.pre_post.class_comp.outlierRM, result.lipid.pre_post.class.outlierRM)
# 
# # Run prepare data function on combined list
# est_and_p_lipid_class_and_comp <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_and_comp)
# # Outlier rm
# est_and_p_lipid_class_and_comp.outlierRM <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_and_comp.outlierRM)



```

## Scatter plots

### Lipid composition

Composition scatter plot Data points above ULOQ and below LLOQ are marked with triangles for.

```{r}
# Create a named vector mapping IDs to continuous values for coloring
# color_map <- setNames(mirage_data$gender, mirage_data$id)

plot_lipid <- function(lipidomicsDF, lipid_composition, lipid_class, detection_limits, p_val_df, p_val_df_outlierRM, unit, save_subfolder) {
  
  
  filtered_data <- filter(lipidomicsDF, lipidClass == lipid_class & lipidComposition == lipid_composition)

  # Find the min and max of the y-axis data and add a buffer
  y_min <- min(filtered_data[[unit]], na.rm = TRUE) * 0.95 # 5% buffer reduced
  y_max <- max(filtered_data[[unit]], na.rm = TRUE) * 1.05 # 5% buffer increased

  # Find correct p-values
  search_key <- paste(lipid_class, lipid_composition, sep = "_")
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]
  pvalues_to_annotate.outlierRM <- p_val_df_outlierRM [p_val_df_outlierRM[, 1] == search_key, ]
  
  
# Calculate means for each group and time point using dynamic variable and only non outlier values
mean_data_comp <- filtered_data %>%
  filter(outlier == FALSE | is.na(outlier)) %>% 
  group_by(group, time) %>%
  summarise(mean_value = mean(!!sym(unit), na.rm = TRUE),
            .groups = 'drop')
  
  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post \np = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "   |   BH p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3),
    "\n----- WITHOUT OUTLIERS -----",
    "\n p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 2:4]), format = "f", digits = 3),
    "   |   BH p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 8:10]), format = "f", digits = 3)
  )
  
  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3),
    "\n----- WITHOUT OUTLIERS -----\n",
        "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 13]), format = "f", digits = 3)
  )

      # Dynamic y-axis label depending on the unit

  if("Cer ratio" %in% filtered_data$lipidClass){
 y_label_text <- "Cer 16:0 to 24:0 ratio" }
  else{
  y_label_text <- switch(unit,
  pmol_mg = expression("Lipid concentration" ~ "(pmol ·" ~ mg^-1 * ")"),
  pmol_mg_log = expression("Log transformed lipid concentration"),
  "No label"  # Default case if none of the above
)}

  # Make the plot
  plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = !!sym(unit), group = interaction(id, group)
  )) +
    geom_line(aes(group = interaction(id, group), color = id), position = position_nudge(x = 0.00)) +
    
      geom_point(aes(color = id), alpha = 0.5, position = position_nudge(x = 0.0)) +
    geom_boxplot(aes(group = interaction(group, time)), color = "black",
      width = 0.3, alpha = 0.2, outlier.shape = NA,
      position = position_dodge(width = 0.75)
    ) +
    # Up triangle for values above ULOQ
    geom_point(
      data = subset(filtered_data, within_threshold == 2), aes(y = !!sym(unit), color = id), size = 3, shape = 24,
      alpha = 1, position = position_nudge(x = 0.00), show.legend = FALSE 
    ) +
    # Down triangle for values below LLOQ
    geom_point(
      data = subset(filtered_data, within_threshold == 1), aes(y = !!sym(unit)),color = "darkgrey", size = 3, shape = 25,
      alpha = 1, position = position_nudge(x = 0.00), show.legend = FALSE 
    ) +

    # Cross to signal outlier
    geom_point(
          data = subset(filtered_data, outlier == TRUE), aes(y = !!sym(unit)), color = "black", size = 4, shape = 4,
      alpha = 0.5, position = position_nudge(x = 0.00), show.legend = FALSE 
    ) +
    
      geom_line(data = mean_data_comp, aes(x = interaction(group, time, sep = " "), y = mean_value, group = group), color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
     
    # scale_color_manual(values = c("M" = "blue", "F" = "red"), name = "Gender") +
    labs(
      title = paste(lipid_class, lipid_composition),
      subtitle = annotation_pvals_slope,
      y = y_label_text,
      x = ""
    ) +

    # Insert P-values pre post
    annotate("text",
      x = c(1.5, 3.5, 5.5), y = max(filtered_data[[unit]]) * 1.02,
      label = annotation_pvals_pre_post, size = 1.75
    ) +
    theme_minimal() +
    theme(
      axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
      legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
      legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), ,
      plot.subtitle = element_text(size = 5, hjust = 0.5)
    )


  # Define the filename and save the plot
  filename <- paste0(
    getwd(), "/outputs/pre_post/scatter composition/", save_subfolder,"/",
    gsub("/", "_", gsub(":", ",", paste(lipid_class, lipid_composition, sep = " "))), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each combination of lipid_class and lipid_composition
unique_lipid_classes <- unique(lipidomicsDF$lipidClass[!lipidomicsDF$lipidClass == "PC.PE"])

for (lipid_class in unique_lipid_classes) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    plot_lipid(lipidomicsDF = lipidomicsDF,
               lipid_composition = lipid_composition,
               lipid_class = lipid_class,
               detection_limits = detection_limits,
               p_val_df = est_and_p_lipid_comp$p.vals,
               p_val_df_outlierRM = est_and_p_lipid_comp.outlierRM$p.vals,
               unit = "pmol_mg",
               save_subfolder = "")
 
    
    # Log tranformed   
 #   plot_lipid(lipidomicsDF,
 #              lipid_composition,
 #              lipid_class, detection_limits,
 #              est_and_p_lipid_class_and_comp$p.vals,
 #              unit = "pmol_mg_log",
 #              save_subfolder = "log_transformed")
  }
}


```

### Lipid class

Scatter plot for each lipid class based on absolute lipid class concentration

```{r}
plot_lipid_class <- function(lipidomicsDF, lipid_class, detection_limits, p_val_df, p_val_df.outlierRM, unit, save_subfolder) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))
  
# MAKE SUM FOR EACH ID
pmol_mg_class_sum <- filtered_data %>%
  group_by(lipidClass, group, id, time) %>%
  summarize(
    sum_pmol_mg = sum(pmol_mg_imp, na.rm = TRUE),
    sum_log_transformed = log(sum_pmol_mg + 1), #Add one to avoid 0 failure during transform
    .groups = "drop"  # Drop the grouping
  )
  
  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]
  pvalues_to_annotate.outlierRM <- p_val_df.outlierRM[p_val_df.outlierRM[, 1] == search_key, ]

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post \np = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "   |   BH p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3),
    "\n----- WITHOUT OUTLIERS -----\n",
    "p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 2:4]), format = "f", digits = 3),
    "   |   BH p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 8:10]), format = "f", digits = 3)
  )

  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3),
    "\n----- WITHOUT OUTLIERS -----\n",
        "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate.outlierRM[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
mean_data_class <- pmol_mg_class_sum %>%
  group_by(group, time) %>%
  summarise(mean_class = mean(!!sym(unit), na.rm = TRUE), .groups = 'drop')
  
# Dynamic Y-labels
if("PC.PE" %in% filtered_data$lipidClass) {
  y_label <- "PE/PC ratio"
}
else {
  y_label <- switch(unit,
    sum_pmol_mg = expression("Lipid concentration" ~ "(pmol ·" ~ mg^-1 * ")"),
    sum_log_transformed = expression("Log transformed concentration"),
    "Default Label"  # This is a fallback if neither of the above cases are true
  )
}

label_height <- max(pmol_mg_class_sum[[unit]])*1
 # If not working change to 3.0

# Create the plot
plot <- ggplot(pmol_mg_class_sum, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = !!sym(unit), group = interaction(id, group)
  )) +
  geom_line(aes(group = interaction(id, group), color = id), alpha = 0.9, linewidth = 0.1, position = position_nudge(x = 0.03)) +
  geom_point(aes(color = id), alpha = 0.5, position = position_nudge(x = 0.03)) +

    geom_boxplot(aes(group = interaction(group, time)),
      width = 0.3, alpha = 0.2, outlier.shape = NA,
      position = position_dodge(width = 0.75), color = "black"
    ) +
  geom_line(data = mean_data_class, aes(x = interaction(group, time, sep = " "), y = mean_class, group = group),color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
  scale_color_manual(values = rainbow(length(unique(filtered_data$id)))) +
  labs(title = lipid_class, 
       subtitle = annotation_pvals_slope, 
       y = y_label,
       x = "") +
  annotate("text", x = c(1.5, 3.5, 5.5), y = label_height, label = annotation_pvals_pre_post, size = 1.75) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
        legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
        legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
        plot.subtitle = element_text(size = 5, hjust = 0.5))


  # Define the filename and save the plot
  filename <- paste0(
    getwd() ,"/outputs/pre_post/scatter class/", save_subfolder, "/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each lipid class
unique_lipid_classes <- unique(lipidomicsDF$lipidClass[!lipidomicsDF$lipidClass == "Cer ratio"])

for (lipid_class in unique_lipid_classes) {
  plot_lipid_class(lipidomicsDF = lipidomicsDF[lipidomicsDF$outlier==FALSE | is.na(lipidomicsDF$outlier),],
                   lipid_class = lipid_class,
                   detection_limits = detection_limits,
                   p_val_df = est_and_p_pvals_lipid_class$p.vals,
                   p_val_df.outlierRM = est_and_p_pvals_lipid_class.outlierRM$p.vals,
                   unit = "sum_pmol_mg",
                   save_subfolder = "")
                   
  
 # plot_lipid_class(lipidomicsDF = lipidomicsDF,
 #                  lipid_class = lipid_class,
 #                  detection_limits = detection_limits,
 #                  p_val_df = est_and_p_lipid_class_and_comp$p.vals,
 #                  unit = "sum_log_transformed",
 #                  save_subfolder = "log_transformed")   
  
}
```

### Z-score lipidClass

Scatter plots of Z-score for each lipid class with lipid classes shown in different colors

```{r}
plot_lipid_class_z_score <- function(lipidomicsDF, lipid_class, detection_limits, p_val_df) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))

  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )

  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
mean_data_class_zscore <- filtered_data %>%
  group_by(group, time) %>%
  summarise(mean_pmol_mg_znorm = mean(pmol_mg_znorm, na.rm = TRUE), .groups = 'drop')
  
# Create the plot
plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = pmol_mg_znorm, group = interaction(id, group)
  )) +
  geom_line(aes(group = interaction(id, group, lipidComposition), color = lipidComposition), alpha = 0.9, size = 0.1, position = position_nudge(x = 0.03)) +
  geom_point(aes(color = lipidComposition), alpha = 0.5, position = position_nudge(x = 0.03)) +
  geom_line(data = mean_data_class_zscore, aes(x = interaction(group, time, sep = " "), y = mean_pmol_mg_znorm, group = group),color = "black", size = 1, position = position_nudge(x = 0.03)) +
  scale_color_manual(values = rainbow(length(unique(filtered_data$lipidComposition)))) +
  labs(title = lipid_class, subtitle = annotation_pvals_slope, y = "Lipid concentration, Z norm [comp within group]", x = "") +
  annotate("text", x = c(1.5, 3.5, 5.5), y = 3.0, label = annotation_pvals_pre_post, size = 2) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
        legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
        legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
        plot.subtitle = element_text(size = 5, hjust = 0.5))


  # Filter the LLOQ and ULOQ for the current lipid_class and set y-axis limits
  y_min <- min(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 0.95 # Adjusted
  y_max <- max(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 1.05 # Adjusted
  plot <- plot + coord_cartesian(ylim = c(y_min, y_max))

  # Define the filename and save the plot
  filename <- paste0(
    getwd(), "/outputs/pre_post/plot, scatter class, z_score/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each lipid class
for (lipid_class in unique_lipid_classes) {
  plot_lipid_class_z_score(lipidomicsDF, lipid_class, detection_limits, est_and_p_pvals_lipid_class$p.vals)
}
```

## Heatmap & volcano plot

### Prepare data

```{r}
# When class and composition is analysed together, merge p-values and correlations

pvals_df <- rbind(est_and_p_pvals_lipid_class.outlierRM$p.vals, est_and_p_lipid_comp.outlierRM$p.vals)
estimates_df <- rbind(est_and_p_pvals_lipid_class.outlierRM$estimates, est_and_p_lipid_comp.outlierRM$estimates)

# Select the specified columns for hm_data.p-vals matrix
pvals_df <- pvals_df[ , c("lipid", "Pre HED - Post HED (corrected)", "Pre DIWL - Post DIWL (corrected)", 
                               "Pre WLEX - Post WLEX (corrected)", "Pre - Post : HED - DIWL (corrected)",
                               "Pre - Post : HED - WLEX (corrected)", "Pre - Post : DIWL - WLEX (corrected)")]


### Calculate log2 change
# Composition
log2fold_ch_comp <- lipidomicsDF %>%
   filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidClass, lipidComposition, group) %>%
  summarize(
    log2fCh = log2(mean(pmol_mg[time == "Post"], na.rm = TRUE) / 
                          mean(pmol_mg[time == "Pre"], na.rm = TRUE)),
    .groups = "drop"
  )

# Class
log2fold_ch_class <- lipidomicsDF %>%
  group_by(lipidClass, group) %>%
  summarize(
    log2fCh = log2(mean(pmol_mg_imp[time == "Post"], na.rm = TRUE) / 
                          mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE)),
    .groups = "drop"
  )

# Make names to match lipid
# Composition
log2fold_ch_comp <- log2fold_ch_comp %>%
  mutate(lipid = paste(lipidClass, lipidComposition, sep = "_")) %>%
  select(-lipidComposition, -lipidClass)

# Class
log2fold_ch_class <- log2fold_ch_class %>%
  rename(lipid = lipidClass)

# Combine lipid composition and lipid class data
log2fold_ch <- rbind(log2fold_ch_class, log2fold_ch_comp)

# Rename col names to match the ones on the DF
log2fold_ch <- log2fold_ch %>%
  mutate(group = case_when(
    group == "HED"  ~ "Pre HED - Post HED",
    group == "DIWL" ~ "Pre DIWL - Post DIWL",
    group == "WLEX" ~ "Pre WLEX - Post WLEX",
    TRUE ~ group  # Keeps the original value if none of the above conditions are met
  ))

### Replace the model change values with the log2change
# Reshape estimates_df from wide to long format to make replacement
estimates_long <- estimates_df %>%
  pivot_longer(
    cols = c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX"),
    names_to = "group",
    values_to = "value"
  )
# perform replacement based on lipid and group
estimates_long_log2ch <- estimates_long %>%
  left_join(log2fold_ch, by = c("lipid", "group")) %>%
  mutate(value = if_else(!is.na(log2fCh), log2fCh, value)) %>%
  select(-log2fCh)

# pivot back to wide format
estimates_df_log2ch <- estimates_long_log2ch %>%
  pivot_wider(
    names_from = group,
    values_from = value
  )

### Slope: Relative changes
# Calculate the mean at time Pre for every lipidComposition within lipidClass and for lipidClass across all groups to use for normalization
lipidomicsDF <- lipidomicsDF %>%
    # Class only
  group_by(lipidClass) %>%
  mutate(pmol_mg_pre_mean_class = ifelse(time == "Pre", mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE), NA)) %>%
  ungroup() %>% 
# Add the mean for composition
  filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidComposition, lipidClass) %>%
  mutate(pmol_mg_pre_mean_comp = ifelse(time == "Pre", mean(pmol_mg[time == "Pre"], na.rm = TRUE), NA)) %>%
  ungroup()


# Calculate absolute pre-post changes
# Composition
slope_norm_ch_comp <- lipidomicsDF %>%
  filter(outlier == FALSE | is.na(outlier)) %>%
  group_by(lipidClass, lipidComposition, group) %>%
  summarize(
    norm_ch = (mean(pmol_mg[time == "Post"], na.rm = TRUE) - 
      mean(pmol_mg[time == "Pre"], na.rm = TRUE)) /
      mean(pmol_mg_pre_mean_comp[time == "Pre"], na.rm = TRUE),
    .groups = "drop"
  )

# Class
slope_norm_ch_class <- lipidomicsDF %>%
  group_by(lipidClass, group) %>%
  summarize(
    norm_ch = (mean(pmol_mg_imp[time == "Post"], na.rm = TRUE) - 
      mean(pmol_mg_imp[time == "Pre"], na.rm = TRUE)) / 
      mean(pmol_mg_pre_mean_class[time == "Pre"], na.rm = TRUE),
    .groups = "drop"
  )


# Make single lipid name for later matching
# Composition
slope_norm_ch_comp <- slope_norm_ch_comp %>%
  mutate(lipid = paste(lipidClass, lipidComposition, sep = "_")) %>%
  select(-lipidComposition, -lipidClass)

# Class
slope_norm_ch_class <- slope_norm_ch_class %>%
  rename(lipid = lipidClass)

# Combine lipid composition and lipid class data
slope_norm_ch <- rbind(slope_norm_ch_class, slope_norm_ch_comp)

# Spread the data for each group to be a separate column
slope_norm_ch_wide <- slope_norm_ch %>%
  pivot_wider(names_from = group, values_from = norm_ch)

# Calculate the difference between slope changes and make pct.
# This makes the values differences in "percentage points"
slope_ch_pp <- slope_norm_ch_wide %>%
  mutate(`Pre - Post : HED - WLEX` = (WLEX - HED)*100,
         `Pre - Post : HED - DIWL` = (DIWL - HED)*100,
         `Pre - Post : DIWL - WLEX` = (WLEX - DIWL)*100)

# Remove the cols with differences between pre and post
slope_ch_pp <- slope_ch_pp %>%
  select(-WLEX, -HED, -DIWL)

# Replace slope values in the estimates data frame
# Join the dataframes based on 'lipid' to align rows
joined_df <- estimates_df_log2ch %>%
  left_join(slope_ch_pp, by = "lipid", suffix = c("", ".normch"))

# Replace values in the original columns with values from the joined columns
estimates_df_plotData <- joined_df %>%
  mutate(`Pre - Post : HED - DIWL` = `Pre - Post : HED - DIWL.normch`,
         `Pre - Post : HED - WLEX` = `Pre - Post : HED - WLEX.normch`,
         `Pre - Post : DIWL - WLEX` = `Pre - Post : DIWL - WLEX.normch`) %>%
  select(-ends_with(".normch"))


# Convert tibble to dataframe for later naming
estimates_df_plotData <- as.data.frame(estimates_df_plotData)
```

### volcano

```{r}
# Turn into two dataframes:
# First: Slope, test_against
# Selecting the relevant columns for transformation
estimates_df_slope <- estimates_df_plotData %>%
  select(lipid, `Pre - Post : HED - DIWL`, `Pre - Post : HED - WLEX`, `Pre - Post : DIWL - WLEX`)

# Transforming into long format
vulc_slope <- estimates_df_slope %>%
  pivot_longer(
    cols = -lipid, # Exclude the 'lipid' column from the reshaping process
    names_to = "test_against", # New column for the original column names
    values_to = "ch_pp" # New column for the values from the reshaped columns
  )

# Second: Pre/post, test_against, p_value
# Selecting the relevant columns for transformation
estimates_df_prePost <- estimates_df_plotData %>%
  select(lipid, `Pre HED - Post HED`, `Pre DIWL - Post DIWL`, `Pre WLEX - Post WLEX`)

# Transforming into long format
vulc_prePost <- estimates_df_prePost %>%
  pivot_longer(
    cols = -lipid, # Exclude the 'lipid' column from the reshaping process
    names_to = "test_against", # New column for the original column names
    values_to = "log2foldch" # New column for the values from the reshaped columns
  )

## Add p-values
# Adjust the names in pvals_df to match those in vulc_slope and vulc_prePost
# First copy pvals_df to not alter
pvals_df_mod <- pvals_df
# then change names
names(pvals_df_mod) <- sub(" \\(corrected\\)", "", names(pvals_df))

# Transform pvals_df into long format
pvals_long <- pvals_df_mod %>%
  pivot_longer(
    cols = -lipid, # Exclude 'lipid'
    names_to = "test_against", # New column for the original column names
    values_to = "p_value" # New column for the p-values
  )

# Join p-values to the dataframes to plot
# Joining p-values to vulc_prePost
vulc_prePost <- left_join(vulc_prePost, pvals_long, by = c("lipid", "test_against"))

# Joining p-values to vulc_slope
vulc_slope <- left_join(vulc_slope, pvals_long, by = c("lipid", "test_against"))

### Make identifier columns based on lipid name and test_against 
# Adding 'identifier' column to vulc_prePost
vulc_prePost <- vulc_prePost %>%
  mutate(identifier = paste(lipid, test_against, sep = " ~ "))

# Adding 'identifier' column to vulc_slope
vulc_slope <- vulc_slope %>%
  mutate(identifier = paste(lipid, test_against, sep = " ~ "))
```

#### Slope

```{r}
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_slope$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)


### Create plot
vulc_plot <- ggplot(vulc_slope, aes(x = ch_pp, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", size = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) + # TRUE for significant, FALSE for not; 1 not translucent; 0.12 very translucent
  geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(ch_pp) > threshold_rho, lipid, "")),
                  box.padding = 0.35, point.padding = 0.5,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  labs(title = "Differences in pre-to-post slopes between groups", x = "Delta slope (pp)", y = "-log10 P-value") +
  xlim(-200,200)+
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) # Hide the alpha legend and fix the color legend

## Display the plot
print(vulc_plot)

# Save the plot
ggsave( paste0(getwd(), "/outputs/pre_post/volcano/slope_volcano.jpg"), plot = vulc_plot, width = 8, height = 10, dpi = 400)
```

#### Pre-post

```{r}
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_prePost$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)


### Create plot
vulc_plot <- ggplot(vulc_prePost, aes(x = log2foldch, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", size = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) + # TRUE for significant, FALSE for not; 1 not translucent; 0.12 very translucent
  geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(log2foldch) > threshold_rho, lipid, "")),
                  box.padding = 0.35, point.padding = 0.5,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  labs(title = "Differences in pre-to-post", x = "log2fc", y = "-log10 P-value") +
  xlim(-2.5,2.5) +
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) # Hide the alpha legend and fix the color legend

## Display the plot
print(vulc_plot)

# Save the plot
ggsave( paste0( getwd(), "/outputs/pre_post/volcano/prePost_volcano.jpg"), plot = vulc_plot, width = 8, height = 10, dpi = 300)
```

### Heatmap

```{r}
# Set 'lipid' as row names
pvals_df_heatMap <- data.frame(pvals_df, check.names = FALSE)
estimates_df_heatMap <- estimates_df_plotData

rownames(pvals_df_heatMap) <- pvals_df_heatMap$lipid
rownames(estimates_df_heatMap) <- estimates_df_heatMap$lipid

# Remove the 'lipid' column
pvals_df_heatMap <- pvals_df_heatMap[ , !(names(pvals_df_heatMap) %in% c("lipid"))]
estimates_df_heatMap <- estimates_df_heatMap[ , !(names(estimates_df_heatMap) %in% c("lipid"))]

# Rename columns by removing " (corrected)" from all column names in pvals_df_heatMap
colnames(pvals_df_heatMap) <- gsub(" \\(corrected\\)", "", colnames(pvals_df_heatMap))

# Sort column names
common_cols <- intersect(colnames(estimates_df_heatMap), colnames(pvals_df_heatMap))
estimates_df_heatMap <- estimates_df_heatMap[, common_cols, drop = FALSE]
pvals_df_heatMap <- pvals_df_heatMap[, common_cols, drop = FALSE]

### Devide dataframe based on lipid groups
# Define lipid groups
lipids_groups <- list(
  gr_tag = c("TAG"),  # Triacylglycerols
  gr_dg_ac = c("1,2-DG", "1,3-DG", "AC"),  # Diglycerides and Acyl carnitines
  gr_pc = c("PC", "PC.PE"),  # Phosphatidylcholines and ratio
  gr_pe = c("PE"),  # Phosphatidylethanolamines
  gr_sphingolipids = c("SPM", "SPH", "Cer", "Cer ratio", "dhCer", "GluCer", "LacCer", "GalCer"),  # Sphingolipids: Sphingomyelins, Sphingosines, Ceramides and derivatives
  gr_lyso = c("LPC", "LPE", "LPG", "LPI", "LPS"),  # Lysophospholipids
  gr_pa_ps = c("PA", "PS"),  # Group combining Phosphatidic acids and Phosphatidylserines
  gr_pg_pi = c("PG", "PI")  # Group combining Phosphatidylglycerols and Phosphatidylinositols
)

### Divide dataframe based on lipid groups with lipid as row name
filter_lipid_group_row <- function(data_frame, lipid_group) {
 
   # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  
  # Convert row names to a temporary column for sorting and filtering
  data_frame_with_lipid <- tibble::rownames_to_column(data_frame, var = "lipid")
  
  # Sort the dataframe by the temporary lipid column
  sorted_data_frame_with_lipid <- data_frame_with_lipid[order(data_frame_with_lipid$lipid), ]
  
  # Filter based on the pattern
  sorted_filtered_data_frame_with_lipid <- sorted_data_frame_with_lipid[grepl(pattern, sorted_data_frame_with_lipid$lipid), ]
  
  # Drop the temporary lipid column and return to original format
  rownames(sorted_filtered_data_frame_with_lipid) <- sorted_filtered_data_frame_with_lipid$lipid
  sorted_filtered_data_frame <- sorted_filtered_data_frame_with_lipid[ , !colnames(sorted_filtered_data_frame_with_lipid) %in% 'lipid', drop = FALSE]
  return(sorted_filtered_data_frame)
}


# Apply the filter function to each group and store the results in a lists
# p-values
pvals_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = pvals_df_heatMap)

# estimates
estimates_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = estimates_df_heatMap)

# Convert all dataframes to matrices
matrices_pvals <- lapply(pvals_gr_list, function(x) as.matrix(x))
matrices_estimates <- lapply(estimates_gr_list, function(x) as.matrix(x))


generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims, hm_title, hm_unit) {
  # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
# Extract test_against by removing the first part (treatment group) and the first underscore
# This joins back the remaining parts to form the full 'test_against' label
colTitles <- c("Slope", "Pre vs Post")

  Heatmap(hm_matrix,
          name = hm_unit, # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 7.5 ), # Change font size of row labels
          
          #column_split = rep(1:(ncol(hm_matrix) / 3), each = 3), # Splits the columns and names them
          column_title = hm_title,
          column_names_rot = 45, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 8, fontface = "bold"),
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 10, fontface = "bold"),
          #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
      
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                  if (p_val_matrix[i, j] < pLims$p1) {
                      grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p2) {
                      grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p3) {
                      grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  }
              }
          })
}

# Define color map for heatmap
color_mapping_slope <- colorRamp2(c(-300, 0, 300), c("blue", "white", "red"))
color_mapping_pre_post <- colorRamp2(c(-3, 0, 3), c("darkgreen", "white", "orange"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
hm <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)) {
  # Generate slope and pre/post hm
  
  hm_slope <- generate_heatmap(matrices_estimates[[i]][,1:3],
                               matrices_pvals[[i]][,1:3],
                               color_mapping_slope,
                               p_value_limits,
                               hm_title = "Slope ", 
                               hm_unit = "pp")
  
  hm_pre_post <- generate_heatmap(matrices_estimates[[i]][,4:6],
                                  matrices_pvals[[i]][,4:6],
                                  color_mapping_pre_post,
                                  p_value_limits,
                                  hm_title = "Pre vs Post",
                                  hm_unit = "log2foldch")
  
  # Combine heat maps and store in list
  hm[[i]] <- hm_slope + hm_pre_post
  # Generate heatmap and store it in the list
}

# Define the path and name of your PDF file
pdf_path <- paste0( getwd(), "/outputs/pre_post/heatmap/heatmap.pdf")

# Open a PDF device
pdf(pdf_path, width = 8, height = 10)

# Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
for (i in 1:length (hm)){
  draw(hm[[i]])
}

# Don't forget to close the device
dev.off()

```

## p-value plots

Make plots of p-values sorted highest to lowest for lipid classes and lipid compositions within each lipid class

```{r}
generate_barplot <- function(data, col_index_non_corrected, col_index_corrected, output_base_path, data_name) {
  # Extract test names based on indices
  test_name_non_corrected <- names(data)[col_index_non_corrected]
  test_name_corrected <- names(data)[col_index_corrected]

  # Use output_base_path directly, no sub-folders created
  output_path <- output_base_path

  # Prepare and sort data for plotting
  data$lipid <- factor(data$lipid, levels = unique(data$lipid))

  # Define common sizes for axis titles and plot title
  axis_title_size <- 13
  plot_title_size <- 10

  # Dynamic adjustment of the label size based on the number of bars (lipids)
  num_bars <- length(unique(data$lipid))
  label_size <- max(2, min(11, 50 / sqrt(num_bars))) # Adjusted dynamically

  # Generate plot for non-corrected p-values
  p1 <- ggplot(data, aes(x = reorder(lipid, .data[[test_name_non_corrected]]), y = .data[[test_name_non_corrected]])) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
    labs(y = "P-value", x = "lipid", title = test_name_non_corrected) +
    theme_minimal() +
    theme(
      axis.title.y = element_text(size = axis_title_size, face = "bold"),
      axis.title.x = element_text(size = axis_title_size, face = "bold"),
      plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = label_size)
    )

  # Generate plot for corrected p-values
  p2 <- ggplot(data, aes(x = reorder(lipid, .data[[test_name_corrected]]), y = .data[[test_name_corrected]])) +
    geom_bar(stat = "identity", fill = "darkgreen") +
    coord_flip() +
    geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
    labs(y = "Corrected P-value", x = "lipid", title = test_name_corrected) +
    theme_minimal() +
    theme(
      axis.title.y = element_text(size = axis_title_size, face = "bold"),
      axis.title.x = element_text(size = axis_title_size, face = "bold"),
      plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = label_size)
    )

  # Combine the two plots
  subplot <- p1 + p2

  # Construct the plot filename
  plot_filename <- paste0(data_name, " ", gsub("[ :()]", " ", test_name_non_corrected), ".jpeg")

  # Save the subplot
  ggsave(file.path(output_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
}

# Define output path
output_base_path <- paste0( getwd(), "/outputs/pre_post/plot, p-value sorted pre-post")

# Column indices to plot against one another; non-corrected vs corrected p-values
cols_to_plot <- matrix(c(2, 8, 3, 9, 4, 10, 5, 11, 6, 12, 7, 13), ncol = 2, byrow = TRUE)

# Loop through each pair of columns and generate the plots
# Lipid class
dataframe_name <- "lipid class"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_pvals_lipid_class$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/class"), dataframe_name)
}

# Lipid class and composition
dataframe_name_comp <- "lipid comp"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_lipid_comp$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/composition"), dataframe_name_comp)
}

# Lipid class and composition
dataframe_name_comp_and_class <- "lipid class and comp"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_lipid_class_and_comp$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/comp_and_class"), dataframe_name_comp)
}

```

# Quality control

### Outlier identification plots

#### Everything grouped within lipid comp and class

```{r}

for (i in 1:nrow(unique_combinations)) {
  class <- unique_combinations$lipidClass[i]
  comp <- unique_combinations$lipidComposition[i]
  
  # Filter data based on lipid class and composition
  subset_lipidomicsDF <- lipidomicsDF[lipidomicsDF$lipidClass == class & lipidomicsDF$lipidComposition == comp,]
  
  # Compute log transformation for plotting
  subset_lipidomicsDF$pmol_mg_log <- log10(subset_lipidomicsDF$pmol_mg + 1)
  
  # Plot for pmol_mg as a boxplot
  plot_mg_box <- ggplot(data = subset_lipidomicsDF, aes(x = factor(1), y = pmol_mg)) +
    geom_boxplot(outlier.shape = 4, outlier.size = 5, coef = outlier_IQR_factor) +
    geom_point(aes(color = id), position = position_jitter(width = 0.1), alpha = 0.6) +
    geom_point(data = subset(subset_lipidomicsDF, outlier == TRUE), aes(y = pmol_mg), shape = 4, color = "red", size = 5) +
    labs(y = "pmol_mg") +
    theme(axis.title.y = element_text(face = "bold", size = 14), axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
  # Plot for pmol_mg_log as a boxplot
  plot_mg_log_box <- ggplot(data = subset_lipidomicsDF, aes(x = factor(1), y = pmol_mg_log)) +
    geom_boxplot(outlier.shape = 4, outlier.size = 5, coef = outlier_IQR_factor) +
    geom_point(data = subset(subset_lipidomicsDF, outlier_log == TRUE), aes(y = pmol_mg), shape = 4, color = "red", size = 5) +
    geom_point(aes(color = id), position = position_jitter(width = 0.1), alpha = 0.6) +
    labs(y = "pmol_mg_log") +
    theme(axis.title.y = element_text(face = "bold", size = 14), axis.text.x = element_blank(), axis.ticks.x = element_blank())
  
  # Histogram for pmol_mg
  plot_mg_hist <- ggplot(data = subset_lipidomicsDF, aes(x = pmol_mg)) +
    geom_histogram(bins = 8, fill = 'skyblue', color = 'black') +
    labs(x = "pmol_mg", y = "Count") +
    theme_minimal()
  
  # Histogram for pmol_mg_log
  plot_mg_log_hist <- ggplot(data = subset_lipidomicsDF, aes(x = pmol_mg_log)) +
    geom_histogram(bins = 8, fill = 'skyblue', color = 'black') +
    labs(x = "Log Transformed pmol_mg", y = "Count") +
    theme_minimal()
  
 combined_plot <- (plot_mg_box | plot_mg_hist) /
                 (plot_mg_log_box | plot_mg_log_hist) +
                 plot_layout(guides = 'collect', widths = c(1, 1), heights = c(1, 1)) +
                 plot_annotation(title = paste(class, comp), 
                                 theme = theme(plot.title = element_text(hjust = 0.5, size = 20, face = "bold")))

  
  # Create output directory if it doesn't exist
  sanitized_class_comp <- gsub("/", "_", gsub(":", ",", paste(class, comp)))
  output_dir <- paste0(getwd(), "/outputs/", "QC/", "outliers/", "absolute within comp and class/")
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  }
  
  # Define filename and save the combined plot with sanitized filename
  filename <- paste0(output_dir, sanitized_class_comp, ".png")
  ggsave(filename, plot = combined_plot, width = 12, height = 12, dpi = 300)
  
  cat("Plot saved as:", filename, "\n")
}

```

#### Based on change between pre and post

```{r}
calculate_differences <- function(df) {
  # Assuming there is an 'id' column to uniquely identify rows that should be paired
  pre <- df %>% filter(time == "Pre")
  post <- df %>% filter(time == "Post")

  # Join pre and post data to calculate differences
  combined <- left_join(pre, post, by = "id", suffix = c(".pre", ".post"))
  
  # Calculate differences for raw and log-transformed data
  combined$difference <- abs(combined$pmol_mg.post - combined$pmol_mg.pre)
  combined$difference_log <- abs(log(combined$pmol_mg.post + 1) -  log(combined$pmol_mg.pre + 1))
  
  return(combined)
}

plot_differences <- function(df, class, comp, log_transform) {
  
  y_var <- if(log_transform) "difference_log" else "difference"
  y_lab <- if(log_transform) "Difference of log transformed values" else "pmol_mg (Post - Pre)"
  
  # Create a boxplot
  plot_box <- ggplot(df, aes(x = factor(1), y = !!sym(y_var))) +
    geom_boxplot(outlier.shape = 4, outlier.size = 5, coef = outlier_IQR_factor) +
    geom_point(aes(color = id), position = position_jitter(width = 0.1), alpha = 0.6) +
    labs( y = y_lab) +
    theme_minimal() +
    theme(axis.title.y = element_text(face = "bold", size = 14),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          plot.title = element_text(hjust = 0.5))
  
  # Create a histogram
  plot_hist <- ggplot(df, aes(x = !!sym(y_var))) +
    geom_histogram(bins = 8, fill = 'skyblue', color = 'black') +
    labs(x = y_lab, y = "Count") +
    theme_minimal()
  
  return(list(box = plot_box, hist = plot_hist))
}


for (i in 1:nrow(unique_combinations)) {
  class <- unique_combinations$lipidClass[i]
  comp <- unique_combinations$lipidComposition[i]
  
  print(paste0(class, " ", comp))
  # Filter data based on lipid class and composition, for both Pre and Post
  subset_lipidomicsDF <- lipidomicsDF[lipidomicsDF$lipidClass == class & lipidomicsDF$lipidComposition == comp,]

  # Calculate differences
  differences_df <- calculate_differences(subset_lipidomicsDF)
  
  # Get plots without and with log transformation
  plots_raw <- plot_differences(differences_df, class, comp, log_transform = FALSE)
  plots_log <- plot_differences(differences_df, class, comp, log_transform = TRUE)
  
  # Combine plots into a 2x2 grid
  combined_plot <- (plots_raw$box | plots_raw$hist) / (plots_log$box | plots_log$hist) +
                   plot_layout(guides = 'collect') +
                   plot_annotation(title = paste("Changes, ", class, comp), 
                                   theme = theme(plot.title = element_text(hjust = 0.5, size = 20, face = "bold")))
  
  # Define filename using sanitized strings and updated save path
  sanitized_class_comp <- gsub("/", "_", gsub(":", ",", paste(class, comp)))
  output_dir <- paste0(getwd(), "/outputs/QC/outliers/changes within comp and class/")
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  }
  filename <- paste0(output_dir, sanitized_class_comp, ".png")
  
  # Save the combined plot with sanitized filename
  ggsave(filename, plot = combined_plot, width = 12, height = 12, dpi = 300)
  
  cat("Plot saved as:", filename, "\n")
}

```

#### QQ plots

```{r}
# Define output directory and ensure it exists
output_dir <- file.path(getwd(), "outputs", "QC", "qq")
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

# Iterate over each unique combination of lipidClass and lipidComposition
for (i in 1:nrow(unique_combinations)) {  
  # is this needed? [unique_combinations$lipidClass != c("Cer ratio", "PC.PE")
  class <- unique_combinations$lipidClass[i]
  comp <- unique_combinations$lipidComposition[i]
  
  print( paste0("Analysing ",class, " ", comp))
  
   # class <- "PC.PE"
   # comp <- "ratio"
  
  # Initialize the plotting layout before saving the plots
  png(file.path(output_dir, paste0(gsub("[/:]", "_", paste(class, comp)), ".png")), width = 1200, height = 800)
  par(mfrow = c(6, 2))
  
  # Iterate over groups and times
  for (group in c("HED", "DIWL", "WLEX")){
    for (time in c("Pre", "Post")){
  
      print(group); print(time)
      
      # Load data subset
      class_comp <- lipidomicsDF[
        lipidomicsDF$lipidClass == class &
          lipidomicsDF$lipidComposition == comp &
          lipidomicsDF$time == time &
          lipidomicsDF$group == group &
           (lipidomicsDF$outlier == FALSE | is.na(lipidomicsDF$outlier))
        ,]
      
      ## Non-transformed Data QQ Plots
      if (length(class_comp$pmol_mg) >= 3 && length(unique(class_comp$pmol_mg)) > 1)  {
        shapiro_result_nonTransformed <- shapiro.test(class_comp$pmol_mg)
        shapiro_p_value_nonTransformed <- sprintf("%.4f", shapiro_result_nonTransformed$p.value)
      } else {
        shapiro_p_value_nonTransformed <- "NA"
      }
      
      # Q-Q plot for non-transformed data
      qqnorm(class_comp$pmol_mg, main = paste0(group, " ", time, " Non-Transformed"))
      qqline(class_comp$pmol_mg, col = "red")
      mtext(sprintf("Shapiro-Wilk p=%s", shapiro_p_value_nonTransformed), side = 3, adj = 0.05, line = 2, cex = 0.8)
      
      ## Log-transformed Data QQ Plots
      if (
        length(class_comp$pmol_mg_log) >= 3 && 
        length(unique(class_comp$pmol_mg_log)) > 1 &&
        !is.na(class_comp$pmol_mg_log[1])) {
        shapiro_result_logTransformed <- shapiro.test(class_comp$pmol_mg_log)
        shapiro_p_value_logTransformed <- sprintf("%.4f", shapiro_result_logTransformed$p.value)
      } else {
        shapiro_p_value_logTransformed <- "NA"
      }
      
      if (
        length(class_comp$pmol_mg_log) >= 3 && 
        !is.na(class_comp$pmol_mg_log[1]))
        {
        qqnorm(class_comp$pmol_mg_log, main = paste0(group, " ", time, " Log-Transformed"))
        qqline(class_comp$pmol_mg_log, col = "red")
        mtext(sprintf("Shapiro-Wilk p=%s", shapiro_p_value_logTransformed), side = 3, adj = 0.05, line = 2, cex = 0.8)
      } else {
        plot(1, type="n", main = paste0(group, " ", time, " Insufficient Data for Log Transformation"))
        mtext("Log transformed data insufficient", side=3, line=3)
      }
    }
  }

  # Reset to default plotting layout and close the device
  par(mfrow = c(1, 1))
  dev.off()

}

```
