---
title: "MIRAGEdata"
purpose: To load, merge, explore, and plot lipidomics data and look for correlations with cardiometabolic endpoints the MIRAGE dataset.
output:
html_notebook: default
author: Ole Emil Andersen
date created: March 2024
editor_options: 
chunk_output_type: console
---

**Packages**
```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(readxl) # reads Excel files
library(dplyr) # to manipulate data
library(tidyr) # facilitates tidy data transformation.
library(purrr) # enhances programming capabilities
library(tibble) # to make columns into row-names
library(janitor) # to clean column names
library(ggplot2) # for plots
library(grid) # to draw and annotate outside plots in figures
library(GGally) # makes pairwise plots
library(patchwork) # to make ggplot subplots
library(lme4) # for mixed models
library(emmeans) # for p-values and confidence intervals
library(lmerTest) # p-values for mixed models
library(correlation) # to analyse data for correlations
library(ComplexHeatmap); library(circlize) # to make complex heatmaps
```
# Project settings
Cut offs and values to be used throughout the analysis
```{r}
# Number of points above 0 needed for an analysis to take place. The number is the number of id's within class across all intervention groups.
analysis_cutoff <- 15

LLOQ_discard_factor <- 3
```


# Load and prepare data
## Lipidomics data
Load data into long format and clean the data by replacing <0 with 0 and N/A with 0.

```{r, message=FALSE}
# Define the path to the Excel file
file_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/data-raw/2022Mar Goodpaster Results With Name Spaces.xlsx"

# List sheet names to load from excel file
sheet_names <- c("SPM SPH AC", "PG", "PI", "PS", "PA", "PE", "PC", "1,3-DAGs", "1,2-DAGs", "Cer dHCer GluCer LacCer GalCer", "TAG")

load_sheets_in_long_format <- function(file_path, sheet_names) {
  map_df(sheet_names, ~ {
    # Read the measurement names from the first row
    measurement_names <- read_excel(file_path, sheet = .x, n_max = 1) %>%
      colnames()

    # Read the data, skipping the first two rows
    data <- read_excel(file_path, sheet = .x, skip = 2, col_names = FALSE)

    # Limit the data to match the number of columns in the column names
    num_cols_in_names <- length(measurement_names)
    data_trimmed <- data[, 1:num_cols_in_names]

    # Assign column names to the data
    colnames(data_trimmed) <- c("Sample Name", measurement_names[-1])

    # Adjusting the replacement for "< 0" with 0 (as numeric) and "N/A" with NA
    data_cleaned <- data_trimmed %>%
      mutate(across(everything(), ~ case_when(
        .x == "< 0" ~ "0", # Replace "< 0" with "0"
        .x == "N/A" ~ "0", # Replace "N/A" with "0"
        TRUE ~ as.character(.x) # Keep other values as-is, converting to character to ensure type consistency
      ))) %>%
      type.convert(as.is = TRUE) # Convert back to original type where possible

    # Rename "Sample Name" to "sampleNumber"
    colnames(data_cleaned)[1] <- "sampleNumber"

    # Transform to long format
    data_long <- pivot_longer(data_cleaned, -sampleNumber, names_to = "measurement", values_to = "pmol")

    # Split the measurement into class and structure based on space
    data_long <- data_long %>%
      separate(measurement, into = c("lipidComposition", "lipidClass"), sep = " ", extra = "merge")

    return(data_long)
  }, .id = "sheet")
}

# Load all specified sheets into a single data frame in long format
lipidomicsDF <- load_sheets_in_long_format(file_path, sheet_names)

# Remove sheet column
lipidomicsDF <- select(lipidomicsDF, -sheet)
```

### Identifiers, samples and PBIS
**Load identifiers and sample weights** and merge with the data frame and split the pid into pre/post and id.
```{r}
# path to file
filePathIdentifiers <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/data-raw/Lipidomics Key and Weights Goodpaster KZB_identifiable.xlsx"

# load file
identifiersDF <- read_excel(filePathIdentifiers)

# clean names to rename columns to be R friendly
identifiersDF <- clean_names(identifiersDF)

# Make tube_id character
identifiersDF$tube_id <- as.character(identifiersDF$tube_id)

# Combine identifiers with data
lipidomicsDF <- left_join(lipidomicsDF, identifiersDF, by = c("sampleNumber" = "tube_id"))

# Split pid column into an id and a time column
lipidomicsDF <- separate(lipidomicsDF, pid, into = c("id", "time"), sep = " ", extra = "merge")

# Make time, lipidClass, id and group categorical variables
lipidomicsDF$time <- factor(lipidomicsDF$time, levels = c("Pre", "Post")) # sort by pre and post
lipidomicsDF$lipidClass <- factor(lipidomicsDF$lipidClass)
lipidomicsDF$id <- factor(lipidomicsDF$id)
lipidomicsDF$group <- factor(lipidomicsDF$group)
lipidomicsDF$lipidComposition <- factor(lipidomicsDF$lipidComposition)

# Remove PBIS rows
lipidomicsDF <- lipidomicsDF %>%
  filter(id != "PBIS")
```

### Quantification limits
Values are copied from the lipidomics Excel file, "2022Mar Goodpaster Results.xlsx"
```{r}
detection_limits <- data.frame(
  lipidclasses = c("SPH", "AC", "SPM", "PG", "LPG", "PI", "LPI", "PS", "LPS", "PA", "PE", "LPE", "PC", "LPC", "1,3-DG", "1,2-DG", "Cer", "dhCer", "GluCer", "LacCer", "GalCer", "TAG"),
  LLOQ = c(0.08, 0.16, 1.2, 0.6, 0.03, 2.5, 1, 2.5, 0.05, 0.1, 2.5, 1, 7, 3, 0.34, 0.68, 0.25, 0.05, 0.1, 0.2, 0.1, 10),
  ULOQ = c(320, 640, 4800, 2400, 100, 10000, 4000, 10000, 200, 400, 10000, 4000, 28000, 12000, 1360, 2720, 1000, 200, 400, 800, 400, 40000)
)
```

Make column to denote if measurement is within (0), below LLOQ (1), above ULOQ (2) or above ULOQ * the defined discard factor (3).
Values that are discarded are made Na.
```{r}
limitFunction <- function(lipidomicsDF, detection_limits){
# Initialize the 'within_threshold' column
lipidomicsDF$within_threshold <- NA

# Loop through each row in lipidomicsDF
for (i in 1:nrow(lipidomicsDF)) {
  # Retrieve the current lipidClass and pmol value
  current_lipidClass <- lipidomicsDF$lipidClass[i]
  current_pmol <- lipidomicsDF$pmol[i]

  # Find matching LLOQ and ULOQ values from detection_limits
  current_LLOQ <- detection_limits$LLOQ[detection_limits$lipidclasses == current_lipidClass]
  current_ULOQ <- detection_limits$ULOQ[detection_limits$lipidclasses == current_lipidClass]
  
  # Check the pmol value against LLOQ and ULOQ and assign the 'within_threshold'
  if (is.na(current_pmol) | length(current_LLOQ) == 0 | length(current_ULOQ) == 0) {
    lipidomicsDF$within_threshold[i] <- NA # Assign NA if there's an NA value in pmol or LLOQ/ULOQ cannot be found
  } else if (current_pmol < current_LLOQ) {
    lipidomicsDF$within_threshold[i] <- 1 # Below LLOQ
  } else if (current_pmol > (current_ULOQ * LLOQ_discard_factor)) { # Above value to be discarded
    lipidomicsDF$within_threshold[i] <- 3
    lipidomicsDF$pmol[i] <- NA # Corrected to set only the current row's pmol to NA
  } else if (current_pmol > current_ULOQ) {
    lipidomicsDF$within_threshold[i] <- 2 # Above ULOQ
  } else {
    lipidomicsDF$within_threshold[i] <- 0 # Within the threshold
  }
}
return (lipidomicsDF)
}

lipidomicsDF <- limitFunction(lipidomicsDF, detection_limits)
```

### Normalization and transformation
**Weight normalization**
```{r}
lipidomicsDF$pmol_mg <- lipidomicsDF$pmol / lipidomicsDF$equiv_weight_extracted
```
**Log transform**
Log transform the weight normalized lipidomics data. 1 is added to all values to avoid zores
```{r}
# Transform and add a small constant (+1) to avoid log(0)
lipidomicsDF <- lipidomicsDF %>%
  mutate(pmol_mg_log = log(pmol_mg + 1))
```

**Z-transformation**
```{r}
# Make column with Z-transformed data for each lipid composition within each lipid class
lipidomicsDF <- lipidomicsDF %>%
  group_by(lipidClass, lipidComposition) %>%
  mutate(pmol_mg_znorm = scale(pmol_mg)) %>%
  ungroup()
```

**Sort data**
```{r}
# Sort the dataframe by 'id' and 'time'
lipidomicsDF <- lipidomicsDF %>%
  arrange(id, time)

# Find all lipidClass-lipidComposition
unique_combinations <- lipidomicsDF %>%
  distinct(lipidClass, lipidComposition) %>%
  arrange(lipidClass, lipidComposition)
```

**Define unique lipid classes**
```{r}
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
```


## Mirage data
**Load from "FINAL MIRAGE DATASET.xlsx"**

!!! DUPLICATE IDS: "MG023" and "MG019" both are duplicates that appear with same group as in id from Pittsburg and TRI. Assumption: All samples are from TRI if not specified otherwise. Therefore, the Excel file "FINAL MIRAGE DATASET.xlsx", sheet "Not Imputed-Clean" was changed to make the merge work. All changes are marked with red text.

```{r}
# path to file
file_path_endpoints <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/data-raw/FINAL MIRAGE DATASET.xlsx"

# load file
mirage_data <- read_excel(file_path_endpoints, sheet = "Not Imputed-Clean")

# clean names
mirage_data <- clean_names(mirage_data)

# separate pid into id and site
mirage_data <- separate(mirage_data, pid, into = c("id", "site"), sep = "-", extra = "merge")

# Remove redundant columns
mirage_data <- select(mirage_data, -study_center)


# Adjust column names, and move pre and post to the end of the name
# Loop through each column name in mirage_data
new_col_names <- sapply(names(mirage_data), function(col_name) {
  # Check if "_pre" is in the column name
  if (grepl("_pre", col_name)) {
    col_name <- gsub("_pre", "", col_name) # Remove "_pre"
    col_name <- paste0(col_name, "_pre") # Add "_pre" to the end
  }
  # Check if "_post" is in the column name
  if (grepl("_post", col_name)) {
    col_name <- gsub("_post", "", col_name) # Remove "_post"
    col_name <- paste0(col_name, "_post") # Add "_post" to the end
  }
  return(col_name)
})

# Update the column names of mirage_data
names(mirage_data) <- new_col_names
```

**Calculate additional rows**
```{r}
mirage_data$tdee_kcal_24hr_ffm_pre <- mirage_data$tdee_kcal_24hr_pre / mirage_data$lean_mass_dxa_pre
```

### Select variables & long format
**pre-post variables**
Define variables of interest for pre-post delta correlations against lipids.
```{r}
# List with pre-post variables of interest
mirage_ch_vars <- list(
  c("rd_ss1kg_ffm_insulin_pre", "rd_ss1kg_ffm_insulin_post"),
  c("weight_pre", "weight_post"),
  c("vo2kg_ffm_pre", "vo2kg_ffm_post"),
  c("thigh_imat_mri_pre", "thigh_imat_mri_post"),
  c("at_pmax_p_mrs_pre", "at_pmax_p_mrs_post"),
  c("homair_pre", "homair_post"),
  c("pcr_p_mrs_pre", "pcr_p_mrs_post"),
  c("thigh_muscle_mri_pre", "thigh_muscle_mri_post"),
  c("fasting_insulin_m_iu_m_l_pre", "fasting_insulin_m_iu_m_l_post"),
  c("age_pre", "age_post") # Age must appear last in this list!
)
```

**Cross-sectional variables**
Define variables of interest to compare between all individuals at pre

```{r}
mirage_crossSectional_vars <- list(
  c(
    "rd_ss1kg_ffm_insulin_pre",
    "weight_pre",
    "age_pre",
    "vo2kg_ffm_pre",
    "thigh_imat_mri_pre",
    "at_pmax_p_mrs_pre",
    "homair_pre",
    "pcr_p_mrs_pre",
    "thigh_muscle_mri_pre",
    "max_oxphos_pre",
    "tdee_kcal_24hr_ffm_pre",
    "hgb_a1c_pre"
  )
)
```

**Mirage long format**
Convert Mirage dataset with selected variables into long format with selected Pre|Post varibles 

```{r}
# Flatten the list of column names into a single vector
columns_to_merge <- unlist(mirage_ch_vars)

# Select columns from 'mirage_data' including the 'id' column
mirage_data_subset <- mirage_data[c("id", columns_to_merge)]

# Filter out the ids based on the ids in lipidomicsDF
mirage_data_subset <- mirage_data_subset %>%
  filter(id %in% lipidomicsDF$id)

# Transform 'mirage_data_subset' to long format
mirage_data_long_ch <- pivot_longer(
  mirage_data_subset,
  cols = -id, # Exclude 'id' from the pivoting
  names_to = c(".value", "time"), # Separate original column name into variable name and time
  names_pattern = "(.+)_(pre|post)" # Pattern to split the variable names and time
)

# Adjust the 'time' column in 'mirage_data_long_ch' to match 'Pre' and 'Post'
mirage_data_long_ch <- mirage_data_long_ch %>%
  mutate(time = case_when(
    time == "pre" ~ "Pre",
    time == "post" ~ "Post",
    TRUE ~ time # This line is a safety net; it keeps the original value if it's neither 'pre' nor 'post'
  ))

# Remove rows where all measurements are NA
mirage_data_long_ch <- mirage_data_long_ch %>%
  group_by(id, time) %>%
  filter(!all(is.na(age)))
```

# Analysis based on changes

## Prepare data (function)

Function to prepare and merge data into wide format

```{r}
# Function to prepare data
prepare_and_combine_data <- function(lipidomicsData, pre_post_cols, mirageData, lipidclass, lipidcomposition) {
  # Filter and prepare lipidomics data
  if (is.null(lipidcomposition)) {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
  } else {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass, lipidComposition == lipidcomposition)
    
  }
    
  # - - -
  # Remove lipid composition within lipid class if fewer non-zero values than the analysis_cutoff. Only for lipidComposition. Add new col called to to_analyse in based on number of non_zero_rows
  non_zero_rows <- lipidomics_selected %>%
  filter(pmol_mg > 0)
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, lipidComposition, pmol_mg)

  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = pmol_mg, names_prefix = "pmol_mg_") %>%
    relocate(id, .before = everything()) # Moves id to front

  # Calculate delta value
  lipidomics_wide$pmol_mg_ch <- lipidomics_wide$pmol_mg_Post - lipidomics_wide$pmol_mg_Pre

  # Adding a small constant to avoid log2(0) if there are zeros
pseudo_count <- 1

# Calculate log2 fold change directly within the dataset
lipidomics_wide <- lipidomics_wide %>%
  mutate(lipid_log2fold = log2((pmol_mg_Post + pseudo_count) / (pmol_mg_Pre + pseudo_count)))

# Calculate the mean log2 fold change and abs change for each ID, then add them back to the original dataframe
lipidomics_wide <- lipidomics_wide %>%
  group_by(id) %>%
  # Calculate mean log2 fold change for each ID
  mutate(lipid_log2fold_id_avg = mean(lipid_log2fold, na.rm = TRUE),
         # Calculate absolute change for each ID
         pmol_mg_ch_id = sum(pmol_mg_Post, na.rm = TRUE) - sum(pmol_mg_Pre, na.rm = TRUE),
         # Assign row number for each group to identify the first occurrence
         row_num = row_number()) %>%
  # Calculate log2fold change for each ID across all points
  mutate(lipid_log2fold_id = log2((sum(pmol_mg_Post, na.rm = TRUE) + pseudo_count) / 
                                   (sum(pmol_mg_Pre, na.rm = TRUE) + pseudo_count))) %>%
  ungroup() %>%
  # Only retain the calculated values for the first occurrence of each ID
  mutate(lipid_log2fold_id_avg = if_else(row_num == 1, lipid_log2fold_id_avg, NA_real_),
         pmol_mg_ch_id = if_else(row_num == 1, pmol_mg_ch_id, NA_real_),
         lipid_log2fold_id = if_else(row_num == 1, lipid_log2fold_id, NA_real_)) %>%
  # Remove the auxiliary row number column
  select(-row_num)
  
  
  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")

  # Dynamically calculate deltas for specified pre/post columns
  for (col_pair in pre_post_cols) {
    pre_col <- col_pair[1]
    post_col <- col_pair[2]
    delta_col_name <- paste0(sub("_pre", "", pre_col), "_ch")

    # Calculate deltas
    combined_df <- combined_df %>%
      mutate(!!sym(delta_col_name) := as.numeric(.[[post_col]]) - as.numeric(.[[pre_col]]))
  }

  # Convert specified columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))

      # If lipid composition 
  if (!is.null(lipidcomposition) & nrow(non_zero_rows) < analysis_cutoff){
    combined_df$skipAnalysis <- TRUE
  }else{
        combined_df$skipAnalysis <- FALSE
    }
  
  return(combined_df)
}
```

## Statistics (function)
Function to get correlation between changes of defined parameters

```{r}
# Define a function to compute correlations of change
correlation_of_change <- function(correlation_df, lipidomicsDF, mirage_data_long_ch, mirage_variables_of_interest, lipidclass, lipidcomposition) {

  
      # Determine the lipid name based on the presence of lipid composition
    if (is.null(lipidcomposition)) {
      lipidName <- lipidclass
    } else {
      lipidName <- paste0(lipidclass, " ", lipidcomposition)
    }
  
  # Only run code if correlation df is not NA. If, Na, assign NA values to all correlation results
  if (correlation_df$skipAnalysis[[1]] == TRUE){
       # Assign NA to all results
  correlation_results <- data.frame(
    lipid = lipidName,
    test_against = NA,
    pearson_r_all = NA,
    pearson_p_all = NA,
    spearman_rho_all = NA,
    spearman_p_all = NA,
    mixed_cor_all = NA,
    mixed_p_all = NA,
    pearson_r_HED = NA,
    pearson_p_HED = NA,
    spearman_rho_HED = NA,
    spearman_p_HED = NA,
    pearson_r_DIWL = NA,
    pearson_p_DIWL = NA,
    spearman_rho_DIWL = NA,
    spearman_p_DIWL = NA,
    pearson_r_WLEX = NA,
    pearson_p_WLEX = NA,
    spearman_rho_WLEX = NA,
    spearman_p_WLEX = NA
  )
  } else {
      
   # Initialize an empty data frame to store correlation results
  correlation_results <- data.frame(
    lipid = character(),
    test_against = character(),
    pearson_r_all = numeric(),
    pearson_p_all = numeric(),
    spearman_rho_all = numeric(),
    spearman_p_all = numeric(),
    mixed_cor_all = numeric(),
    mixed_p_all = numeric(),
    pearson_r_HED = numeric(),
    pearson_p_HED = numeric(),
    spearman_rho_HED = numeric(),
    spearman_p_HED = numeric(),
    pearson_r_DIWL = numeric(),
    pearson_p_DIWL = numeric(),
    spearman_rho_DIWL = numeric(),
    spearman_p_DIWL = numeric(),
    pearson_r_WLEX = numeric(),
    pearson_p_WLEX = numeric(),
    spearman_rho_WLEX = numeric(),
    spearman_p_WLEX = numeric()
  )
  
  # Loop over every mirage variables of interest
  for (df in mirage_variables_of_interest) {
    # Manipulate current variable name
    test_against_name <- (df[[1]])
    test_against_name_clean <- sub("_pre$", "", test_against_name)
    test_against_name <- sub("pre$", "ch", test_against_name)

    # Skip this iteration if the first column's name is "age"
    if (test_against_name_clean == "age") {
      next
    }

    # Add new row to output df
    correlation_results <- add_row(correlation_results)

    # Identify the index of the current row
    current_row_index <- nrow(correlation_results)

    # Assign lipid name and test against to last row
    correlation_results$lipid[current_row_index] <- lipidName
    correlation_results$test_against[current_row_index] <- test_against_name

    # Use pmol_mg_ch for composition within group. Use lipid_log2fold_id_avg for lipid class.
    if (is.null(lipidcomposition)) {
      lipid_unit <- "pmol_mg_ch_id"
    } else {
      lipid_unit <- "pmol_mg_ch"
    }


    # Perform Pearson and Spearman correlations for all data
    result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
    result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)


    # Assign results the the results df
    correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
    correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
    correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
    correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p

    # Calculate correlations for each group
    for (current_group in unique(correlation_df$group)) {
      # Filter the dataframe for the current group
      correlation_df_group <- filter(correlation_df, group == current_group)

      # Perform Pearson and Spearman correlations for the current group
      result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
      result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)

      # Dynamic assignment of results based on the current group
      pearson_r_col <- paste0("pearson_r_", current_group)
      pearson_p_col <- paste0("pearson_p_", current_group)
      spearman_rho_col <- paste0("spearman_rho_", current_group)
      spearman_p_col <- paste0("spearman_p_", current_group)

      correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
      correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
      correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
      correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
    }

    # Merge this transformed subset with 'lipidomicsDF' based on 'id' and 'time'
    merged_data <- left_join(lipidomicsDF, mirage_data_long_ch, by = c("id", "time"))

    # Prepare lipidomics data
    if (is.null(lipidcomposition)) {
      merged_data_filtered <- filter(merged_data, lipidClass == lipidclass)
    } else {
      merged_data_filtered <- filter(merged_data, lipidClass == lipidclass, lipidComposition == lipidcomposition)
    }

    # Ensure 'time' and 'group' are factors
    merged_data_filtered$time <- as.factor(merged_data_filtered$time)
    merged_data_filtered$group <- as.factor(merged_data_filtered$group)

    # Relevel 'time' so 'Pre' is the reference level
    merged_data_filtered$time <- relevel(merged_data_filtered$time, ref = "Pre")

    # Relevel 'group' so 'HED' is the reference level
    merged_data_filtered$group <- relevel(merged_data_filtered$group, ref = "HED")

    # Attempt to construct the formula, fit the model, and extract results
    tryCatch(
      {
        # Construct the formula as a string
        model_formula_str <- paste0(
          "pmol_mg ~ time * group * ", test_against_name_clean,
          " + time:", test_against_name_clean, " + (1|id)"
        )
        model_formula <- as.formula(model_formula_str)

        # Fit the mixed model to the filtered and merged data using the dynamic formula
        model <- lmer(model_formula, data = merged_data_filtered)

        # Model summary
        model_summary <- summary(model)

        # Extract p-value and correlation (assuming correlation here means the same as in the comment, which may be a typo)
        # Construct the Index String Dynamically
        index_string <- paste("timePost:", test_against_name_clean, sep = "")

        correlation_results$mixed_p_all[current_row_index] <- model_summary$coefficients[index_string, "Pr(>|t|)"]
        correlation_results$mixed_cor_all[current_row_index] <- model_summary$coefficients[index_string, "Pr(>|t|)"]
      },
      error = function(e) {
        # Handle error
        cat("An error occurred: ", e$message, "\n")
      }
    )
  }
  }
  return(correlation_results)
}
```

## Plot, scatter (function)

```{r}
correlation_change_plot <- function(correlation_df, mirage_ch_vars, correlation_results, savePath, lipidclass, lipidcomposition) {
  # Make lipid name
  if (is.null(lipidcomposition)) {
    lipidName <- lipidclass
  } else {
    lipidName <- paste0(lipidclass, " ", lipidcomposition)
  }

  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pmol_mg_ch))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(lapply(mirage_ch_vars, function(x) sub("_pre", "_ch", x[1])))
    # Remove "age_ch" from the vector if it exists
    plotVars <- plotVars[plotVars != "age_ch"]

    # If lipidcomposition is null, the only plot class
    if (is.null(lipidcomposition)) {
      # Add lipid variable to plotVars
      # Make plot with log2 fold change if only class is available
      plotVars <- c("pmol_mg_ch_id", plotVars)

      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars
      )
    } else {
      # Add lipid variable to plotVars
      plotVars <- c("pmol_mg_ch", plotVars)

      # Now use ggpairs on the renamed dataframe
      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars,
        lower = list(continuous = wrap("smooth", method = "none", se = FALSE))
      )
    }

    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }

    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)

      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
        x = Inf, y = Inf,
        label = paste0(
          "Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
          ", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
          "\nSpearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
          ", rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
          "\nHED: Pearson, p = ", formatC(correlation_row$pearson_p_HED, format = "f", digits = 3),
          ", r = ", formatC(correlation_row$pearson_r_HED, format = "f", digits = 3),
          "\nSpearman, p = ", formatC(correlation_row$spearman_p_HED, format = "f", digits = 3),
          ", rho = ", formatC(correlation_row$spearman_rho_HED, format = "f", digits = 3),
          "\nDIWL: Pearson, p = ", formatC(correlation_row$pearson_p_DIWL, format = "f", digits = 3),
          ", r = ", formatC(correlation_row$pearson_r_DIWL, format = "f", digits = 3),
          "\nSpearman, p = ", formatC(correlation_row$spearman_p_DIWL, format = "f", digits = 3),
          ", rho = ", formatC(correlation_row$spearman_rho_DIWL, format = "f", digits = 3),
          "\nWLEX: Pearson, p = ", formatC(correlation_row$pearson_p_WLEX, format = "f", digits = 3),
          ", r = ", formatC(correlation_row$pearson_r_WLEX, format = "f", digits = 3),
          "\nSpearman, p = ", formatC(correlation_row$spearman_p_WLEX, format = "f", digits = 3),
          ", rho = ", formatC(correlation_row$spearman_rho_WLEX, format = "f", digits = 3)
        ),
        size = 1.8, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }


    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }

    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }

    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }

  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )

  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 10, height = 8, units = "in")
}
```

## Run functions

```{r}
# Save folder for .jpg output files
savePathClassComp <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/plot, correlations changes composition/"
savePathClass <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/plot, correlations changes class/"

# Initialize an empty data frame to hold all correlation values
correlation_values_ch_composition <- data.frame()
correlation_values_ch_class <- data.frame()

# Loop over each lipid composition within each lipidclass
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
for (lipid_class in unique_lipid_classes) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    # Organize data
    correlation_df <- prepare_and_combine_data(
      lipidomicsData = lipidomicsDF,
      pre_post_cols = mirage_ch_vars,
      mirageData = mirage_data,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition
    )

    # Calculate correlations for changes
    correlation_values_ch_composition <- rbind(correlation_values_ch_composition, correlation_of_change(correlation_df, lipidomicsDF, mirage_data_long_ch, mirage_ch_vars, lipid_class, lipid_composition))

#    # Plot data - Comment out if to be used
#    correlation_change_plot(
#      correlation_df,
#      mirage_ch_vars,
#      correlation_values_ch_composition,
#      savePathClassComp,
#      lipid_class,
#      lipid_composition
#    )
  }
}

# Loop over each lipid class and make plots
for (lipid_class in unique_lipid_classes) {
  # Organize data
  correlation_df <- prepare_and_combine_data(
    lipidomicsData = lipidomicsDF,
    pre_post_cols = mirage_ch_vars,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    lipidcomposition = NULL
  )

  # Calculate correlations for changes
  correlation_values_ch_class <- rbind(correlation_values_ch_class, correlation_of_change(correlation_df, lipidomicsDF, mirage_data_long_ch, mirage_ch_vars, lipid_class, lipidcomposition = NULL))

# # Plot data - un-comment if to be used again
#  correlation_change_plot(
#    correlation_df,
#    mirage_ch_vars,
#    correlation_values_ch_class,
#    savePathClass,
#    lipid_class,
#    lipidcomposition = NULL
#  )
}
```

## Heat map on p-values
```{r}
#Gather the Spearman p-value columns

# Input for function:  correlation_values_ch_composition, correlation_values_ch_class

# For composition data
long_format_p_adj_comp <- correlation_values_ch_composition %>%
  select(lipid, test_against, spearman_p_all, spearman_p_HED, spearman_p_DIWL, spearman_p_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")

# For class data
long_format_p_adj_class <- correlation_values_ch_class %>% 
  select(lipid, test_against, spearman_p_all, spearman_p_HED, spearman_p_DIWL, spearman_p_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")

# Combine both into one data frame
long_format_p_adj.non <- rbind(long_format_p_adj_comp, long_format_p_adj_class)


long_format_cor_comp <- correlation_values_ch_composition %>%
  select(lipid, test_against, spearman_rho_all, spearman_rho_HED, spearman_rho_DIWL, spearman_rho_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")

long_format_cor_class <- correlation_values_ch_class %>%
  select(lipid, test_against, spearman_rho_all, spearman_rho_HED, spearman_rho_DIWL, spearman_rho_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")

long_format_cor <- rbind(long_format_cor_comp, long_format_cor_class)

# Remove Na rows based on NA in correlation
long_format_cor <- long_format_cor %>%
  filter(!is.na(rho_value))

# Use the 'lipid' values to filter long_format_p_adj.non
long_format_p_adj.non <- long_format_p_adj.non %>%
  filter(lipid %in% long_format_cor$lipid)


# Adjust p-values by group
long_format_p_adj.gr <- long_format_p_adj.non %>%
  group_by(test_against) %>%
  mutate(p_value = p.adjust(p_value, method = "BH")) %>%
  ungroup()

# adjust p-values by all columns
long_format_p_adj.all <- long_format_p_adj.non %>%
  mutate(p_value = p.adjust(p_value, method = "BH"))


# Group lipidclasses to make multiple, clean heatmaps
lipids_groups <- list(
  gr_tag_ac = c("TAG", "AC"),  # Glycerolipids and Acyl carnitines
  gr_dg = c("1,2-DG", "1,3-DG"),  # Diglycerides
  gr_pc = c("PC"),  # Phosphatidylcholines
  gr_pa_pe = c("PA", "PE"),  # Phosphatidic acid and Phosphatidylethanolamines
  gr_pg_pi_ps = c("PG", "PI", "PS"),  # Phosphatidylglycerols, Phosphatidylinositols, Phosphatidylserines
  gr_cer_spm_sph = c("SPM", "SPH", "Cer", "dhCer", "GluCer", "LacCer", "GalCer"),  # Sphingomyelins, Sphingosines, Ceramides and derivatives
  gr_lyso = c("LPC", "LPE", "LPG", "LPI", "LPS")  # Lysophospholipids
)


# Define function to filter and sort lipids based on group names
filter_lipid_group_base <- function(data_frame, lipid_group) {
  # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  # Sort the data_frame by lipid column
  sorted_data_frame <- data_frame[order(data_frame$lipid), ]
  # Filter based on the pattern and return the sorted & filtered data frame
  sorted_filtered_data_frame <- sorted_data_frame[grepl(pattern, sorted_data_frame$lipid), ]
  return(sorted_filtered_data_frame)
}

# Apply the filter function to each group and store the results in a lists
# p-values
long_format_p_adj_groups.non <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj.non)
long_format_p_adj_groups.gr <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj.gr)
long_format_p_adj_groups.all <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj.all)
# correlations
long_format_corr_groups <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_cor)


# Function to create 'unique_test_against' column
mutate_unique_column_p <- function(data_frame) {
  data_frame %>%
    mutate(unique_test_against = paste0(sub("spearman_p_", "", spearman_type), "_", test_against))
}

# Adjust the function for correlation data frames if necessary
mutate_unique_column_corr <- function(data_frame) {
  data_frame %>%
    mutate(unique_test_against = paste0(sub("spearman_rho_", "", spearman_type), "_", test_against))
}

# Apply the mutation function to each group's data frames for p-values
long_format_p_adj_groups.non <- lapply(long_format_p_adj_groups.non, mutate_unique_column_p)
long_format_p_adj_groups.gr <- lapply(long_format_p_adj_groups.gr, mutate_unique_column_p)
long_format_p_adj_groups.all <- lapply(long_format_p_adj_groups.all, mutate_unique_column_p)

# Apply the mutation function to each group's data frames for correlations
long_format_corr_groups <- lapply(long_format_corr_groups, mutate_unique_column_corr)


# Function to perform negative log10 transformation and remove p_value column
transform_p_values <- function(df) {
  df %>%
    mutate(p_log10 = -log10(p_value)) %>%
    select(-p_value)
}

# Apply the transformation to each list
long_format_p_adj_log10.non <- lapply(long_format_p_adj_groups.non, transform_p_values)
long_format_p_adj_log10.gr <- lapply(long_format_p_adj_groups.gr, transform_p_values)
long_format_p_adj_log10.all <- lapply(long_format_p_adj_groups.all, transform_p_values)


# # Make p-values positive or negative based on positive or negative correlation
# adjust_p_values_based_on_correlation <- function(df_p, df_cor) {
#   # Ensure the correlation dataframe has the unique_test_against column
#   df_cor <- df_cor %>%
#     mutate(unique_test_against = paste0(sub("spearman_rho_", "", spearman_type), "_", test_against))
#   
#   # Perform the left join, p-value adjustment, and selection
#   df_p <- df_p %>%
#     left_join(select(df_cor, lipid, unique_test_against, rho_value), by = c("lipid", "unique_test_against")) %>%
#     mutate(p_log10 = ifelse(rho_value < 0, -p_log10, p_log10)) %>%
#     select(-rho_value)
#   
#   return(df_p)
# }
# # Apply the adjustment function to each group's data frames in parallel
# long_format_p_adj_groups.non <- Map(adjust_p_values_based_on_correlation, long_format_p_adj_log10.non, long_format_corr_groups)
# long_format_p_adj_groups.gr <- Map(adjust_p_values_based_on_correlation, long_format_p_adj_log10.gr, long_format_corr_groups)
# long_format_p_adj_groups.all <- Map(adjust_p_values_based_on_correlation, long_format_p_adj_log10.all, long_format_corr_groups)

 
# Define a function to spread the data and convert it to a matrix
spread_and_convert_matrix <- function(df, unitName) {
  result_matrix <- df %>%
    select(lipid, unique_test_against, all_of(unitName)) %>%
    pivot_wider(names_from = unique_test_against, 
                values_from = unitName, 
                values_fill = setNames(list(NA), unitName)) %>%
    column_to_rownames(var = "lipid") %>%
    as.matrix()
  return(result_matrix)
}

# Apply the function to each list
matrices_p_adj_non <- lapply(long_format_p_adj_groups.non, function(x) spread_and_convert_matrix(x, "p_value"))
matrices_p_adj_gr <- lapply(long_format_p_adj_groups.gr, function(x) spread_and_convert_matrix(x, "p_value"))
matrices_p_adj_all <- lapply(long_format_p_adj_groups.all, function(x) spread_and_convert_matrix(x, "p_value"))
# To correlation values
matrices_rho <- lapply(long_format_corr_groups, function(x) spread_and_convert_matrix(x, "rho_value"))


generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims) {
  # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
# Extract test_against by removing the first part (treatment group) and the first underscore
# This joins back the remaining parts to form the full 'test_against' label
colTitles <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) paste(x[-1], collapse = "_"))
colTitles <- unique(colTitles)
  
  
# Modify the column names to only show the group
colnames(hm_matrix) <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) {
  # Concatenate the first part with the first four letters of the second part and "..."
  paste0(x[1], "", substr(x[2], 1, 0), "")
})


  Heatmap(hm_matrix,
          name = "rho", # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 7), # Change font size of row labels
          
          column_split = rep(1:(ncol(hm_matrix) / 4), each = 4), # Splits the columns and names them
          column_title = colTitles, # Custom titles for each split
          column_names_rot = 45, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 8, fontface = "bold"),
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 7, fontface = "bold"),
          #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
      
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                  if (p_val_matrix[i, j] < pLims$p1) {
                      grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p2) {
                      grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p3) {
                      grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  }
              }
          })
}

# Define color map for heatmap
color_mapping <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
hm <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)) {
  # Generate heatmap and store it in the list
  hm[[i]] <- generate_heatmap(matrices_rho[[i]], matrices_p_adj_gr[[i]], color_mapping, p_value_limits)
}

# Define the path and name of your PDF file
pdf_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/heatmap/heatmap.pdf"

# Open a PDF device
pdf(pdf_path, width = 12, height = 14)

# Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
for (i in 1:length (hm)){
  draw(hm[[i]])
}

# Don't forget to close the device
dev.off()

```


## Plot p-values sorted
```{r}
# BH correct p-values
# Name the columns that should be adjusted
cols_to_adjust <- c(
  "pearson_p_all", "spearman_p_all", "mixed_p_all",
  "pearson_p_HED", "spearman_p_HED",
  "pearson_p_DIWL", "spearman_p_DIWL",
  "pearson_p_WLEX", "spearman_p_WLEX"
)

# Function to apply BH correction within each "test_against" group
adjust_p_values_within_group <- function(data, cols_to_adjust) {
  data %>%
    group_by(test_against) %>%
    mutate(across(all_of(cols_to_adjust), ~ p.adjust(.x, method = "BH"), .names = "{.col} (corrected)")) %>%
    ungroup()
}

# Apply correct function
# composition
correlation_values_ch_composition <- adjust_p_values_within_group(correlation_values_ch_composition, cols_to_adjust)
# class
correlation_values_ch_class <- adjust_p_values_within_group(correlation_values_ch_class, cols_to_adjust)
# class and composition
# combine data
correlation_values_ch_comp_and_class <- rbind(correlation_values_ch_composition, correlation_values_ch_class)
# Adjust
correlation_values_ch_comp_and_class <- adjust_p_values_within_group(correlation_values_ch_comp_and_class, cols_to_adjust)

### Plot p-values sorted
generate_barplot_ch <- function(data, col_non_corrected, col_corrected, output_base_path, data_name) {
  # Define common sizes for axis titles and plot title
  axis_title_size <- 12
  plot_title_size <- 13

  # Loop over every unique test
  for (test_var in unique(data$test_against)) {
    # Filter based on test variable
    data_test_filtered <- filter(data, test_against == test_var)

    # Remove row if non corrected column is Na
    data_test_filtered <- data_test_filtered[!is.na(data_test_filtered[[col_non_corrected]]), ]

    # Dynamic adjustment of the label size based on the number of bars (lipids)
    num_bars <- length(unique(data_test_filtered$lipid))
    label_size <- max(2, min(10, 50 / sqrt(num_bars))) # Adjusted dynamically


    # Generate plot for non-corrected p-values
    p1 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_non_corrected]]), y = data_test_filtered[[col_non_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_non_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Generate plot for corrected p-values
    p2 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_corrected]]), y = data_test_filtered[[col_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Combine the two plots
    subplot <- p1 + p2

    # Construct the subfolder path based on 'test_var'
    subfolder_path <- file.path(output_base_path, gsub("[ :()]", "_", test_var)) # Replace problematic characters

    # Ensure the subfolder exists
    dir.create(subfolder_path, recursive = TRUE, showWarnings = FALSE)

    # Construct the plot filename, ensuring no problematic characters for file names
    plot_filename <- paste0(gsub("[ :()]", "_", col_non_corrected), ", ", data_name, test_var, ".jpeg") # Replace spaces and special characters with underscores

    # Save the plot
    ggsave(file.path(subfolder_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
  }
}

# RUN FUNCTIONS
# Add a second row to cols_to_adjust with corrected column names
plot_nonadj_vs_adj <- data.frame(original = cols_to_adjust, corrected = paste0(cols_to_adjust, " (corrected)"))

# Just leave empty, as ch already indicates change in file name
dataframe_name_comp <- ""


####### MAKE FOR LIPID COMP AND CLASS!!!

# For lipid class
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/plot, p-value sorted changes/lipid class"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_ch(correlation_values_ch_class, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}

# For lipid class
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/plot, p-value sorted changes/lipid class and composition"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_ch(correlation_values_ch_composition, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}
```


# Cross sectional analysis on pre

Analyse correlation between variables from the mirage dataset and the lipidomics data for all subjects at the time point pre.

## Prepare data (function)

```{r}
# run function test
# Function to prepare data
prepare_and_combine_crossSection <- function(lipidomicsData, mirageData, lipidclass, lipidcomposition) {
  # Filter and prepare lipidomics data
  if (is.null(lipidcomposition)) {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
  } else {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass, lipidComposition == lipidcomposition)
  }
  
        # Remove lipid composition within lipid class if fewer non-zero values than the analysis_cutoff. Only for lipidComposition
  non_zero_rows <- lipidomics_selected %>%
  filter(pmol_mg > 0)
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, lipidComposition, pmol_mg)

  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = pmol_mg, names_prefix = "pmol_mg_") %>%
    relocate(id, .before = everything()) # Moves id to front

  
  ## Calculate sum within each individual to use for lipid class.
lipidomics_wide <- lipidomics_wide %>%
  group_by(id) %>%
  mutate(pmol_mg_id = if_else(row_number() == 1, sum(pmol_mg_Pre), NA_real_)) %>%
  ungroup()
  
  ### Normalize data
  # Normalization has to be within each lipidclass and composition.
  # Calculate z normalization within each lipid composition
  lipidomics_wide <- lipidomics_wide %>%
    group_by(lipidClass, lipidComposition) %>%
    mutate(lipid_normalized_z = scale(pmol_mg_Pre)[, 1]) %>%
    ungroup()

#  # Calculate the mean z-score for each ID
#  mean_z_score_per_id <- lipidomics_wide %>%
#    group_by(id) %>%
#    summarise(lipid_normalized_z_avg = mean(lipid_normalized_z, na.rm = TRUE)) %>%
#    ungroup()
#
#  # Add the normalized data back to original dataframe for only for the first occurrence of each ID
#  lipidomics_wide <- lipidomics_wide %>%
#    left_join(mean_z_score_per_id, by = "id") %>%
#    group_by(id) %>%
#    mutate(
#      row_num = row_number(),
#      lipid_normalized_z_avg = if_else(row_num == 1, lipid_normalized_z_avg, NA_real_)
#    ) %>%
#    select(-row_num) %>%
#    ungroup()

  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")

  # Convert certain columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))

  
  # output Na
  if (!is.null(lipidcomposition) & nrow(non_zero_rows) < analysis_cutoff){
      combined_df$skipAnalysis <- TRUE
    }else{
      combined_df$skipAnalysis <- FALSE
    }
  
      return(combined_df)
}

```

## Statistics (function)

```{r}
# Define a function to compute correlations of change
correlation_cross_sectional <- function(correlation_df, lipidomicsDF, mirage_variables_of_interest, lipidclass, lipidcomposition) {

      # Determine the lipid name based on the presence of lipid composition
    if (is.null(lipidcomposition)) {
      lipidName <- lipidclass
    } else {
      lipidName <- paste0(lipidclass, " ", lipidcomposition)
    }
  
  
  # Make Na if too few values determined from prepare data function
  if (correlation_df$skipAnalysis[[1]] == TRUE) {
    
      correlation_results <- data.frame(
    lipid = lipidName,
    test_against = NA,
    pearson_r_all = NA,
    pearson_p_all = NA,
    spearman_rho_all = NA,
    spearman_p_all = NA,
    pearson_r_HED = NA,
    pearson_p_HED = NA,
    spearman_rho_HED = NA,
    spearman_p_HED = NA,
    pearson_r_DIWL = NA,
    pearson_p_DIWL = NA,
    spearman_rho_DIWL = NA,
    spearman_p_DIWL = NA,
    pearson_r_WLEX = NA,
    pearson_p_WLEX = NA,
    spearman_rho_WLEX = NA,
    spearman_p_WLEX = NA
  )
  } else {
  
    # Initialize an empty data frame to store correlation results
  correlation_results <- data.frame(
    lipid = character(),
    test_against = character(),
    pearson_r_all = numeric(),
    pearson_p_all = numeric(),
    spearman_rho_all = numeric(),
    spearman_p_all = numeric(),
    pearson_r_HED = numeric(),
    pearson_p_HED = numeric(),
    spearman_rho_HED = numeric(),
    spearman_p_HED = numeric(),
    pearson_r_DIWL = numeric(),
    pearson_p_DIWL = numeric(),
    spearman_rho_DIWL = numeric(),
    spearman_p_DIWL = numeric(),
    pearson_r_WLEX = numeric(),
    pearson_p_WLEX = numeric(),
    spearman_rho_WLEX = numeric(),
    spearman_p_WLEX = numeric()
  )

  
  # Loop over every mirage variables of interest
  for (i in seq_along(mirage_variables_of_interest[[1]])) {
    # Manipulate current variable name
    test_against_name <- mirage_variables_of_interest[[1]][i]
    test_against_name_clean <- sub("_pre$", "", test_against_name)

    # Add new row to output df
    correlation_results <- add_row(correlation_results)

    # Identify the index of current row
    current_row_index <- nrow(correlation_results)

    # Assign lipid name and test against to last row
    correlation_results$lipid[current_row_index] <- lipidName
    correlation_results$test_against[current_row_index] <- test_against_name

    # Use pmol_mg_ch for composition within group. Use lipid z normalization for lipid class.
    if (is.null(lipidcomposition)) {
      lipid_unit <- "pmol_mg_id"
    } else {
      lipid_unit <- "pmol_mg_Pre"
    }

    ### REMOVE NA
    
    # Perform Pearson and Spearman correlations for all data
    result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
    result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)


    # Assign results the the results df
    correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
    correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
    correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
    correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p

    # Calculate correlations for each group
    for (current_group in unique(correlation_df$group)) {
      # Filter the dataframe for the current group
      correlation_df_group <- filter(correlation_df, group == current_group)


      # Perform Pearson and Spearman correlations for the current group
      result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
      result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)

      # Dynamic assignment of results based on the current group
      pearson_r_col <- paste0("pearson_r_", current_group)
      pearson_p_col <- paste0("pearson_p_", current_group)
      spearman_rho_col <- paste0("spearman_rho_", current_group)
      spearman_p_col <- paste0("spearman_p_", current_group)

      correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
      correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
      correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
      correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
    }
  }
  }
  return(correlation_results)
}

# Test function
# cross_res <- correlation_cross_sectional (combined, lipidomicsDF, mirage_crossSectional_vars, lipidclass = "Cer", lipidcomposition = "14:0")
```

## Plot scatter (function)

```{r}
correlation_crossSectional_plot <- function(correlation_df, mirage_crossSectional_vars, correlation_results, savePath, lipidclass, lipidcomposition) {
  # Make lipid name
  if (is.null(lipidcomposition)) {
    lipidName <- lipidclass
  } else {
    lipidName <- paste0(lipidclass, " ", lipidcomposition)
  }

  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pmol_mg_Pre))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(mirage_crossSectional_vars)

    # If lipidcomposition is null, then only plot class
    if (is.null(lipidcomposition)) {
      # Add lipid variable to plotVars
      # Make plot with log2 fold change if only class is available
      plotVars <- c("pmol_mg_id", plotVars)

      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars
      )
    } else {
      # Add lipid variable to plotVars
      plotVars <- c("pmol_mg_Pre", plotVars)

      # Now use ggpairs on the renamed dataframe
      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars,
        lower = list(continuous = wrap("smooth", method = "none", se = FALSE))
      )
    }

    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }


    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)

      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
        x = Inf, y = Inf,
        label = paste0(
          "Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
          ", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
          "\nSpearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
          ", rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3)
        ),
        size = 1.8, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }

    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }


    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }

    # Define the layout
    combined_plot <- combined_plot + plot_layout(ncol = 2)


    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }

  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )

  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 10, height = 14, units = "in")
}
```

## Run functions

```{r}
# Save folder for .jpg output files
savePathClassComp <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, correlations cross sectional composition/"
savePathClass <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, correlations cross sectional class/"

# Initialize an empty data frame to hold all correlation values
correlation_results_crossSection_composition <- data.frame()
correlation_results_crossSection_class <- data.frame()

# Loop over each lipid composition within each lipidclass
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
for (lipid_class in unique_lipid_classes) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    # Select and prepare data for analysis
    correlation_crossSection_df <- prepare_and_combine_crossSection(
      lipidomicsData = lipidomicsDF,
      mirageData = mirage_data,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition
    )

    # Calculate correlation coefficients
    correlation_results_crossSection_composition <- rbind(correlation_results_crossSection_composition, correlation_cross_sectional(correlation_df = correlation_crossSection_df, lipidomicsDF, mirage_variables_of_interest = mirage_crossSectional_vars, lipidclass = lipid_class, lipidcomposition = lipid_composition))


#        # Plot data - Comment out if to be used
#        correlation_crossSectional_plot(
#          correlation_crossSection_df,
#          mirage_crossSectional_vars,
#          correlation_results_crossSection_composition,
#          savePathClassComp,
#          lipid_class,
#          lipid_composition
#        )
  }
}

# Loop over each lipid class and make plots
for (lipid_class in unique_lipid_classes) {
  # Organize data
  correlation_crossSection_df <- prepare_and_combine_crossSection(
    lipidomicsData = lipidomicsDF,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    lipidcomposition = NULL
  )

  # Calculate correlations for changes
  correlation_results_crossSection_class <- rbind(correlation_results_crossSection_class, correlation_cross_sectional(correlation_crossSection_df, lipidomicsDF, mirage_crossSectional_vars, lipid_class, lipidcomposition = NULL))

#  # Plot data - un-comment if to be used again
#  correlation_crossSectional_plot(
#    correlation_crossSection_df,
#    mirage_crossSectional_vars,
#    correlation_results_crossSection_class,
#    savePathClass,
#    lipid_class,
#    lipidcomposition = NULL
#  )
}
```

## Adjust & plot p-values
**Correct p-values based on Bejamini-Hochberg**
```{r}
# BH correct p-values
# Name the columns that should be adjusted
cols_to_adjust <- c(
  "pearson_p_all", "spearman_p_all"
)

# Function to apply BH correction within each "test_against" group
adjust_p_values_within_group <- function(data, cols_to_adjust) {
  data %>%
    group_by(test_against) %>%
    mutate(across(all_of(cols_to_adjust), ~ p.adjust(.x, method = "BH"), .names = "{.col} (corrected)")) %>%
    ungroup()
}


# Apply adjustment function
# Composition and class
# Combine class and composition
correlation_results_crossSection_class_and_comp <- rbind(correlation_results_crossSection_composition, correlation_results_crossSection_class)
# Rund adjustment
correlation_results_crossSection_class_and_comp <-
  adjust_p_values_within_group(correlation_results_crossSection_class_and_comp, cols_to_adjust)

# Composition
correlation_results_crossSection_composition <-
  adjust_p_values_within_group(correlation_results_crossSection_composition, cols_to_adjust)

# Class
correlation_results_crossSection_class <-
  adjust_p_values_within_group(correlation_results_crossSection_class, cols_to_adjust)

```

**Plot p-values**

```{r}
generate_barplot_crossSection <- function(data, col_non_corrected, col_corrected, output_base_path, data_name) {
  # Define common sizes for axis titles and plot title
  axis_title_size <- 12
  plot_title_size <- 13

  # Loop over every unique test
  for (test_var in unique(data$test_against)) {
    # Filter based on test variable and columns of interest
    data_test_filtered <- data %>%
      filter(test_against == test_var) %>%
      select(lipid, test_against, pearson_p_all, spearman_p_all, `pearson_p_all (corrected)`, `spearman_p_all (corrected)`)

    # Remove row if non corrected column is Na
    data_test_filtered <- data_test_filtered[!is.na(data_test_filtered[[col_non_corrected]]), ]

    # Dynamic adjustment of the label size based on the number of bars (lipids)
    num_bars <- length(unique(data_test_filtered$lipid))
    label_size <- max(2, min(10, 50 / sqrt(num_bars))) # Adjusted dynamically


    # Generate plot for non-corrected p-values
    p1 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_non_corrected]]), y = data_test_filtered[[col_non_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_non_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Generate plot for corrected p-values
    p2 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_corrected]]), y = data_test_filtered[[col_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Combine the two plots
    subplot <- p1 + p2

    # Construct the subfolder path based on 'test_var'
    subfolder_path <- file.path(output_base_path, gsub("[ :()]", "_", test_var)) # Replace problematic characters

    # Ensure the subfolder exists
    dir.create(subfolder_path, recursive = TRUE, showWarnings = FALSE)

    # Construct the plot filename, ensuring no problematic characters for file names
    plot_filename <- paste0(gsub("[ :()]", "_", col_non_corrected), ", ", data_name, test_var, ".jpeg") # Replace spaces and special characters with underscores

    # Save the plot
    ggsave(file.path(subfolder_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
  }
}


# RUN FUNCTIONS
# Add a second row to cols_to_adjust with corrected column names
plot_nonadj_vs_adj <- data.frame(original = cols_to_adjust, corrected = paste0(cols_to_adjust, " (corrected)"))

# Just leave empty, as ch already indicates change in file name
dataframe_name_comp <- ""


# For lipid class
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, p-value sorted cross section/class"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_class, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}


# For lipid composition within lipid class
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, p-value sorted cross section/composition"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_composition, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}

# For lipid composition and lipid class combined
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, p-value sorted cross section/class and composition"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_class_and_comp, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}
```

# Pre-post group changes for lipids

## Mixed models
Insulin sensitivity. Original data was analyzed by one-way ANOVA. So this would be to double check results

mixed model for pre-post changes for every lipid composition within all lipid classes and for every lipid class.

```{r}
# Set the max number of observations that the emmeans package will handle. Lower number shorter computation times, larger number, more precise CI and p-value estimates
emm_options(pbkrtest.limit = 6000) # change to 5000 after code works

mixedmodel_pre_post <- function(dataset, response_var, lipidclass, lipidcomposition = NULL) {
  # Filter dataset based on lipidclass and optionally lipidcomposition
  if (!is.null(lipidcomposition)) {
    data_to_model <- filter(dataset, lipidClass == lipidclass & lipidComposition == lipidcomposition)
  } else {
    data_to_model <- filter(dataset, lipidClass == lipidclass)
  }

  
  # Check number of non-zero rows
  non_zero_rows <- data_to_model %>% 
    filter(pmol_mg > 0) %>% 
    nrow()
  
  # only proceed if number of non zero rows is above cutoff
  if (non_zero_rows < analysis_cutoff){
    return(list(estimates = NA, pvals = NA))
  } else {
    
  # Prepare factors
  data_to_model$group <- factor(data_to_model$group, levels = c("HED", "DIWL", "WLEX"))
  data_to_model$time <- factor(data_to_model$time, levels = c("Pre", "Post"))

#  # Remove Na rows
#  data_to_model <- data_to_model[!is.na(data_to_model$pmol_mg), ]
#
#
#  # Remove lipidcomposition with only 0
#  data_to_model <- data_to_model %>%
#    group_by(lipidComposition) %>%
#    filter(any(pmol_mg != 0)) %>%
#    ungroup()


  # Determine if lipidComposition can be a random effect
  if (!is.null(lipidcomposition) || length(unique(data_to_model$lipidComposition)) <= 1) {
    model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id)"))
  } else {
    model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id) + (1 | lipidComposition)"))
  }

  # Try-catch block for model fitting
  tryCatch(
    {
      model <- lmer(model_formula,
                    data = data_to_model,
                    na.action = na.exclude)
      # Estimated marginal of means to get out slope and between groups statistics
      emm <- emmeans(model, ~ time * group)

      # Contrasts for differences in slopes between groups
      model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")

      model.slope.contrasts.results <- summary(model.slope.contrasts)

      # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
      model.slope.contrasts.results <- model.slope.contrasts.results %>%
        mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
        select(contrast, estimate, SE, df, t.ratio, p.value)

      # Pre, Post between group comparisons
      prepost.contrasts <- pairs(emm, adjust = "none")

      # Get results
      prepost.contrasts.results <- summary(prepost.contrasts)

      return(list(lipidClass = as.character(lipidclass), lipidComposition = as.character(lipidcomposition), slope_results = model.slope.contrasts.results, prepost_results = prepost.contrasts.results))
    },
    error = function(e) {
      return(list(estimates = NA, pvals = NA))
    }
  )
}
  }

# Run function for lipid composition within lipid class
result.lipid.pre_post.class_comp <- pmap(
  list(lipidClass = unique_combinations$lipidClass, lipidComposition = unique_combinations$lipidComposition),
  ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", ..1, ..2)
)
# Naming the results list elements
names(result.lipid.pre_post.class_comp) <- paste(unique_combinations$lipidClass, unique_combinations$lipidComposition, sep = "_")

# Use map to iterate over lipid classes and use z-normalized data
result.lipid.pre_post.class <- map(unique_lipid_classes, ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", .x))

# Naming the results list
names(result.lipid.pre_post.class) <- unique_lipid_classes
```

Sort, adjust by Benjamini-Hochberg for lipid composition within lipid class

```{r}
prepare_lipid_data_for_plotting <- function(result_data) {
  pvals_df <- data.frame()

  contrasts_prepost <- c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX")
  contrasts_slope <- c("Pre - Post : HED - DIWL", "Pre - Post : HED - WLEX", "Pre - Post : DIWL - WLEX")

  for (test_name in names(result_data)) {
    # Check if prepost_results and slope_results are not NULL
    if (!is.null(result_data[[test_name]]$prepost_results)) {
      prepost_results <- result_data[[test_name]]$prepost_results
    } else {
      prepost_results <- data.frame(contrast = character(), p.value = numeric())
    }

    if (!is.null(result_data[[test_name]]$slope_results)) {
      slope_results <- result_data[[test_name]]$slope_results
    } else {
      slope_results <- data.frame(contrast = character(), p.value = numeric())
    }

    # Proceed with extraction using the ensured data frames
    prepost_pvals <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)

    slope_pvals <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)

    combined_pvals <- c(prepost_pvals, slope_pvals)
    combined_pvals <- setNames(combined_pvals, c(contrasts_prepost, contrasts_slope))
    pvals_df <- rbind(pvals_df, cbind(Lipid = test_name, t(as.data.frame(list(combined_pvals)))))
  }

  # Select all columns after the first one
  corrected_cols <- names(pvals_df)[-1]

   # Remove rows where every column from the second column onwards contains NA
  pvals_df <- pvals_df[rowSums(is.na(pvals_df[, -1])) < (ncol(pvals_df) - 1), ]
  
  # Apply Benjamini-Hochberg correction and create new columns with the suffix "_BH_corrected"
  for (col in corrected_cols) {
    pvals_df[[paste0(col, " (corrected)")]] <- p.adjust(pvals_df[[col]], method = "BH")
  }

  # Reset row names to simple sequential numbers
  rownames(pvals_df) <- NULL

  # Convert the columns to numeric
  for (i in 2:ncol(pvals_df)) {
    if (!is.numeric(pvals_df[[i]])) {
      pvals_df[[i]] <- as.numeric(pvals_df[[i]])
    }
  }

  return(pvals_df)
}

# Run for class and composition combined
# Combine lists
result.lipid.pre_post.class_and_comp <- c(result.lipid.pre_post.class_comp, result.lipid.pre_post.class)
# Run prepare data function on combined list
pvals_lipid_class_and_comp <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_and_comp)

# Prepare data for plotting lipid composition within each lipid class
pvals_lipid_comp <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_comp)

# Prepare data for plotting lipid classes
pvals_lipid_class <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class)

```

## p-value plots
Make plots of p-values sorted highest to lowest for lipid classes and lipid compositions within each lipid class

```{r}
generate_barplot <- function(data, col_index_non_corrected, col_index_corrected, output_base_path, data_name) {
  # Extract test names based on indices
  test_name_non_corrected <- names(data)[col_index_non_corrected]
  test_name_corrected <- names(data)[col_index_corrected]

  # Use output_base_path directly, no sub-folders created
  output_path <- output_base_path

  # Prepare and sort data for plotting
  data$Lipid <- factor(data$Lipid, levels = unique(data$Lipid))

  # Define common sizes for axis titles and plot title
  axis_title_size <- 13
  plot_title_size <- 10

  # Dynamic adjustment of the label size based on the number of bars (lipids)
  num_bars <- length(unique(data$Lipid))
  label_size <- max(2, min(11, 50 / sqrt(num_bars))) # Adjusted dynamically

  # Generate plot for non-corrected p-values
  p1 <- ggplot(data, aes(x = reorder(Lipid, .data[[test_name_non_corrected]]), y = .data[[test_name_non_corrected]])) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
    labs(y = "P-value", x = "Lipid", title = test_name_non_corrected) +
    theme_minimal() +
    theme(
      axis.title.y = element_text(size = axis_title_size, face = "bold"),
      axis.title.x = element_text(size = axis_title_size, face = "bold"),
      plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = label_size)
    )

  # Generate plot for corrected p-values
  p2 <- ggplot(data, aes(x = reorder(Lipid, .data[[test_name_corrected]]), y = .data[[test_name_corrected]])) +
    geom_bar(stat = "identity", fill = "darkgreen") +
    coord_flip() +
    geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
    labs(y = "Corrected P-value", x = "Lipid", title = test_name_corrected) +
    theme_minimal() +
    theme(
      axis.title.y = element_text(size = axis_title_size, face = "bold"),
      axis.title.x = element_text(size = axis_title_size, face = "bold"),
      plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = label_size)
    )

  # Combine the two plots
  subplot <- p1 + p2

  # Construct the plot filename
  plot_filename <- paste0(data_name, " ", gsub("[ :()]", " ", test_name_non_corrected), ".jpeg")

  # Save the subplot
  ggsave(file.path(output_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
}

# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/plot, p-value sorted pre-post"

# Column indices to plot against one another; non-corrected vs corrected p-values
cols_to_plot <- matrix(c(2, 8, 3, 9, 4, 10, 5, 11, 6, 12, 7, 13), ncol = 2, byrow = TRUE)

# Loop through each pair of columns and generate the plots
# Lipid class
dataframe_name <- "lipid class"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(pvals_lipid_class, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/class"), dataframe_name)
}

# Lipid class and composition
dataframe_name_comp <- "lipid comp"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(pvals_lipid_comp, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/composition"), dataframe_name_comp)
}

# Lipid class and composition
dataframe_name_comp_and_class <- "lipid class and comp"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(pvals_lipid_class_and_comp, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/comp_and_class"), dataframe_name_comp)
}

```

## Scatter plots
Scatter plots with insulin sensitivity as colormap. Datapoints above ULOQ and below LLOQ are marked with triangles for.
```{r}
# Create a named vector mapping IDs to continuous values for coloring
# color_map <- setNames(mirage_data$gdr_rd_ss2_mg_kg_ffm_min_pre, mirage_data$id)
# Create a new descrete coloring vector
color_map <- setNames(mirage_data$gender, mirage_data$id)

plot_lipid <- function(lipidomicsDF, lipid_composition, lipid_class, color_map, detection_limits, p_val_df) {
  filtered_data <- filter(lipidomicsDF, lipidClass == lipid_class & lipidComposition == lipid_composition & !is.na(time))

  # Find the min and max of the y-axis data and add a buffer
  y_min <- min(filtered_data$pmol_mg, na.rm = TRUE) * 0.95 # 5% buffer reduced
  y_max <- max(filtered_data$pmol_mg, na.rm = TRUE) * 1.05 # 5% buffer increased

  # Find correct p-values
  search_key <- paste(lipid_class, lipid_composition, sep = "_")
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )
  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )

  # Prepare the plot
  plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = pmol_mg, group = interaction(id, group)
  )) +
    geom_line(aes(group = interaction(id, group)), color = "darkgrey", position = position_nudge(x = 0.03)) +
    geom_point(aes(color = color_map[id]), alpha = 0.5, position = position_nudge(x = 0.03)) +
    geom_boxplot(aes(group = interaction(group, time)),
      width = 0.3, alpha = 0.2, outlier.shape = NA,
      position = position_dodge(width = 0.75), color = "black"
    ) +
    geom_point(
      data = subset(filtered_data, within_threshold == 2), aes(y = pmol_mg), size = 3, shape = 24, color = "black", fill = "grey",
      alpha = 0.3, position = position_nudge(x = 0.03) # Up triangle for values above ULOQ
    ) +
    geom_point(
      data = subset(filtered_data, within_threshold == 1), aes(y = pmol_mg), size = 3, shape = 25, color = "black", fill = "grey",
      alpha = 0.3, position = position_nudge(x = 0.03) # Down triangle for values 
    ) +
    scale_color_manual(values = c("M" = "blue", "F" = "red"), name = "Gender") +
    labs(
      title = paste(lipid_composition, lipid_class),
      subtitle = annotation_pvals_slope,
      y = expression("Lipid concentration" ~ "(pmol ·" ~ mg^-1 * ")"),
      x = ""
    ) +

    # Insert P-values pre post
    annotate("text",
      x = c(1.5, 3.5, 5.5), y = max(filtered_data$pmol_mg) * 1.05,
      label = annotation_pvals_pre_post, size = 2
    ) +
    theme_minimal() +
    theme(
      axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
      legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
      legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), ,
      plot.subtitle = element_text(size = 5, hjust = 0.5)
    )


  # Define the filename and save the plot
  filename <- paste0(
    "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/plot, scatter composition/",
    gsub("/", "_", gsub(":", ",", paste(lipid_class, lipid_composition, sep = " "))), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each combination of lipid_class and lipid_composition
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
for (lipid_class in unique_lipid_classes) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    plot_lipid(lipidomicsDF, lipid_composition, lipid_class, color_map, detection_limits, pvals_lipid_comp)
  }
}
```

Scatter plot for each lipid class based on absolute lipid class concentration
```{r}
plot_lipid_class <- function(lipidomicsDF, lipid_class, detection_limits, p_val_df) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))

  
  ### MAKE SUM FOR EACH ID
pmol_mg_class_sum <- lipidomicsDF %>%
  group_by(id) %>%
  summarize(
    sum_pmol_mg_Pre = sum(pmol_mg_Pre, na.rm = TRUE),
    sum_pmol_mg_Post = sum(pmol_mg_Post, na.rm = TRUE)
  ) %>%
  ungroup()
    
    
    
  ########### ############### ############### ############### ############### ############### ############### ############### 
  
  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )

  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
mean_data <- filtered_data %>%
  group_by(group, time) %>%
  summarise(mean_pmol_mg_znorm = mean(pmol_mg_znorm, na.rm = TRUE), .groups = 'drop')
  
# Create the plot
plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = pmol_mg_znorm, group = interaction(id, group)
  )) +
  geom_line(aes(group = interaction(id, group, lipidComposition), color = lipidComposition), alpha = 0.9, size = 0.1, position = position_nudge(x = 0.03)) +
  geom_point(aes(color = lipidComposition), alpha = 0.5, position = position_nudge(x = 0.03)) +
  geom_line(data = mean_data, aes(x = interaction(group, time, sep = " "), y = mean_pmol_mg_znorm, group = group),color = "black", size = 1, position = position_nudge(x = 0.03)) +
  scale_color_manual(values = rainbow(length(unique(filtered_data$lipidComposition)))) +
  labs(title = lipid_class, subtitle = annotation_pvals_slope, y = "Lipid concentration, Z norm [comp within group]", x = "") +
  annotate("text", x = c(1.5, 3.5, 5.5), y = 3.0, label = annotation_pvals_pre_post, size = 2) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
        legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
        legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
        plot.subtitle = element_text(size = 5, hjust = 0.5))

  # Filter the LLOQ and ULOQ for the current lipid_class and set y-axis limits
  y_min <- min(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 0.95 # Adjusted
  y_max <- max(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 1.05 # Adjusted
  plot <- plot + coord_cartesian(ylim = c(y_min, y_max))

  # Define the filename and save the plot
  filename <- paste0(
    "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/plot, scatter class/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each lipid class
for (lipid_class in unique_lipid_classes) {
  plot_lipid_class(lipidomicsDF, lipid_class, detection_limits, pvals_lipid_class)
}
```



Scatter plots for each lipid class with lipid classes shown in different colors
```{r}
plot_lipid_class_z_score <- function(lipidomicsDF, lipid_class, detection_limits, p_val_df) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))

  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )

  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
mean_data <- filtered_data %>%
  group_by(group, time) %>%
  summarise(mean_pmol_mg_znorm = mean(pmol_mg_znorm, na.rm = TRUE), .groups = 'drop')
  
# Create the plot
plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = pmol_mg_znorm, group = interaction(id, group)
  )) +
  geom_line(aes(group = interaction(id, group, lipidComposition), color = lipidComposition), alpha = 0.9, size = 0.1, position = position_nudge(x = 0.03)) +
  geom_point(aes(color = lipidComposition), alpha = 0.5, position = position_nudge(x = 0.03)) +
  geom_line(data = mean_data, aes(x = interaction(group, time, sep = " "), y = mean_pmol_mg_znorm, group = group),color = "black", size = 1, position = position_nudge(x = 0.03)) +
  scale_color_manual(values = rainbow(length(unique(filtered_data$lipidComposition)))) +
  labs(title = lipid_class, subtitle = annotation_pvals_slope, y = "Lipid concentration, Z norm [comp within group]", x = "") +
  annotate("text", x = c(1.5, 3.5, 5.5), y = 3.0, label = annotation_pvals_pre_post, size = 2) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
        legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
        legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
        plot.subtitle = element_text(size = 5, hjust = 0.5))


  # Filter the LLOQ and ULOQ for the current lipid_class and set y-axis limits
  y_min <- min(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 0.95 # Adjusted
  y_max <- max(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 1.05 # Adjusted
  plot <- plot + coord_cartesian(ylim = c(y_min, y_max))

  # Define the filename and save the plot
  filename <- paste0(
    "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/plot, scatter class, z_score/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each lipid class
for (lipid_class in unique_lipid_classes) {
  plot_lipid_class_z_score(lipidomicsDF, lipid_class, detection_limits, pvals_lipid_class)
}
```

## QQ plots

QQ-plots for faw, normalized lipidomics data

```{r}
output_dir <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/plot, qq-plots"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

groups <- c("HED", "DIWL", "WLEX")
times <- c("Pre", "Post")

for (i in seq_len(nrow(unique_combinations))) {
  current_combination <- unique_combinations[i, ]

  sanitized_lipidClass <- gsub("[/:]", "_", current_combination$lipidClass)
  sanitized_lipidComposition <- gsub("[/:]", "_", current_combination$lipidComposition)
  file_name <- paste(sanitized_lipidClass, sanitized_lipidComposition, "qqplots.jpeg", sep = " ")
  file_path <- file.path(output_dir, file_name)

  # Open JPEG device
  jpeg(file_path, width = 800, height = 600)

  # Setup plot layout
  par(mfrow = c(3, 2), mar = c(4, 4, 2, 1))

  for (group in groups) {
    for (time in times) {
      data_to_plot <- lipidomicsDF %>%
        filter(
          lipidClass == current_combination$lipidClass,
          lipidComposition == current_combination$lipidComposition,
          group == !!group,
          time == !!time
        )

      # Plot only if there's data
      if (nrow(data_to_plot) > 0 && !all(is.na(data_to_plot$pmol_mg))) {
        qqnorm(data_to_plot$pmol_mg, main = paste(current_combination$lipidClass, current_combination$lipidComposition, group, time))
        qqline(data_to_plot$pmol_mg, col = "red")
      } else {
        plot.new()
        title(main = paste("No data for", current_combination$lipidClass, current_combination$lipidComposition, group, time))
      }
    }
  }

  # Close the plotting device
  dev.off()
}

cat("All plots have been saved to", output_dir, "\n")
```

QQ-plots for log transformed lipidomics data

```{r}
output_dir <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/qq-plots/log transformed"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

unique_combinations <- lipidomicsDF %>%
  distinct(lipidClass, lipidComposition) %>%
  arrange(lipidClass, lipidComposition)

groups <- c("HED", "DIWL", "WLEX")
times <- c("Pre", "Post")

for (i in seq_len(nrow(unique_combinations))) {
  current_combination <- unique_combinations[i, ]

  sanitized_lipidClass <- gsub("[/:]", "_", current_combination$lipidClass)
  sanitized_lipidComposition <- gsub("[/:]", "_", current_combination$lipidComposition)
  file_name <- paste(sanitized_lipidClass, sanitized_lipidComposition, "Log qqplots.jpeg", sep = " ")
  file_path <- file.path(output_dir, file_name)

  # Open JPEG device
  jpeg(file_path, width = 800, height = 600)

  # Setup plot layout
  par(mfrow = c(3, 2), mar = c(4, 4, 2, 1))

  for (group in groups) {
    for (time in times) {
      data_to_plot <- lipidomicsDF %>%
        filter(
          lipidClass == current_combination$lipidClass,
          lipidComposition == current_combination$lipidComposition,
          group == !!group,
          time == !!time
        )

      # Plot only if there's data
      if (nrow(data_to_plot) > 0 && !all(is.na(data_to_plot$pmol_mg))) {
        qqnorm(data_to_plot$pmol_mg_log, main = paste(current_combination$lipidClass, current_combination$lipidComposition, group, time))
        qqline(data_to_plot$pmol_mg_log, col = "red")
      } else {
        plot.new()
        title(main = paste("No data for", current_combination$lipidClass, current_combination$lipidComposition, group, time))
      }
    }
  }

  # Close the plotting device
  dev.off()
}

cat("All plots have been saved to", output_dir, "\n")
```
