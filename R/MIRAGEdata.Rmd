---
title: "MIRAGEdata"   
purpose: To load, merge, explore, and plot lipidomics data and look for correlations with cardiometabolic endpoints the MIRAGE dataset.
output:
html_notebook: default
author: Ole Emil Andersen
date created: March 2024
editor_options: 
chunk_output_type: console
---

**Packages**

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(readxl) # reads Excel files
library(dplyr) # to manipulate data
library(tidyr) # facilitates tidy data transformation.
library(purrr) # enhances programming capabilities
library(tibble) # to make columns into row-names
library(janitor) # to clean column names
library(ggplot2) # for plots
library(grid) # to draw and annotate outside plots in figures
library(GGally) # makes pairwise plots
library(patchwork) # to make ggplot subplots
library(lme4) # for mixed models
library(emmeans) # for p-values and confidence intervals
library(lmerTest) # p-values for mixed models
library(correlation) # to analyse data for correlations
library(ComplexHeatmap); library(circlize) # to make complex heatmaps
library(ggrepel) # to avoid overlapping labels
```

# Project settings

Cut offs and values to be used throughout the analysis

```{r message=TRUE, warning=FALSE}
# Number of points above 0 needed for an analysis to take place. The number is the number of id's within class across all intervention groups.
analysis_cutoff <- 15

## Factor above LLOQ to discard a value
LLOQ_discard_factor <- 2
```

# Load and prepare data

## Lipidomics data

Load data into long format and clean the data by replacing \<0 with 0 and N/A with 0.

```{r, message=FALSE}
# Define the path to the Excel file
file_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/data-raw/2022Mar Goodpaster Results With Name Spaces.xlsx"

# List sheet names to load from excel file
sheet_names <- c("SPM SPH AC", "PG", "PI", "PS", "PA", "PE", "PC", "1,3-DAGs", "1,2-DAGs", "Cer dHCer GluCer LacCer GalCer", "TAG")

load_sheets_in_long_format <- function(file_path, sheet_names) {
  map_df(sheet_names, ~ {
    # Read the measurement names from the first row
    measurement_names <- read_excel(file_path, sheet = .x, n_max = 1) %>%
      colnames()

    # Read the data, skipping the first two rows
    data <- read_excel(file_path, sheet = .x, skip = 2, col_names = FALSE)

    # Limit the data to match the number of columns in the column names
    num_cols_in_names <- length(measurement_names)
    data_trimmed <- data[, 1:num_cols_in_names]

    # Assign column names to the data
    colnames(data_trimmed) <- c("Sample Name", measurement_names[-1])

    # Adjusting the replacement for "< 0" with 0 (as numeric) and "N/A" with NA
    data_cleaned <- data_trimmed %>%
      mutate(across(everything(), ~ case_when(
        .x == "< 0" ~ "0", # Replace "< 0" with "0"
        .x == "N/A" ~ "0", # Replace "N/A" with "0"
        TRUE ~ as.character(.x) # Keep other values as-is, converting to character to ensure type consistency
      ))) %>%
      type.convert(as.is = TRUE) # Convert back to original type where possible

    # Rename "Sample Name" to "sampleNumber"
    colnames(data_cleaned)[1] <- "sampleNumber"

    # Transform to long format
    data_long <- pivot_longer(data_cleaned, -sampleNumber, names_to = "measurement", values_to = "pmol")

    # Split the measurement into class and structure based on space
    data_long <- data_long %>%
      separate(measurement, into = c("lipidComposition", "lipidClass"), sep = " ", extra = "merge")

    return(data_long)
  }, .id = "sheet")
}

# Load all specified sheets into a single data frame in long format
lipidomicsDF <- load_sheets_in_long_format(file_path, sheet_names)

# Remove sheet column
lipidomicsDF <- select(lipidomicsDF, -sheet)
```

### Identifiers, samples and PBIS

**Load identifiers and sample weights** and merge with the data frame and split the pid into pre/post and id.

```{r}
# path to file
filePathIdentifiers <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/data-raw/Lipidomics Key and Weights Goodpaster KZB_identifiable.xlsx"

# load file
identifiersDF <- read_excel(filePathIdentifiers)

# clean names to rename columns to be R friendly
identifiersDF <- clean_names(identifiersDF)

# Make tube_id character
identifiersDF$tube_id <- as.character(identifiersDF$tube_id)

# Combine identifiers with data
lipidomicsDF <- left_join(lipidomicsDF, identifiersDF, by = c("sampleNumber" = "tube_id"))

# Split pid column into an id and a time column
lipidomicsDF <- separate(lipidomicsDF, pid, into = c("id", "time"), sep = " ", extra = "merge")

# Make time, lipidClass, id and group categorical variables
lipidomicsDF$time <- factor(lipidomicsDF$time, levels = c("Pre", "Post")) # sort by pre and post
lipidomicsDF$lipidClass <- factor(lipidomicsDF$lipidClass)
lipidomicsDF$id <- factor(lipidomicsDF$id)
lipidomicsDF$group <- factor(lipidomicsDF$group)
lipidomicsDF$lipidComposition <- factor(lipidomicsDF$lipidComposition)

# Remove PBIS rows
lipidomicsDF <- lipidomicsDF %>%
  filter(id != "PBIS")
```

### Quantification limits

Values are copied from the lipidomics Excel file, "2022Mar Goodpaster Results.xlsx"

```{r}
detection_limits <- data.frame(
  lipidclasses = c("SPH", "AC", "SPM", "PG", "LPG", "PI", "LPI", "PS", "LPS", "PA", "PE", "LPE", "PC", "LPC", "1,3-DG", "1,2-DG", "Cer", "dhCer", "GluCer", "LacCer", "GalCer", "TAG"),
  LLOQ = c(0.08, 0.16, 1.2, 0.6, 0.03, 2.5, 1, 2.5, 0.05, 0.1, 2.5, 1, 7, 3, 0.34, 0.68, 0.25, 0.05, 0.1, 0.2, 0.1, 10),
  ULOQ = c(320, 640, 4800, 2400, 100, 10000, 4000, 10000, 200, 400, 10000, 4000, 28000, 12000, 1360, 2720, 1000, 200, 400, 800, 400, 40000)
)
```

Make column to denote if measurement is within (0), below LLOQ (1), above ULOQ (2) or above ULOQ \* the defined discard factor (3). Values that are discarded are made Na.

```{r}
limitFunction <- function(lipidomicsDF, detection_limits){
# Initialize the 'within_threshold' column
lipidomicsDF$within_threshold <- NA

# Loop through each row in lipidomicsDF
for (i in 1:nrow(lipidomicsDF)) {
  # Retrieve the current lipidClass and pmol value
  current_lipidClass <- lipidomicsDF$lipidClass[i]
  current_pmol <- lipidomicsDF$pmol[i]

  # Find matching LLOQ and ULOQ values from detection_limits
  current_LLOQ <- detection_limits$LLOQ[detection_limits$lipidclasses == current_lipidClass]
  current_ULOQ <- detection_limits$ULOQ[detection_limits$lipidclasses == current_lipidClass]
  
  # Check the pmol value against LLOQ and ULOQ and assign the 'within_threshold'
  if (is.na(current_pmol) | length(current_LLOQ) == 0 | length(current_ULOQ) == 0) {
    lipidomicsDF$within_threshold[i] <- NA # Assign NA if there's an NA value in pmol or LLOQ/ULOQ cannot be found
  } else if (current_pmol < current_LLOQ) {
    lipidomicsDF$within_threshold[i] <- 1 # Below LLOQ
  } else if (current_pmol > (current_ULOQ * LLOQ_discard_factor)) { # Above value to be discarded
    lipidomicsDF$within_threshold[i] <- 3
    # lipidomicsDF$pmol[i] <- NA # Corrected to set only the current row's pmol to NA
  } else if (current_pmol > current_ULOQ) {
    lipidomicsDF$within_threshold[i] <- 2 # Above ULOQ
  } else {
    lipidomicsDF$within_threshold[i] <- 0 # Within the threshold
  }
}
return (lipidomicsDF)
}

lipidomicsDF <- limitFunction(lipidomicsDF, detection_limits)
```

### Outlier removal
```{r}
##### Manual removal #####

# Subject MG034 POST (Tube 66)
# Reason: Removed as TAG values are unnaturally high strongly suggesting IMAT contamination in the sample. As other lipids either directly or through the weight normalization would be affected, the post-measurement point is removed.

lipidomicsDF <- lipidomicsDF[!lipidomicsDF$sampleNumber == 66,]
```


### Ratios and saturation

### Normalization and transformation

**Weight normalization**

```{r}
lipidomicsDF$pmol_mg <- lipidomicsDF$pmol / lipidomicsDF$equiv_weight_extracted
```

**Add PE/PC ratio**

```{r}
add_ratio_lipidomics <- function (lipidomicsDF)
{
# Step 1: Filter for PE and PC lipid classes and summarize their pmol values
sums_df <- lipidomicsDF %>%
  filter(lipidClass %in% c("PE", "PC")) %>%
  group_by(id, time, sampleNumber, group, wet_weight, lyphilized_weight, volume_of_homogenate_ul, equiv_weight_extracted, lipidClass) %>%
  summarise(sum_pmol_mg = sum(pmol_mg), .groups = "drop_last")

# Step 2: Pivot the data to wide format after summarization
sums_wide <- sums_df %>%
  pivot_wider(names_from = lipidClass, values_from = sum_pmol_mg)

# Step 3: Calculate the PE/PC ratio
ratios_df <- sums_wide %>%
  mutate(lipidClass = "PE_PC ratio",
         lipidComposition = NA_character_,  # Assuming character; adjust as needed
         pmol = NA_real_,  # Set to NA; adjust type as needed
         pmol_mg = PE / PC,
         within_threshold = NA_real_) %>%  # Adjust type if needed
  select(-PE, -PC)  # Remove intermediate PE and PC columns

# Ensure matching column structure with the original dataframe
# For columns not included in ratios_df, add them as NAs
missing_cols <- setdiff(names(lipidomicsDF), names(ratios_df))
for(col in missing_cols) {
  ratios_df[[col]] <- NA
}

# Reorder columns to match the original dataframe exactly
ratios_df <- ratios_df[names(lipidomicsDF)]

# Step 4: Bind the rows to include PE:PC ratio ratios in the original dataframe
lipidomicsDF <- bind_rows(lipidomicsDF, ratios_df)

return(lipidomicsDF)
}

lipidomicsDF <- add_ratio_lipidomics(lipidomicsDF)
```

**Log transform** Log transform the weight normalized lipidomics data. 1 is added to all values to avoid zores

```{r}
# Transform and add a small constant (+1) to avoid log(0)
lipidomicsDF <- lipidomicsDF %>%
  mutate(pmol_mg_log = log(pmol_mg + 1))
```

**Sort data**

```{r}
# Sort the dataframe by 'id' and 'time'
lipidomicsDF <- lipidomicsDF %>%
  arrange(id, time)

# Find all lipidClass-lipidComposition
unique_combinations <- lipidomicsDF %>%
  distinct(lipidClass, lipidComposition) %>%
  arrange(lipidClass, lipidComposition)
```

**Define unique lipid classes**

```{r}
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
```

## Mirage data

**Load from "FINAL MIRAGE DATASET.xlsx"**

!!! DUPLICATE IDS: "MG023" and "MG019" both are duplicates that appear with same group as in id from Pittsburg and TRI. Assumption: All samples are from TRI if not specified otherwise. Therefore, the Excel file "FINAL MIRAGE DATASET.xlsx", sheet "Not Imputed-Clean" was changed to make the merge work. All changes are marked with red text.

```{r}
# path to file
file_path_endpoints <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/data-raw/FINAL MIRAGE DATASET.xlsx"

# load file
mirage_data <- read_excel(file_path_endpoints, sheet = "Not Imputed-Clean")

# clean names
mirage_data <- clean_names(mirage_data)

# separate pid into id and site
mirage_data <- separate(mirage_data, pid, into = c("id", "site"), sep = "-", extra = "merge")

# Remove redundant columns
mirage_data <- select(mirage_data, -study_center)


# Adjust column names, and move pre and post to the end of the name
# Loop through each column name in mirage_data
new_col_names <- sapply(names(mirage_data), function(col_name) {
  # Check if "_pre" is in the column name
  if (grepl("_pre", col_name)) {
    col_name <- gsub("_pre", "", col_name) # Remove "_pre"
    col_name <- paste0(col_name, "_pre") # Add "_pre" to the end
  }
  # Check if "_post" is in the column name
  if (grepl("_post", col_name)) {
    col_name <- gsub("_post", "", col_name) # Remove "_post"
    col_name <- paste0(col_name, "_post") # Add "_post" to the end
  }
  return(col_name)
})

# Update the column names of mirage_data
names(mirage_data) <- new_col_names
```

**Calculate additional rows**

```{r}
mirage_data$tdee_kcal_24hr_ffm_pre <- mirage_data$tdee_kcal_24hr_pre / mirage_data$lean_mass_dxa_pre

# Asses moderate to vigorous physical activity by combining minutes in moderate (mpa) with vigerous activity (vpa) 
mirage_data$mvpa_mins_day_pre <- mirage_data$mpa_mins_day_pre + mirage_data$vpa_mins_day_pre
mirage_data$mvpa_mins_day_post <- mirage_data$mpa_mins_day_post + mirage_data$vpa_mins_day_post

```

### Select variables & long format

**pre-post variables** Define variables of interest for pre-post delta correlations against lipids.

```{r}
# List with pre-post variables of interest
glycemicControl <- list(
  c("rd_ss1kg_ffm_insulin_pre", "rd_ss1kg_ffm_insulin_post", "Glucose RD per FFM and insulin (?)"),
  c("rd_ss2kg_ffm_insulin_pre", "rd_ss2kg_ffm_insulin_post", "Glucose RD per FFM and insulin (?)"),
  c("hgb_a1c_pre", "hgb_a1c_post", "HbA1c (mmol / mol?)"),
  c("homair_pre", "homair_post", "HOMAIR (abr unit)"),
  c("egp0kg_ffm_pre", "egp0kg_ffm_post", "Endogenous glucose production (?)"),
  c("egpss1kg_ffm_pre", "egpss1kg_ffm_post", "Endogenous glucose production (?)"),
  c("egpss2kg_ffm_pre", "egpss2kg_ffm_post", "Endogenous glucose production (?)")
  )

mitochondria <- list(
  c("at_pmax_p_mrs_pre", "at_pmax_p_mrs_post", "ATP max (?)"),
  c("pcr_p_mrs_pre", "pcr_p_mrs_post", "PCR recovery? (?)"),
  c("max_oxphos_pre", "max_oxphos_post", "Max oxidative phosphorylation (?)"),
  c("max_ets_pre", "max_ets_post", "Max ETS? (?)"),
  c("le_pre", "le_post", "Leak? (?)"),
  c("pe_pre", "pe_post", "PE? (?)")
  )

bodycomposition <- list( # SHOULD FFM ETC. WEIGHTs BE NORMALISED TO TOTAL WEIGHT?
  c("leg_lean_mass_pre", "leg_lean_mass_post", "Leg lean mass (kg?)" ),
  c("fat_mass_dxa_pre", "fat_mass_dxa_post", "Fat mass (kg?)"),
  c("lean_mass_dxa_pre", "lean_mass_dxa_post", "Lean body mass (kg?)"),
  c("ffm_dxa_pre", "ffm_dxa_post", "Fat free mass (kg?)"),
  c("thigh_sat_g_pre", "thigh_sat_g_post", "Thigh SAT, (g)"),
  c("thigh_imat_g_pre", "thigh_imat_g_post", "IMAT (g)"),
  c("percent_imat_pre", "percent_imat_post", "IMAT fraction (%)"),
  c("thigh_muscle_g_pre", "thigh_muscle_g_post", "Thigh muscle (g)"),
  c("abdomen_vat_g_pre", "abdomen_vat_g_post", "Adbominal VAT (g)"),
  c("type_iia_iix_pre", "type_iia_iix_post", "Fibertype? (?)")
  )

blood <-  list(
  c("vldl_pre", "vldl_post", "VLDL (mmol / l)"),
  c("ldl_pre", "ldl_post", "LDL (mmol / l"),
  c("hdl_pre", "hdl_post", "HDL (mmol / l)"),
  c("cholesterol_pre", "cholesterol_post", "Total cholesterol (mmol / l)"),
  c("triglycerides_pre", "triglycerides_post", "Triglycerides (mmol / l)"),
  c("plasma_ffabg_pre", "plasma_ffabg_post", "FFA (mmol / l)")
  )
  
  physicalActivity <- list(
  c("mvpa_mins_day_pre", "mvpa_mins_day_post", "Time per day (min / day)"),
  c("vo2abs_pre", "vo2abs_post", "Oxygen uptake (l / min)"),
  c("vo2kg_ffm_pre", "vo2kg_ffm_post", "Oxygen uptake (l / min / kgFFM) "),
  c("x4m_walk_pre", "x4m_walk_post", "Time? (s)"),
  c("step_test_pre", "step_test_post", "Steps? (?)"),
  c("x1rm_pre", "x1rm_post", "Stength (?)"),
  c("peak_torque120_pre", "peak_torque120_post", "Torque (Nm?)"),
  c("age_pre", "age_post", "Age (years)")
  )
  
  mirage_ch_vars <- list(
    glycemicControl = glycemicControl,
    mitochondria = mitochondria,
    bodycomposition = bodycomposition,
    blood = blood,
    physicalActivity = physicalActivity
  )
  
  
```

**Cross-sectional variables** Define variables of interest to compare between all individuals at pre

```{r}
# Glycemic Control
glycemicControl <- c("rd_ss1kg_ffm_insulin_pre", "rd_ss2kg_ffm_insulin_pre", "hgb_a1c_pre", "homair_pre", "egp0kg_ffm_pre", "egpss1kg_ffm_pre", "egpss2kg_ffm_pre")

# Mitochondria
mitochondria <- c("at_pmax_p_mrs_pre", "pcr_p_mrs_pre", "max_oxphos_pre", "max_ets_pre", "le_pre", "pe_pre")

bodycomposition <- c("leg_lean_mass_pre", "fat_mass_dxa_pre", "lean_mass_dxa_pre", "ffm_dxa_pre", "thigh_sat_g_pre", "thigh_imat_g_pre", "percent_imat_pre", "thigh_muscle_g_pre", "abdomen_vat_g_pre", "type_iia_iix_pre")

# Blood
blood <- c("vldl_pre", "ldl_pre", "hdl_pre", "cholesterol_pre", "triglycerides_pre", "plasma_ffabg_pre")

# Physical Activity + Age
physicalActivity <- c("mvpa_mins_day_pre", "vo2abs_pre", "vo2kg_ffm_pre", "x4m_walk_pre", "step_test_pre", "x1rm_pre", "age_pre")


# Combining all the "_pre" variables into a single list for mirage_crossSectional_vars, excluding "age_pre" from all but the physicalActivity list
mirage_crossSectional_vars <- list(
  glycemicControl = glycemicControl,
  mitochondria = mitochondria,
  bodycomposition = bodycomposition,
  blood = blood,
  physicalActivity = physicalActivity
)
```

**Mirage long format** Convert Mirage dataset with selected variables into long format with selected Pre\|Post varibles

```{r}
# Flatten the lists into a single vector
columns_to_merge <- mirage_ch_vars_flat <- unlist(unlist(lapply(mirage_ch_vars, function(category) {
  lapply(category, function(item) item[1:2])
}), recursive = FALSE), use.names = FALSE)


# Select columns from 'mirage_data' including the 'id' column
mirage_data_subset <- mirage_data[c("id", columns_to_merge)]

# Filter out the ids based on the ids in lipidomicsDF
mirage_data_subset <- mirage_data_subset %>%
  filter(id %in% lipidomicsDF$id)

# Transform 'mirage_data_subset' to long format
mirage_data_long_ch <- pivot_longer(
  mirage_data_subset,
  cols = -id, # Exclude 'id' from the pivoting
  names_to = c(".value", "time"), # Separate original column name into variable name and time
  names_pattern = "(.+)_(pre|post)" # Pattern to split the variable names and time
)

# Adjust the 'time' column in 'mirage_data_long_ch' to match 'Pre' and 'Post'
mirage_data_long_ch <- mirage_data_long_ch %>%
  mutate(time = case_when(
    time == "pre" ~ "Pre",
    time == "post" ~ "Post",
    TRUE ~ time # Keeps the original value if it's neither 'pre' nor 'post'
  ))

# Remove rows where all measurements are NA
mirage_data_long_ch <- mirage_data_long_ch %>%
  group_by(id, time) %>%
  filter(!all(is.na(age)))
```

# Mirage pre-post analysis w plot
```{r}
## Make function for the analysis
mirage_analysis_and_plot <- function(endpoint_variable, y_label, save_folder){
  
# Turn MIRAGE data into long format to be able to plot data
# Combine all variables of interest
subset_variables <- c("id", "group", "gender", endpoint_variable)

# Rename the endpoint variable to match the name in long format 
endpoint_variable <- gsub("_pre", "", endpoint_variable[1])

# Subset 'mirage_data' to include only the variables of interest
mirage_subset <- mirage_data[, subset_variables]

# Transform 'mirage_data_subset' to long format
mirage_plot_long <- pivot_longer(
  mirage_subset,
  cols = -c(id, group, gender),  # exclude cols from the pivot
  names_to = c(".value", "time"),
  names_pattern = "(.+)_(pre|post)"
)

### Make a column called in_lipidomics to filter out values that are present in that dataset
# Make id columns strings to be able to search
mirage_plot_long$id <- as.character(mirage_plot_long$id)
lipidomicsDF$id <- as.character(lipidomicsDF$id)

# Create the new column 'in_lipidomics' based on 'id' existence in lipidomicsDF
mirage_plot_long <- mirage_plot_long %>%
  mutate(in_lipidomics = if_else(id %in% lipidomicsDF$id, TRUE, FALSE))


# Adjust the 'time' column in 'mirage_data_long_ch' to match 'Pre' and 'Post'
mirage_plot_long <- mirage_plot_long %>%
  mutate(time = case_when(
    time == "pre" ~ "Pre",
    time == "post" ~ "Post",
    TRUE ~ time # Keeps the original value if it's neither 'pre' nor 'post'
  ))


##### MIXED MODEL

mirage_lmer <- function(modelData, endpoint_variable){
# Writing out formula allows dynamic naming
    model_formula <- as.formula(paste(
      endpoint_variable,
      "~ time * group +
      (1 | id)"))

      model <- lmer(model_formula,
                    data = modelData,
                    na.action = na.exclude)
      
      # Estimated marginal of means to get out slope and between groups statistics
      emm <- emmeans(model, ~ time * group)

      # Contrasts for differences in slopes between groups
      model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")

      model.slope.contrasts.results <- summary(model.slope.contrasts)

      # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
      model.slope.contrasts.results <- model.slope.contrasts.results %>%
        mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
        select(contrast, estimate, SE, df, t.ratio, p.value)

      # Pre, Post between group comparisons
      prepost.contrasts <- pairs(emm, adjust = "none")

      # Get results
      prepost.contrasts.results <- summary(prepost.contrasts)

      return(list(enpoint = as.character(endpoint_variable), slope_results = model.slope.contrasts.results, prepost_results = prepost.contrasts.results))
}

# Run function
lmer_results.mirage <- mirage_lmer(mirage_plot_long, endpoint_variable)
lmer_results.lipidomics <- mirage_lmer(mirage_plot_long[mirage_plot_long$in_lipidomics==TRUE,], endpoint_variable)

##### PLOT DATA

# Function to extract p-value based on contrast
extract_p_value <- function(results, contrast_name) {
  results$p.value[results$contrast == contrast_name]
}

# In lipidomics data
p_value.hed <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post HED - Pre HED")
p_value.diwl <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post DIWL - Pre DIWL")
p_value.wlex <- extract_p_value(lmer_results.lipidomics$prepost_results, "Post WLEX - Pre WLEX")
p_value_slope.hed_diwl <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : DIWL - HED")
p_value_slope.diwl_wlex <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : DIWL - WLEX")
p_value_slope.wlex_hed <- extract_p_value(lmer_results.lipidomics$slope_results, "Post - Pre : HED - WLEX")
# For whole mirage data
p_value.hed_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post HED - Pre HED")
p_value.diwl_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post DIWL - Pre DIWL")
p_value.wlex_mirage <- extract_p_value(lmer_results.mirage$prepost_results, "Post WLEX - Pre WLEX")
p_value_slope.hed_diwl_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : DIWL - HED")
p_value_slope.diwl_wlex_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : DIWL - WLEX")
p_value_slope.wlex_hed_mirage <- extract_p_value(lmer_results.mirage$slope_results, "Post - Pre : HED - WLEX")


# Calculate the count (n) for each group and time
# lipidomics data
n_hed_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "HED" & mirage_plot_long$time == "Pre"]))
n_hed_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "HED" & mirage_plot_long$time == "Post"]))
n_diwl_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Pre"]))
n_diwl_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Post"]))
n_wlex_pre <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Pre"]))
n_wlex_post <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$in_lipidomics & mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Post"]))

# mirage data
n_hed_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "HED" & mirage_plot_long$time == "Pre"]))
n_hed_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "HED" & mirage_plot_long$time == "Post"]))
n_diwl_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Pre"]))
n_diwl_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "DIWL" & mirage_plot_long$time == "Post"]))
n_wlex_pre_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Pre"]))
n_wlex_post_mirage <- sum(!is.na(mirage_plot_long[[endpoint_variable]][mirage_plot_long$group == "WLEX" & mirage_plot_long$time == "Post"]))

  
# Calculate both means for lipidomics ids and mirage ids
mean_data <- mirage_plot_long %>%
  group_by(group, time) %>%
  summarise(
    mean_lipidomics = mean(ifelse(in_lipidomics == TRUE, .data[[endpoint_variable]], NA), na.rm = TRUE),
    mean_mirage = mean(.data[[endpoint_variable]], na.rm = TRUE),
    .groups = 'drop'
  )

# Generate labels with original and corrected p-values including n counts
annotation_hed <- paste0(
  "HED pre (n=", n_hed_pre, ") vs post (n=", n_hed_post,
  "), p = ", formatC(p_value.hed, format = "f", digits = 3), 
  "\n MIRAGE: pre (n=", n_hed_pre_mirage, ") vs post (n=", n_hed_post_mirage,
  "), p = ", formatC(p_value.hed_mirage, format = "f", digits = 3))

annotation_diwl <- paste0(
  "DIWL pre (n=", n_diwl_pre, ") vs post (n=", n_diwl_post, 
  "), p = ", formatC(p_value.diwl, format = "f", digits = 3), 
  "\n MIRAGE: pre (n=", n_diwl_pre_mirage, ") vs post (n=", n_diwl_post_mirage, 
  "), p = ", formatC(p_value.diwl_mirage, format = "f", digits = 3))

annotation_wlex <- paste0(
  "WLEX pre (n=", n_wlex_pre, ") vs post (n=", n_wlex_post, 
  "), p = ", formatC(p_value.wlex, format = "f", digits = 3), 
  "\n MIRAGE: pre (n=", n_wlex_pre_mirage, ") vs post (n=", n_wlex_post_mirage, 
  "), p = ", formatC(p_value.wlex_mirage, format = "f", digits = 3))


annotation_pvals_slope <- paste0(
  "Slope p-values: HED vs DIWL, p = ", formatC(p_value_slope.hed_diwl, format = "f", digits = 3),
  "       |    HED vs WLEX, p = ", formatC(p_value_slope.wlex_hed, format = "f", digits = 3),
  "       |    DIWL vs WLEX, p = ", formatC(p_value_slope.diwl_wlex, format = "f", digits = 3),
  "\n MIRAGE:         HED vs DIWL, p = ", formatC(p_value_slope.hed_diwl_mirage, format = "f", digits = 3),
  "       |    HED vs WLEX, p = ", formatC(p_value_slope.wlex_hed_mirage, format = "f", digits = 3),
  "       |    DIWL vs WLEX, p = ", formatC(p_value_slope.diwl_wlex_mirage, format = "f", digits = 3)
)

# Make the plot
plot <- ggplot(mirage_plot_long, aes(
  x = factor(interaction(group, time, sep = " "),
    levels = c(
      "HED Pre",
      "HED Post", 
      "DIWL Pre", 
      "DIWL Post", 
      "WLEX Pre", 
      "WLEX Post")),
  y = !!sym(endpoint_variable), group = interaction(id, group))) +
  
  # Lines for all, colored conditionally, alpha adjusted directly
  geom_line(aes(color = if_else(in_lipidomics == TRUE, "Lipidomics", "MIRAGE"), 
                alpha = if_else(in_lipidomics == TRUE, 1, 0.95)), 
            position = position_nudge(x = 0.03)) +
  
  # Points for all, colored conditionally, alpha adjusted directly
  geom_point(aes(color = if_else(in_lipidomics == TRUE, "Lipidomics", "MIRAGE"), 
                 alpha = if_else(in_lipidomics == TRUE, 1, 0.95)),  # Adjusted alpha for visibility
             position = position_nudge(x = 0.03)) +
  
  geom_boxplot(data = mirage_plot_long[mirage_plot_long$in_lipidomics == TRUE, ],
               aes(group = interaction(group, time)),
               width = 0.3, alpha = 0.2, outlier.shape = NA,
               position = position_dodge(width = 0.75), color = "black") +
  
  # Mean line lipidomics
  geom_line(data = mean_data, aes(x = interaction(group, time, sep = " "), y = mean_lipidomics, group = group), 
            color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
  
  # Mean line MIRAGE
  geom_line(data = mean_data, aes(x = interaction(group, time, sep = " "), y = mean_mirage, group = group), 
            color = "darkgrey", alpha = 0.95, linewidth = 1, position = position_nudge(x = 0.03)) +
  
  scale_color_manual(values = c("Lipidomics" = "black", "MIRAGE" = "darkgrey"), name = "Data") +
  
  labs(
    title = paste(endpoint_variable, "(p-vals not adj.)"),
    subtitle = annotation_pvals_slope,
    y = y_label,
    x = ""
  ) +
  guides(alpha = FALSE) + # Hide the alpha legend
  # Insert P-values pre post
 annotate("text", x = 1.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
           label = annotation_hed, size = 2.1, hjust = 0.5) +
  annotate("text", x = 3.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
           label = annotation_diwl, size = 2.1, hjust = 0.5) +
  annotate("text", x = 5.5, y = max(mirage_plot_long[[endpoint_variable]], na.rm = TRUE) * 1.05,
           label = annotation_wlex, size = 2.1, hjust = 0.5) +
  theme_minimal(base_size = 12) + # Start with a minimal theme
  theme(
    axis.title.x = element_blank(), 
    axis.text.x = element_text(angle = 45, hjust = 1), 
    legend.position = "right",
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"), # Bold and centered title
    plot.subtitle = element_text(hjust = 0.5, size = 8), # Smaller and centered subtitle
    legend.text = element_text(size = 6),
    legend.title = element_text(size = 6, hjust = 0.5), 
    panel.grid.major.x = element_blank(), 
    panel.grid.minor.x = element_blank(),
    plot.caption = element_text(size = 8)
  )

# Define the directory
dir_path <- paste0("/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/mirage/", save_folder)

# Create the directory if it does not exist
if (!dir.exists(dir_path)) {
  dir.create(dir_path, recursive = TRUE)
}

# Define the filename
filename <- file.path(dir_path, paste0(endpoint_variable, ".jpg"))

# Save the plot
ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)
 
 }


### Run function
# Loop through each named element of mirage_ch_vars
for (list_name in names(mirage_ch_vars)) {
  # Print the name of the list
  for (i in 1:length(mirage_ch_vars[[list_name]])) {
    mirage_analysis_and_plot(endpoint_variable=mirage_ch_vars[[list_name]][[i]][1:2], y_label=mirage_ch_vars[[list_name]][[i]][3], save_folder = list_name)
  }}
  



# endpoint_variable <- c("mpa_mins_day_pre", "mpa_mins_day_post")
# y_label <- expression("mins/day")





```

# Table 1 statistics

```{r}
# Filter mirage subjects included in this study
mirage_included <- mirage_data %>%
    filter(id %in% lipidomicsDF$id)

# Weight loss
summary(mirage_included[mirage_included$group=="WLEX","weight_post"] - mirage_included[mirage_included$group=="WLEX","weight_pre"])

# SD
sd(mirage_included[mirage_included$group == "WLEX",]$weight_post - 
   mirage_included[mirage_included$group == "WLEX",]$weight_pre)

#DIWL
summary(mirage_included[mirage_included$group=="DIWL","weight_post"] - mirage_included[mirage_included$group=="DIWL","weight_pre"])

# SD
sd(mirage_included[mirage_included$group == "DIWL",]$weight_post - 
   mirage_included[mirage_included$group == "DIWL",]$weight_pre)

#HED
summary(mirage_included[mirage_included$group=="HED","weight_post"] - mirage_included[mirage_included$group=="HED","weight_pre"])

# SD
sd(mirage_included[mirage_included$group == "HED",]$weight_post - 
   mirage_included[mirage_included$group == "HED",]$weight_pre)


### Physical acitivity
summary(mirage_included[mirage_included$group=="WLEX","daily_steps_steps_24hr_post"] - mirage_included[mirage_included$group=="WLEX","daily_steps_steps_24hr_pre"], na.rm = TRUE)

# SD
sd(mirage_included[mirage_included$group == "WLEX",]$daily_steps_steps_24hr_post - 
   mirage_included[mirage_included$group == "WLEX",]$daily_steps_steps_24hr_pre, na.rm = TRUE)

#DIWL
summary(mirage_included[mirage_included$group=="DIWL","daily_steps_steps_24hr_post"] - mirage_included[mirage_included$group=="DIWL","daily_steps_steps_24hr_pre"], na.rm = TRUE)

# SD
sd(mirage_included[mirage_included$group == "DIWL",]$daily_steps_steps_24hr_post - 
   mirage_included[mirage_included$group == "DIWL",]$daily_steps_steps_24hr_pre, na.rm = TRUE)

#HED
summary(mirage_included[mirage_included$group=="HED","daily_steps_steps_24hr_post"] - mirage_included[mirage_included$group=="HED","daily_steps_steps_24hr_pre"], na.rm = TRUE)

# SD
sd(mirage_included[mirage_included$group == "HED",]$daily_steps_steps_24hr_post - 
   mirage_included[mirage_included$group == "HED",]$daily_steps_steps_24hr_pre, na.rm = TRUE)
```

# Analysis based on changes
## Prepare data (function)
Function to prepare and merge data into wide format

```{r}
# Function to prepare data
prepare_and_combine_data <- function(lipidomicsData, pre_post_cols, mirageData, lipidclass, lipidcomposition) {
 
# Filter and prepare lipidomics data
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
  lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass, lipidComposition == lipidcomposition)
} else {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
}
  
  # - - -
  # Remove lipid composition within lipid class if fewer non-zero values than the analysis_cutoff. Only for lipidComposition. Add new col called to to_analyse in based on number of non_zero_rows
  non_zero_rows <- lipidomics_selected %>%
  filter(pmol_mg > 0)
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, lipidComposition, pmol_mg)

  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = pmol_mg, names_prefix = "pmol_mg_") %>%
    relocate(id, .before = everything()) # Moves id to front

  # Calculate delta value
  lipidomics_wide$pmol_mg_ch <- lipidomics_wide$pmol_mg_Post - lipidomics_wide$pmol_mg_Pre

  # Adding a small constant to avoid log2(0) if there are zeros
pseudo_count <- 1
# Calculate log2 fold change directly within the dataset
lipidomics_wide <- lipidomics_wide %>%
  mutate(lipid_log2fold = log2((pmol_mg_Post + pseudo_count) / (pmol_mg_Pre + pseudo_count)))

# Calculate the mean log2 fold change and abs change for each ID, then add them back to the original dataframe
lipidomics_wide <- lipidomics_wide %>%
  group_by(id) %>%
  # Calculate mean log2 fold change for each ID
  mutate(lipid_log2fold_id_avg = mean(lipid_log2fold, na.rm = TRUE),
         # Calculate absolute change for each ID
         pmol_mg_ch_id = sum(pmol_mg_Post, na.rm = TRUE) - sum(pmol_mg_Pre, na.rm = TRUE),
         # Assign row number for each group to identify the first occurrence
         row_num = row_number()) %>%
  # Calculate log2fold change for each ID across all points
  mutate(lipid_log2fold_id = log2((sum(pmol_mg_Post, na.rm = TRUE) + pseudo_count) / 
                                   (sum(pmol_mg_Pre, na.rm = TRUE) + pseudo_count))) %>%
  ungroup() %>%
  # Only retain the calculated values for the first occurrence of each ID
  mutate(lipid_log2fold_id_avg = if_else(row_num == 1, lipid_log2fold_id_avg, NA_real_),
         pmol_mg_ch_id = if_else(row_num == 1, pmol_mg_ch_id, NA_real_),
         lipid_log2fold_id = if_else(row_num == 1, lipid_log2fold_id, NA_real_)) %>%
  # Remove the auxiliary row number column
  select(-row_num)
  
  
  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")
  
    # Loop through all lists
    for (j in 1:length(pre_post_cols)){
      for (g in 1:length (pre_post_cols[[j]])){
      pre_col <- pre_post_cols[[j]][[g]][1]
      post_col <- pre_post_cols[[j]][[g]][2]
      delta_col_name <- paste0(sub("_pre", "", pre_col), "_ch")
    
    # Calculate deltas
    combined_df <- combined_df %>%
      mutate(!!sym(delta_col_name) := as.numeric(.[[post_col]]) - as.numeric(.[[pre_col]]))
      }
      }
# }
  # Convert specified columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))

      # If lipid composition 
  if (!is.null(lipidcomposition) & nrow(non_zero_rows) < analysis_cutoff){
    combined_df$skipAnalysis <- TRUE
  }else{
        combined_df$skipAnalysis <- FALSE
    }
  
  return(combined_df)
}
```

## Statistics (function)
Function to get correlation between changes of defined parameters
```{r}
# Define a function to compute correlations of change
correlation_of_change <- function(correlation_df, lipidomicsDF, mirage_data_long_ch, mirage_variables_of_interest, lipidclass, lipidcomposition) {

# Determine the lipid name based on the presence of lipid composition
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
lipidName <- paste0(lipidclass, " ", lipidcomposition)
} else {
    lipidName <- lipidclass
}
  
  
  # Only run code if correlation df is not NA. If, Na, assign NA values to all correlation results
  if (correlation_df$skipAnalysis[[1]] == TRUE){
       # Assign NA to all results
  correlation_results <- data.frame(
    lipid = lipidName,
    test_against = NA,
    pearson_r_all = NA,
    pearson_p_all = NA,
    spearman_rho_all = NA,
    spearman_p_all = NA,
    mixed_cor_all = NA,
    mixed_p_all = NA,
    pearson_r_HED = NA,
    pearson_p_HED = NA,
    spearman_rho_HED = NA,
    spearman_p_HED = NA,
    pearson_r_DIWL = NA,
    pearson_p_DIWL = NA,
    spearman_rho_DIWL = NA,
    spearman_p_DIWL = NA,
    pearson_r_WLEX = NA,
    pearson_p_WLEX = NA,
    spearman_rho_WLEX = NA,
    spearman_p_WLEX = NA
  )
  } else {
      
   # Initialize an empty data frame to store correlation results
  correlation_results <- data.frame(
    lipid = character(),
    test_against = character(),
    pearson_r_all = numeric(),
    pearson_p_all = numeric(),
    spearman_rho_all = numeric(),
    spearman_p_all = numeric(),
    mixed_cor_all = numeric(),
    mixed_p_all = numeric(),
    pearson_r_HED = numeric(),
    pearson_p_HED = numeric(),
    spearman_rho_HED = numeric(),
    spearman_p_HED = numeric(),
    pearson_r_DIWL = numeric(),
    pearson_p_DIWL = numeric(),
    spearman_rho_DIWL = numeric(),
    spearman_p_DIWL = numeric(),
    pearson_r_WLEX = numeric(),
    pearson_p_WLEX = numeric(),
    spearman_rho_WLEX = numeric(),
    spearman_p_WLEX = numeric()
  )
  
  # Loop over every mirage variables of interest
    for (j in 1:length(mirage_variables_of_interest)){
      for (g in 1:length (mirage_variables_of_interest[[j]])){
        test_against_name <- mirage_variables_of_interest[[j]][[g]][[1]]
        test_against_name_clean <- sub("_pre$", "", test_against_name)
        test_against_name <- sub("pre$", "ch", test_against_name)
        

    # Add new row to output df
    correlation_results <- add_row(correlation_results)

    # Identify the index of the current row
    current_row_index <- nrow(correlation_results)

    # Assign lipid name and test against to last row
    correlation_results$lipid[current_row_index] <- lipidName
    correlation_results$test_against[current_row_index] <- test_against_name

    # Use pmol_mg_ch for composition within group. Use lipid_log2fold_id_avg for lipid class.
    if (is.null(lipidcomposition)) {
      lipid_unit <- "pmol_mg_ch_id"
    } else {
      lipid_unit <- "pmol_mg_ch"
    }


    # Perform Pearson and Spearman correlations for all data
    result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
    result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)


    # Assign results the the results df
    correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
    correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
    correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
    correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p

    # Calculate correlations for each group
    for (current_group in unique(correlation_df$group)) {
      # Filter the dataframe for the current group
      correlation_df_group <- filter(correlation_df, group == current_group)

      # Perform Pearson and Spearman correlations for the current group
      result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
      result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)

      # Dynamic assignment of results based on the current group
      pearson_r_col <- paste0("pearson_r_", current_group)
      pearson_p_col <- paste0("pearson_p_", current_group)
      spearman_rho_col <- paste0("spearman_rho_", current_group)
      spearman_p_col <- paste0("spearman_p_", current_group)

      correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
      correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
      correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
      correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
    }

    # Merge this transformed subset with 'lipidomicsDF' based on 'id' and 'time'
    merged_data <- left_join(lipidomicsDF, mirage_data_long_ch, by = c("id", "time"))

    # Prepare lipidomics data
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
      merged_data_filtered <- filter(merged_data, lipidClass == lipidclass, lipidComposition == lipidcomposition)
} else {
    merged_data_filtered <- filter(merged_data, lipidClass == lipidclass)
}
    
    
    # Ensure 'time' and 'group' are factors
    merged_data_filtered$time <- as.factor(merged_data_filtered$time)
    merged_data_filtered$group <- as.factor(merged_data_filtered$group)

    # Relevel 'time' so 'Pre' is the reference level
    merged_data_filtered$time <- relevel(merged_data_filtered$time, ref = "Pre")

    # Relevel 'group' so 'HED' is the reference level
    merged_data_filtered$group <- relevel(merged_data_filtered$group, ref = "HED")

    # Attempt to construct the formula, fit the model, and extract results
    tryCatch(
      {
        # Construct the formula as a string
        model_formula_str <- paste0(
          "pmol_mg ~ time * group * ", test_against_name_clean,
          " + time:", test_against_name_clean, " + (1|id)"
        )
        model_formula <- as.formula(model_formula_str)

        # Fit the mixed model to the filtered and merged data using the dynamic formula
        model <- lmer(model_formula, data = merged_data_filtered)

        # Model summary
        model_summary <- summary(model)

        # Extract p-value and correlation (assuming correlation here means the same as in the comment, which may be a typo)
        # Construct the Index String Dynamically
        index_string <- paste("timePost:", test_against_name_clean, sep = "")

        correlation_results$mixed_p_all[current_row_index] <- model_summary$coefficients[index_string, "Pr(>|t|)"]
        correlation_results$mixed_cor_all[current_row_index] <- model_summary$coefficients[index_string, "Pr(>|t|)"]
      },
      error = function(e) {
        # Handle error
        cat("An error occurred: ", e$message, "\n")
      }
    )
  }
    }
  }
  return(correlation_results)
}
```

## Plot, scatter (function)

```{r}
correlation_change_plot <- function(correlation_df, mirage_ch_vars, correlation_results, savePath, lipidclass, lipidcomposition) {
  
  # Make lipid name
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
lipidName <- paste0(lipidclass, " ", lipidcomposition)
} else {
    lipidName <- lipidclass
}
  
  
  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pmol_mg_ch))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_ch_vars, function(category) {
    lapply(category, function(item) sub("_pre", "_ch", item[1]))
    }), recursive = FALSE), use.names = FALSE)
    

    
    # If lipidcomposition is null, then only plot class
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
    # Add lipid variable to plotVars
      plotVars <- c("pmol_mg_ch", plotVars)

      # Now use ggpairs on the renamed dataframe
      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars,
        lower = list(continuous = wrap("smooth", method = "none", se = FALSE))
      )
} else {
         # Add lipid variable to plotVars
      # Make plot with log2 fold change if only class is available
      plotVars <- c("pmol_mg_ch_id", plotVars)

      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars
      )
}
    

    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }

    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)

      
      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
        x = Inf, y = Inf,
        label = paste0(
          #"Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
          
          "All: Spearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3),
          #"\nHED: Pearson, p = ", formatC(correlation_row$pearson_p_HED, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_HED, format = "f", digits = 3),
          "\nHED: Spearman, p = ", formatC(correlation_row$spearman_p_HED, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_HED, format = "f", digits = 3),
          #"\nDIWL: Pearson, p = ", formatC(correlation_row$pearson_p_DIWL, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_DIWL, format = "f", digits = 3),
          "\nDIWL: Spearman, p = ", formatC(correlation_row$spearman_p_DIWL, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_DIWL, format = "f", digits = 3),
          #"\nWLEX: Pearson, p = ", formatC(correlation_row$pearson_p_WLEX, format = "f", digits = 3),
          #", r = ", formatC(correlation_row$pearson_r_WLEX, format = "f", digits = 3),
          "\nWLEX: Spearman, p = ", formatC(correlation_row$spearman_p_WLEX, format = "f", digits = 3),
          "    |    rho = ", formatC(correlation_row$spearman_rho_WLEX, format = "f", digits = 3),
          "\n*****p-values are not adjusted*****"
        ),
        size = 3, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }


    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }

    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }

    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }

  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )

  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 35, height = 25, units = "in")
}
```

## Run functions

```{r}
# Save folder for .jpg output files
savePathClassComp <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/plot, correlations changes composition/"
savePathClass <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/plot, correlations changes class/"

# Initialize an empty data frame to hold all correlation values
correlation_values_ch_composition <- data.frame()
correlation_values_ch_class <- data.frame()

# Loop over each lipid composition within each lipidclass
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
for (lipid_class in unique_lipid_classes[!unique_lipid_classes == "PE_PC ratio"]) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    # Organize data
    correlation_df <- prepare_and_combine_data(
      lipidomicsData = lipidomicsDF,
      pre_post_cols = mirage_ch_vars,
      mirageData = mirage_data,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition
    )

    # Calculate correlations for changes
    correlation_values_ch_composition <- rbind(correlation_values_ch_composition, correlation_of_change(correlation_df, lipidomicsDF, mirage_data_long_ch, mirage_ch_vars, lipid_class, lipid_composition))

#    # Plot data - Comment out if to be used
#    correlation_change_plot(
#      correlation_df,
#      mirage_ch_vars,
#      correlation_values_ch_composition,
#      savePathClassComp,
#      lipid_class,
#      lipid_composition
#   )
  }
}

# Loop over each lipid class and make plots
for (lipid_class in unique_lipid_classes) {
  # Organize data
  correlation_df <- prepare_and_combine_data(
    lipidomicsData = lipidomicsDF,
    pre_post_cols = mirage_ch_vars,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    lipidcomposition = NULL
  )

  # Calculate correlations for changes
  correlation_values_ch_class <- rbind(correlation_values_ch_class, correlation_of_change(correlation_df, lipidomicsDF, mirage_data_long_ch, mirage_ch_vars, lipid_class, lipidcomposition = NULL))

 # Plot data - un-comment if to be used again
#  correlation_change_plot(
#    correlation_df,
#    mirage_ch_vars,
#    correlation_values_ch_class,
#    savePathClass,
#    lipid_class,
#    lipidcomposition = NULL
#  )
}


## SAVE AND LOAD VARIABLES TO NOT HAVE TO RERUN ALL THE ANALYSIS
# Define the path to save/load folder
 save_variable_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/saved variables/"
# 
# # Specify filenames for each variable
 file_correlation_values_ch_composition <- paste0(save_variable_path, "correlation_values_ch_composition.rds")
 file_correlation_values_ch_class <- paste0(save_variable_path, "correlation_values_ch_class.rds")
# 
 # Save the variables
# saveRDS(correlation_values_ch_composition, file = file_correlation_values_ch_composition)
 #saveRDS(correlation_values_ch_class, file = file_correlation_values_ch_class)

# OR LOAD VARIABLES
correlation_values_ch_composition <- readRDS(file = file_correlation_values_ch_composition)
correlation_values_ch_class <- readRDS(file = file_correlation_values_ch_class)

```

## Heatmap & vulcano plot

### Common data preparation
```{r}
#Gather the Spearman p-value columns
# For composition data
long_format_p_adj_comp <- correlation_values_ch_composition %>%
  select(lipid, test_against, spearman_p_all, spearman_p_HED, spearman_p_DIWL, spearman_p_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")

# For class data
long_format_p_adj_class <- correlation_values_ch_class %>% 
  select(lipid, test_against, spearman_p_all, spearman_p_HED, spearman_p_DIWL, spearman_p_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_p"), names_to = "spearman_type", values_to = "p_value")

# Combine both into one data frame
long_format_p_adj.non <- rbind(long_format_p_adj_comp, long_format_p_adj_class)

#Gather the Spearman rho columns
# For composition
long_format_cor_comp <- correlation_values_ch_composition %>%
  select(lipid, test_against, spearman_rho_all, spearman_rho_HED, spearman_rho_DIWL, spearman_rho_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")

# For class
long_format_cor_class <- correlation_values_ch_class %>%
  select(lipid, test_against, spearman_rho_all, spearman_rho_HED, spearman_rho_DIWL, spearman_rho_WLEX) %>%
  pivot_longer(cols = starts_with("spearman_rho"), names_to = "spearman_type", values_to = "rho_value")

# Combine composition and class into one df
long_format_cor <- rbind(long_format_cor_comp, long_format_cor_class)

# Capitalize all to ALL
long_format_p_adj.non$spearman_type <- gsub("all", "ALL", long_format_p_adj.non$spearman_type)
long_format_cor$spearman_type <- gsub("all", "ALL", long_format_cor$spearman_type)

# Remove Na rows based on NA in correlation
long_format_cor <- long_format_cor %>%
  filter(!is.na(rho_value))

# Use the 'lipid' values to filter long_format_p_adj.non
long_format_p_adj.non <- long_format_p_adj.non %>%
  filter(lipid  %in% long_format_cor$lipid)

# Adjust p-values by group
long_format_p_adj.gr <- long_format_p_adj.non %>%
  group_by(test_against, spearman_type) %>%
  mutate(p_value = p.adjust(p_value, method = "BH"))%>%
  ungroup()

# adjust p-values by group and lipidClass
# First reintroduce lipidclass
long_format_p_adj.gr.class <- long_format_p_adj.non %>%
  mutate(lipidClass = sub("^(\\S+)\\s.*$", "\\1", lipid)) %>%
  group_by(test_against, spearman_type, lipidClass) %>%
  mutate(p_value = p.adjust(p_value, method = "BH")) %>%
  ungroup()

```

### Vulcano plot

```{r}
vulcano_changes <- function(input_vars, save_sub_path, spearman_types_select, sub_folder){
### Join p-values adjusted for all lipid species and join with the rho values
# Adjust names in the spearman_type to facilitate merge
# p-val df

# Filter rows where 'test_against' column values are in 'input_vars'
vulc.pvals <- long_format_p_adj.gr[long_format_p_adj.gr$test_against %in% input_vars, ]
# Filter out only the spearman groups specified
vulc.pvals <- vulc.pvals[sub("spearman_p_", "", vulc.pvals$spearman_type) %in% spearman_types_select, ]

vulc.pvals$spearman_type <- gsub("spearman_p_", "", vulc.pvals$spearman_type)

# Correlation df
vulc.cor <- long_format_cor[long_format_cor$test_against %in% input_vars, ]
# Filter out only the spearman groups specified
vulc.cor <- vulc.cor[sub("spearman_rho_", "", vulc.cor$spearman_type) %in% spearman_types_select, ]

vulc.cor$spearman_type <- gsub("spearman_rho_", "", vulc.cor$spearman_type)



# make into single dataframe
vulc_data <- vulc.cor %>%
  left_join(vulc.pvals, by = c("lipid", "test_against", "spearman_type"))


# Make a identifier column that combines lipid, test-against and Spearman_type
vulc_data$identifier <- paste0(vulc_data$lipid, " ~ ", vulc_data$test_against, " | ", vulc_data$spearman_type)

### Plot settings
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_data$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)


### Create plot
vulc_plot <- ggplot(vulc_data, aes(x = rho_value, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", linewidth = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) +
  theme_minimal() +
  labs(title = paste0("Correlation: ", save_sub_path, " within ", sub_folder),
       x = "Spearman rho", y = "-log10 P-value") +
  theme(plot.title = element_text(hjust = 0.5))+
   geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(rho_value) > threshold_rho, identifier, "")),
                  box.padding = 0.45, point.padding = 0.5, max.overlaps = 100,
                  size = 2, segment.color = 'grey50') +

  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) 

# Save the plot
save_path <- paste0("/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/vulcano/",sub_folder, "/", save_sub_path, ".jpg")

ggsave(save_path, plot = vulc_plot, width = 14, height = 10, dpi = 400)
}

spearman_types_select.all <- c("ALL") # use ALL, HED, DIWL and WLEX
spearman_types_select.groups <- c("ALL", "HED", "DIWL", "WLEX") # use ALL, HED, DIWL, WLEX

# Loop through each main category in mirage_ch_vars
for (i in seq_along(mirage_ch_vars)) {
    # Print the name of the current list being processed
    list_name <- names(mirage_ch_vars)[i]
    print(paste("Processing list:", list_name))

    # Use lapply to iterate over each sublist in the current category
    names_to_use <- unlist(lapply(mirage_ch_vars[[i]], function(sublist) {
        # Check if the sublist is long enough to have at least the first element
        if(length(sublist) >= 1) {
            # Replace '_pre' with '_ch' in the first element
            return(gsub("_pre", "_ch", sublist[1]))
        } else {
            return(NA)  # Return NA if the sublist does not have at least one element
        }
      
    }))
    vulcano_changes(input_vars = names_to_use, sub_folder = "all" , save_sub_path = list_name, spearman_types_select = spearman_types_select.all)
    vulcano_changes(input_vars = names_to_use, sub_folder = "groups", save_sub_path = list_name, spearman_types_select = spearman_types_select.groups)
}
# Add groups_to_plot
```

### Heatmap
```{r}

heatmap_changes <- function(test_against_input, save_name)
  {
# Group lipidclasses to make multiple, clean heatmaps
lipids_groups <- list(
  gr_tag = c("TAG"),  # Triacylglycerols
  gr_dg_ac = c("1,2-DG", "1,3-DG", "AC"),  # Diglycerides and Acyl carnitines
  gr_pc = c("PC", "PE_PC ratio"),  # Phosphatidylcholines and ratio
  gr_pe = c("PE"),  # Phosphatidylethanolamines
  gr_sphingolipids = c("SPM", "SPH", "Cer", "dhCer", "GluCer", "LacCer", "GalCer"),  # Sphingolipids: Sphingomyelins, Sphingosines, Ceramides and derivatives
  gr_lyso = c("LPC", "LPE", "LPG", "LPI", "LPS"),  # Lysophospholipids
  gr_pa_ps = c("PA", "PS"),  # Group combining Phosphatidic acids and Phosphatidylserines
  gr_pg_pi = c("PG", "PI")  # Group combining Phosphatidylglycerols and Phosphatidylinositols
)

# Define function to filter and sort lipids based on group names
filter_lipid_group_base <- function(data_frame, lipid_group) {
  # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  # Sort the data_frame by lipid column
  sorted_data_frame <- data_frame[order(data_frame$lipid), ]
  # Filter based on the pattern and return the sorted & filtered data frame
  sorted_filtered_data_frame <- sorted_data_frame[grepl(pattern, sorted_data_frame$lipid), ]
  return(sorted_filtered_data_frame)
}

# Select specific test against
long_format_p_adj_selected.non <- long_format_p_adj.non[long_format_p_adj.non$test_against %in% test_against_input,]
long_format_p_adj_selected.gr <- long_format_p_adj.gr[long_format_p_adj.gr$test_against %in% test_against_input,]
long_format_p_adj_selected.gr.class <- long_format_p_adj.gr.class[long_format_p_adj.gr.class$test_against %in% test_against_input,]

long_format_corr_selected <- long_format_cor[long_format_cor$test_against %in% test_against_input,] 

# Apply the filter function to each group and store the results in a lists
# p-values
long_format_p_adj_groups.non <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.non)
long_format_p_adj_groups.gr <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr)
long_format_p_adj_groups.all <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_p_adj_selected.gr.class)
# correlations
long_format_corr_groups <- lapply(lipids_groups, filter_lipid_group_base, data_frame = long_format_corr_selected)


# Function to create 'unique_test_against' column for p-value df
mutate_unique_column_p <- function(data_frame) {
  data_frame %>%
    mutate(unique_test_against = paste0(sub("spearman_p_", "", spearman_type), "_", test_against))
}

# Adjust the function for correlation df
mutate_unique_column_corr <- function(data_frame) {
  data_frame %>%
    mutate(unique_test_against = paste0(sub("spearman_rho_", "", spearman_type), "_", test_against))
}

# Apply the mutation function to each group's data frames for p-values
long_format_p_adj_groups.non <- lapply(long_format_p_adj_groups.non, mutate_unique_column_p)
long_format_p_adj_groups.gr <- lapply(long_format_p_adj_groups.gr, mutate_unique_column_p)
long_format_p_adj_groups.all <- lapply(long_format_p_adj_groups.all, mutate_unique_column_p)

# Apply the mutation function to each group's data frames for correlations
long_format_corr_groups <- lapply(long_format_corr_groups, mutate_unique_column_corr)


# Function to perform negative log10 transformation and remove p_value column
transform_p_values <- function(df) {
  df %>%
    mutate(p_log10 = -log10(p_value)) %>%
    select(-p_value)
}

# Apply the transformation to each list
long_format_p_adj_log10.non <- lapply(long_format_p_adj_groups.non, transform_p_values)
long_format_p_adj_log10.gr <- lapply(long_format_p_adj_groups.gr, transform_p_values)
long_format_p_adj_log10.all <- lapply(long_format_p_adj_groups.all, transform_p_values)
 
# Define a function to spread the data and convert it to a matrix
spread_and_convert_matrix <- function(df, unitName) {
  result_matrix <- df %>%
    select(lipid, unique_test_against, all_of(unitName)) %>%
    pivot_wider(names_from = unique_test_against, 
                values_from = unitName, 
                values_fill = setNames(list(NA), unitName)) %>%
    column_to_rownames(var = "lipid") %>%
    as.matrix()
  return(result_matrix)
}

# Apply the function to each list
matrices_p_adj_non <- lapply(long_format_p_adj_groups.non, function(x) spread_and_convert_matrix(x, "p_value"))
matrices_p_adj_gr <- lapply(long_format_p_adj_groups.gr, function(x) spread_and_convert_matrix(x, "p_value"))
matrices_p_adj_all <- lapply(long_format_p_adj_groups.all, function(x) spread_and_convert_matrix(x, "p_value"))
# To correlation values
matrices_rho <- lapply(long_format_corr_groups, function(x) spread_and_convert_matrix(x, "rho_value"))


generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims) {
  # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
# Extract test_against by removing the first part (treatment group) and the first underscore
# This joins back the remaining parts to form the full 'test_against' label
colTitles <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) paste(x[-1], collapse = "_"))
colTitles <- unique(colTitles)
  
  
# Modify the column names to only show the group
colnames(hm_matrix) <- sapply(strsplit(colnames(hm_matrix), "_", fixed = TRUE), function(x) {
  # Concatenate the first part with the first four letters of the second part and "..."
  paste0(x[1], "", substr(x[2], 1, 0), "")
})


  Heatmap(hm_matrix,
          name = "rho", # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 9), # Change font size of row labels
          
          column_split = rep(1:(ncol(hm_matrix) / 4), each = 4), # Splits the columns and names them
          column_title = colTitles, # Custom titles for each split
          column_names_rot = 45, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 8, fontface = "bold"),
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 7, fontface = "bold"),
          #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
      
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                  if (p_val_matrix[i, j] < pLims$p1) {
                      grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p2) {
                      grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p3) {
                      grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  }
              }
          })
}

# Define color map for heatmap
color_mapping <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
hm <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)) {
  # Generate heatmap and store it in the list
  hm[[i]] <- generate_heatmap(matrices_rho[[i]], matrices_p_adj_gr[[i]], color_mapping, p_value_limits)
}

# Define the path and name of your PDF file
pdf_path <- paste0("/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/heatmap/", save_name, ".pdf")

# Open a PDF device
pdf(pdf_path, width = 12, height = 14)

# Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
for (i in 1:length (hm)){
  draw(hm[[i]])
}
dev.off()

}

# Loop over every group within the compositions
    for (i in seq_along(mirage_ch_vars)) {
        # Print the name of the current list being processed
        list_name <- names(mirage_ch_vars)[i]
        print(paste("Processing list:", list_name))
    
     test_against_input <- unlist(lapply(mirage_ch_vars[[i]], function(sublist) {
            # Check if the sublist is long enough to have at least the first element
            if(length(sublist) >= 1) {
                # Replace '_pre' with '_ch' in the first element
                return(gsub("_pre", "_ch", sublist[1]))
            }}))
      heatmap_changes(test_against_input = test_against_input, save_name = list_name)
     }
    
```


```{r}

```





## Plot p-values sorted
```{r}

# BH correct p-values
# Name the columns that should be adjusted
cols_to_adjust <- c(
  "pearson_p_all", "spearman_p_all", "mixed_p_all",
  "pearson_p_HED", "spearman_p_HED",
  "pearson_p_DIWL", "spearman_p_DIWL",
  "pearson_p_WLEX", "spearman_p_WLEX"
)

# Function to apply BH correction within each "test_against" group
adjust_p_values_within_group <- function(data, cols_to_adjust) {
  data %>%
    group_by(test_against) %>%
    mutate(across(all_of(cols_to_adjust), ~ p.adjust(.x, method = "BH"), .names = "{.col} (corrected)")) %>%
    ungroup()
}

# Apply correct function
# composition
correlation_values_ch_composition <- adjust_p_values_within_group(correlation_values_ch_composition, cols_to_adjust)
# class
correlation_values_ch_class <- adjust_p_values_within_group(correlation_values_ch_class, cols_to_adjust)
# class and composition
# combine data
correlation_values_ch_comp_and_class <- rbind(correlation_values_ch_composition, correlation_values_ch_class)
# Adjust
correlation_values_ch_comp_and_class <- adjust_p_values_within_group(correlation_values_ch_comp_and_class, cols_to_adjust)

### Plot p-values sorted
generate_barplot_ch <- function(data, col_non_corrected, col_corrected, output_base_path, data_name) {
  # Define common sizes for axis titles and plot title
  axis_title_size <- 12
  plot_title_size <- 13

  # Loop over every unique test
  for (test_var in unique(data$test_against)) {
    # Filter based on test variable
    data_test_filtered <- filter(data, test_against == test_var)

    # Remove row if non corrected column is Na
    data_test_filtered <- data_test_filtered[!is.na(data_test_filtered[[col_non_corrected]]), ]

    # Dynamic adjustment of the label size based on the number of bars (lipids)
    num_bars <- length(unique(data_test_filtered$lipid))
    label_size <- max(2, min(10, 50 / sqrt(num_bars))) # Adjusted dynamically


    # Generate plot for non-corrected p-values
    p1 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_non_corrected]]), y = data_test_filtered[[col_non_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_non_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Generate plot for corrected p-values
    p2 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_corrected]]), y = data_test_filtered[[col_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Combine the two plots
    subplot <- p1 + p2

    # Construct the subfolder path based on 'test_var'
    subfolder_path <- file.path(output_base_path, gsub("[ :()]", "_", test_var)) # Replace problematic characters

    # Ensure the subfolder exists
    dir.create(subfolder_path, recursive = TRUE, showWarnings = FALSE)

    # Construct the plot filename, ensuring no problematic characters for file names
    plot_filename <- paste0(gsub("[ :()]", "_", col_non_corrected), ", ", data_name, test_var, ".jpeg") # Replace spaces and special characters with underscores

    # Save the plot
    ggsave(file.path(subfolder_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
  }
}

# RUN FUNCTIONS
# Add a second row to cols_to_adjust with corrected column names
plot_nonadj_vs_adj <- data.frame(original = cols_to_adjust, corrected = paste0(cols_to_adjust, " (corrected)"))

# Just leave empty, as ch already indicates change in file name
dataframe_name_comp <- ""


####### MAKE FOR LIPID COMP AND CLASS!!!

# For lipid class
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/plot, p-value sorted changes/lipid class"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_ch(correlation_values_ch_class, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}

# For lipid class
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/correlations in changes/plot, p-value sorted changes/lipid class and composition"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_ch(correlation_values_ch_composition, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}
```

# Cross sectional analysis on pre

Analyse correlation between variables from the mirage dataset and the lipidomics data for all subjects at the time point pre.

## Prepare data (function)

```{r}
# run function test
# Function to prepare data
prepare_and_combine_crossSection <- function(lipidomicsData, mirageData, lipidclass, lipidcomposition) {
  
  # Filter and prepare lipidomics data. If composition is empty or if NA as PE/PC ratio is NA.
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
  lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass, lipidComposition == lipidcomposition)
} else {
    lipidomics_selected <- filter(lipidomicsData, lipidClass == lipidclass)
}
  
  
        # Remove lipid composition within lipid class if fewer non-zero values than the analysis_cutoff. Only for lipidComposition
  non_zero_rows <- lipidomics_selected %>%
  filter(pmol_mg > 0)
  
  # Select only the columns of interest before the pivot
  lipidomics_filtered <- lipidomics_selected %>%
    select(id, group, time, lipidClass, lipidComposition, pmol_mg)

  # Pivot to wide format with specific naming for pre and post columns
  lipidomics_wide <- lipidomics_filtered %>%
    pivot_wider(names_from = time, values_from = pmol_mg, names_prefix = "pmol_mg_") %>%
    relocate(id, .before = everything()) # Moves id to front

  
  ## Calculate sum within each individual to use for lipid class.
lipidomics_wide <- lipidomics_wide %>%
  group_by(id) %>%
  mutate(pmol_mg_id = if_else(row_number() == 1, sum(pmol_mg_Pre), NA_real_)) %>%
  ungroup()
  
  ### Normalize data
  # Normalization has to be within each lipidclass and composition.
  # Calculate z normalization within each lipid composition
  lipidomics_wide <- lipidomics_wide %>%
    group_by(lipidClass, lipidComposition) %>%
    mutate(lipid_normalized_z = scale(pmol_mg_Pre)[, 1]) %>%
    ungroup()

#  # Calculate the mean z-score for each ID
#  mean_z_score_per_id <- lipidomics_wide %>%
#    group_by(id) %>%
#    summarise(lipid_normalized_z_avg = mean(lipid_normalized_z, na.rm = TRUE)) %>%
#    ungroup()
#
#  # Add the normalized data back to original dataframe for only for the first occurrence of each ID
#  lipidomics_wide <- lipidomics_wide %>%
#    left_join(mean_z_score_per_id, by = "id") %>%
#    group_by(id) %>%
#    mutate(
#      row_num = row_number(),
#      lipid_normalized_z_avg = if_else(row_num == 1, lipid_normalized_z_avg, NA_real_)
#    ) %>%
#    select(-row_num) %>%
#    ungroup()

  # Combine with mirageData based on id
  combined_df <- left_join(mirageData, lipidomics_wide, by = "id")

  # Convert certain columns to factors and remove group
  combined_df <- combined_df %>%
    rename(group = group.x) %>%
    # Assuming there's no need to keep the original 'group' from the second dataframe
    select(-group.y) %>%
    # Convert specified columns to factors
    mutate(across(c(id, site, study_status, t2d_y_n, group), factor))

  
  # output Na
  if (!is.null(lipidcomposition) & nrow(non_zero_rows) < analysis_cutoff){
      combined_df$skipAnalysis <- TRUE
    }else{
      combined_df$skipAnalysis <- FALSE
    }
  
      return(combined_df)
}

```

## Statistics (function)

```{r}
# Define a function to compute correlations of change
correlation_cross_sectional <- function(correlation_df, lipidomicsDF, mirage_variables_of_interest, lipidclass, lipidcomposition) {

 # Determine the lipid name based on the presence of lipid composition   
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
  lipidName <- paste0(lipidclass, " ", lipidcomposition)
} else {
    lipidName <- lipidclass
}
  
  # Make Na if too few values determined from prepare data function
  if (correlation_df$skipAnalysis[[1]] == TRUE) {
    
      correlation_results <- data.frame(
    lipid = lipidName,
    test_against = NA,
    pearson_r_all = NA,
    pearson_p_all = NA,
    spearman_rho_all = NA,
    spearman_p_all = NA,
    pearson_r_HED = NA,
    pearson_p_HED = NA,
    spearman_rho_HED = NA,
    spearman_p_HED = NA,
    pearson_r_DIWL = NA,
    pearson_p_DIWL = NA,
    spearman_rho_DIWL = NA,
    spearman_p_DIWL = NA,
    pearson_r_WLEX = NA,
    pearson_p_WLEX = NA,
    spearman_rho_WLEX = NA,
    spearman_p_WLEX = NA
  )
  } else {
  
    # Initialize an empty data frame to store correlation results
  correlation_results <- data.frame(
    lipid = character(),
    test_against = character(),
    pearson_r_all = numeric(),
    pearson_p_all = numeric(),
    spearman_rho_all = numeric(),
    spearman_p_all = numeric(),
    pearson_r_HED = numeric(),
    pearson_p_HED = numeric(),
    spearman_rho_HED = numeric(),
    spearman_p_HED = numeric(),
    pearson_r_DIWL = numeric(),
    pearson_p_DIWL = numeric(),
    spearman_rho_DIWL = numeric(),
    spearman_p_DIWL = numeric(),
    pearson_r_WLEX = numeric(),
    pearson_p_WLEX = numeric(),
    spearman_rho_WLEX = numeric(),
    spearman_p_WLEX = numeric()
  )

  
  # Loop over every mirage variables of interest
  for (i in seq_along(mirage_variables_of_interest)) {
    for (j in seq_along(mirage_variables_of_interest[[i]])){
    
      # Manipulate current variable name
      test_against_name <- mirage_variables_of_interest[[i]][[j]][1]
      test_against_name_clean <- sub("_pre$", "", test_against_name)

      # Add new row to output df
      correlation_results <- add_row(correlation_results)
  
      # Identify the index of current row to be able to append data to it
      current_row_index <- nrow(correlation_results)
  
      # Assign lipid name and test against to last row
      correlation_results$lipid[current_row_index] <- lipidName
      correlation_results$test_against[current_row_index] <- test_against_name
  
      # Choose the correct unit for lipid class and lipid comp
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
          lipid_unit <- "pmol_mg_Pre"
} else {
    lipid_unit <- "pmol_mg_id"
}
      
      
      ### REMOVE NA NEEDED?
      
      # Perform Pearson and Spearman correlations for all data
      result_pearson_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
      result_spearman_all <- correlation(correlation_df, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
  
  
      # Assign results the the results df
      correlation_results$pearson_r_all[current_row_index] <- result_pearson_all$r
      correlation_results$pearson_p_all[current_row_index] <- result_pearson_all$p
      correlation_results$spearman_rho_all[current_row_index] <- result_spearman_all$r
      correlation_results$spearman_p_all[current_row_index] <- result_spearman_all$p
  
      # Calculate correlations for each group
      for (current_group in unique(correlation_df$group)) {
        # Filter the dataframe for the current group
        correlation_df_group <- filter(correlation_df, group == current_group)
  
  
        # Perform Pearson and Spearman correlations for the current group
        result_pearson_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "pearson", p_adjust = "none", ci = 0.95)
        result_spearman_group <- correlation(correlation_df_group, select = lipid_unit, select2 = test_against_name, method = "spearman", p_adjust = "none", ci = 0.95)
  
        # Dynamic assignment of results based on the current group
        pearson_r_col <- paste0("pearson_r_", current_group)
        pearson_p_col <- paste0("pearson_p_", current_group)
        spearman_rho_col <- paste0("spearman_rho_", current_group)
        spearman_p_col <- paste0("spearman_p_", current_group)
  
        correlation_results[[pearson_r_col]][current_row_index] <- result_pearson_group$r
        correlation_results[[pearson_p_col]][current_row_index] <- result_pearson_group$p
        correlation_results[[spearman_rho_col]][current_row_index] <- result_spearman_group$r
        correlation_results[[spearman_p_col]][current_row_index] <- result_spearman_group$p
    }
  }
  }
  }
  return(correlation_results)
}

# Test function
# cross_res <- correlation_cross_sectional (combined, lipidomicsDF, mirage_crossSectional_vars, lipidclass = "Cer", lipidcomposition = "14:0")
```

## Plot scatter (function)

```{r}
correlation_crossSectional_plot <- function(correlation_df, mirage_crossSectional_vars, correlation_results, savePath, lipidclass, lipidcomposition) {
  # Make lipid name
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
  lipidName <- paste0(lipidclass, " ", lipidcomposition)
} else {
    lipidName <- lipidclass
}
  
  # Only plot if there's data to plot
  if (!all(is.na(correlation_df$pmol_mg_Pre))) {
    # Extract the first element from each sub-list, replace "pre" with "ch", and compile into a single vector
    plotVars <- unlist(unlist(lapply(mirage_crossSectional_vars, function(category) {
    lapply(category, function(item) item[1])
    }), recursive = FALSE), use.names = FALSE)
    

    # If lipidcomposition is null, then only plot class
    
    # Filter and prepare lipidomics data
if (!is.null(lipidcomposition) && length(lipidcomposition) > 0 && !any(is.na(lipidcomposition))) {
      # Add lipid variable to plotVars
      plotVars <- c("pmol_mg_Pre", plotVars)

      # Now use ggpairs on the renamed dataframe
      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars,
        lower = list(continuous = wrap("smooth", method = "none", se = FALSE))
      )
} else {
    # Add lipid variable to plotVars
      # Make plot with log2 fold change if only class is available
      plotVars <- c("pmol_mg_id", plotVars)

      pm <- ggpairs(correlation_df,
        mapping = aes(color = group),
        columns = plotVars
      )
}
    
    # Take plots from the ggpairs plot and add to list
    plotList <- list()
    for (i in 2:(pm$ncol)) {
      plotList[[i - 1]] <- pm[i, 1]
    }

    # Add annotation to plots
    addCorrelationAnnotation <- function(plot, correlation_results, lipidName, plotVar) {
      # Get correlations for the correct lipid and test
      correlation_row <- filter(correlation_results, lipid == lipidName & test_against == plotVar)

      # Annotate plot with correlation information
      annotated_plot <- plot + annotate("text",
        x = Inf, y = Inf,
        label = paste0(
          "Non-corrected\nAll: Pearson, p = ", formatC(correlation_row$pearson_p_all, format = "f", digits = 3),
          ", r = ", formatC(correlation_row$pearson_r_all, format = "f", digits = 3),
          "\nSpearman, p = ", formatC(correlation_row$spearman_p_all, format = "f", digits = 3),
          ", rho = ", formatC(correlation_row$spearman_rho_all, format = "f", digits = 3)
        ),
        size = 1.8, hjust = 1.05, vjust = 1, alpha = 0.6
      )
      return(annotated_plot)
    }

    # Add annotations to all plots
    for (j in 1:length(plotList)) {
      plotList[[j]] <- addCorrelationAnnotation(plotList[[j]], correlation_results, lipidName, plotVars[j + 1])
    }


    # Combine all plots in plotList
    combined_plot <- plotList[[1]]
    for (i in 2:length(plotList)) {
      combined_plot <- combined_plot + plotList[[i]]
    }

    # Define the layout
    combined_plot <- combined_plot + plot_layout(ncol = 2)


    # Add title to plot
    combined_plot <- combined_plot + plot_annotation(title = lipidName, theme = theme(plot.title = element_text(hjust = .5, size = 25)))
  } else {
    combined_plot <- plot.new()
    title(main = paste("No data for", lipidName))
  }

  # Specify the file path
  file_path <- paste0(
    savePath,
    gsub("/", "_", gsub(":", ",", lipidName)), ".jpeg"
  )

  # Save the plot
  ggsave(file_path, combined_plot, device = "jpeg", width = 10, height = 14, units = "in")
}
```

## Run functions

```{r}
# Save folder for .jpg output files
savePathClassComp <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, correlations cross sectional composition/"
savePathClass <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, correlations cross sectional class/"

# Initialize an empty data frame to hold all correlation values
correlation_results_crossSection_composition <- data.frame()
correlation_results_crossSection_class <- data.frame()

# Loop over each lipid composition within each lipidclass
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)

for (lipid_class in unique_lipid_classes[!unique_lipid_classes == "PE_PC ratio"]) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    # Select and prepare data for analysis
    correlation_crossSection_df <- prepare_and_combine_crossSection(
      lipidomicsData = lipidomicsDF,
      mirageData = mirage_data,
      lipidclass = lipid_class,
      lipidcomposition = lipid_composition
    )

    # Calculate correlation coefficients
    correlation_results_crossSection_composition <- rbind(correlation_results_crossSection_composition, correlation_cross_sectional(correlation_df = correlation_crossSection_df, lipidomicsDF, mirage_variables_of_interest = mirage_crossSectional_vars, lipidclass = lipid_class, lipidcomposition = lipid_composition))


        # Plot data - Comment out if to be used
        correlation_crossSectional_plot(
          correlation_crossSection_df,
          mirage_crossSectional_vars,
          correlation_results_crossSection_composition,
          savePathClassComp,
          lipid_class,
          lipid_composition
        )
  }
}

# Loop over each lipid class and make plots
for (lipid_class in unique_lipid_classes) {
  # Organize data
  correlation_crossSection_df <- prepare_and_combine_crossSection(
    lipidomicsData = lipidomicsDF,
    mirageData = mirage_data,
    lipidclass = lipid_class,
    lipidcomposition = NULL
  )

  # Calculate correlations for changes
  correlation_results_crossSection_class <- rbind(correlation_results_crossSection_class, correlation_cross_sectional(correlation_crossSection_df, lipidomicsDF, mirage_crossSectional_vars, lipid_class, lipidcomposition = NULL))

  # Plot data - un-comment if to be used again
  correlation_crossSectional_plot(
    correlation_crossSection_df,
    mirage_crossSectional_vars,
    correlation_results_crossSection_class,
    savePathClass,
    lipid_class,
    lipidcomposition = NULL
  )
}
```

## Vulcano

```{r}
vulcano_crossSection <- function(){
# Combine class and composition data
correlation_results_crossSection_class_and_comp <- rbind(correlation_results_crossSection_composition, correlation_results_crossSection_class)

# Remove NA rows
correlation_results_crossSection_class_and_comp <- correlation_results_crossSection_class_and_comp[!is.na(correlation_results_crossSection_class_and_comp$spearman_rho_all), ]

# Select columns: Rho and p-value
vulc_data_crossSection <- correlation_results_crossSection_class_and_comp %>% 
  select("lipid", "test_against", "spearman_rho_all", "spearman_p_all")
  
# Adjust the p-value column based test_against.
vulc_data_crossSection <- vulc_data_crossSection %>%
    group_by(test_against) %>%
    mutate(across("spearman_p_all", ~ p.adjust(.x, method = "BH"), .names = "p_value")) %>%
    ungroup()

# Make a identifier column that combines lipid and test_against
vulc_data_crossSection$identifier <- paste0(vulc_data_crossSection$lipid, " ~ ", vulc_data_crossSection$test_against)


### Plot settings
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_data_crossSection$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)

### Create plot
vulc_plot <- ggplot(vulc_data_crossSection, aes(x = spearman_rho_all, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", size = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12), guide = FALSE) + # TRUE for significant, FALSE for not
  geom_text_repel(aes(label = ifelse(p_value < 0.06 & abs(spearman_rho_all) > threshold_rho, identifier, "")),
                  box.padding = .3, point.padding = .3,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  xlim(-1,1)
  labs(title = "Correlation between lipids and clinical endpoints at baseline", x = "Spearman rho", y = "-log10 P-value") +
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) # Hide the alpha legend and fix the color legend

## Display the plot
print(vulc_plot)

# Save the plot
ggsave("/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/vulcano/volcano_plot.png", plot = vulc_plot, width = 12, height = 8, dpi = 300)
}

# Run function
vulcano_crossSection()
```

## Adjust & plot p-values

**Correct p-values based on Bejamini-Hochberg**

```{r}
# BH correct p-values
# Name the columns that should be adjusted
cols_to_adjust <- c(
  "pearson_p_all", "spearman_p_all"
)

# Function to apply BH correction within each "test_against" group
adjust_p_values_within_group <- function(data, cols_to_adjust) {
  data %>%
    group_by(test_against) %>%
    mutate(across(all_of(cols_to_adjust), ~ p.adjust(.x, method = "BH"), .names = "{.col} (corrected)")) %>%
    ungroup()
}


# Apply adjustment function
# Composition and class
# Combine class and composition
correlation_results_crossSection_class_and_comp <- rbind(correlation_results_crossSection_composition, correlation_results_crossSection_class)
# Run adjustment
correlation_results_crossSection_class_and_comp <-
  adjust_p_values_within_group(correlation_results_crossSection_class_and_comp, cols_to_adjust)

# Composition
correlation_results_crossSection_composition <-
  adjust_p_values_within_group(correlation_results_crossSection_composition, cols_to_adjust)

# Class
correlation_results_crossSection_class <-
  adjust_p_values_within_group(correlation_results_crossSection_class, cols_to_adjust)

```

**Plot p-values**

```{r}
generate_barplot_crossSection <- function(data, col_non_corrected, col_corrected, output_base_path, data_name) {
  # Define common sizes for axis titles and plot title
  axis_title_size <- 12
  plot_title_size <- 13

  # Loop over every unique test
  for (test_var in unique(data$test_against)) {
    # Filter based on test variable and columns of interest
    data_test_filtered <- data %>%
      filter(test_against == test_var) %>%
      select(lipid, test_against, pearson_p_all, spearman_p_all, `pearson_p_all (corrected)`, `spearman_p_all (corrected)`)

    # Remove row if non corrected column is Na
    data_test_filtered <- data_test_filtered[!is.na(data_test_filtered[[col_non_corrected]]), ]

    # Dynamic adjustment of the label size based on the number of bars (lipids)
    num_bars <- length(unique(data_test_filtered$lipid))
    label_size <- max(2, min(10, 50 / sqrt(num_bars))) # Adjusted dynamically


    # Generate plot for non-corrected p-values
    p1 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_non_corrected]]), y = data_test_filtered[[col_non_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_non_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Generate plot for corrected p-values
    p2 <- ggplot(data_test_filtered, aes(x = reorder(lipid, data_test_filtered[[col_corrected]]), y = data_test_filtered[[col_corrected]])) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
      labs(y = "p-value", x = "Lipid", title = test_var, subtitle = col_corrected) +
      theme_minimal() +
      theme(
        axis.title.y = element_text(size = axis_title_size, face = "bold"),
        axis.title.x = element_text(size = axis_title_size, face = "bold"),
        plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(size = plot_title_size * 0.7, hjust = 0.5, face = "bold"),
        axis.text.y = element_text(size = label_size)
      )

    # Combine the two plots
    subplot <- p1 + p2

    # Construct the subfolder path based on 'test_var'
    subfolder_path <- file.path(output_base_path, gsub("[ :()]", "_", test_var)) # Replace problematic characters

    # Ensure the subfolder exists
    dir.create(subfolder_path, recursive = TRUE, showWarnings = FALSE)

    # Construct the plot filename, ensuring no problematic characters for file names
    plot_filename <- paste0(gsub("[ :()]", "_", col_non_corrected), ", ", data_name, test_var, ".jpeg") # Replace spaces and special characters with underscores

    # Save the plot
    ggsave(file.path(subfolder_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
  }
}


# RUN FUNCTIONS
# Add a second row to cols_to_adjust with corrected column names
plot_nonadj_vs_adj <- data.frame(original = cols_to_adjust, corrected = paste0(cols_to_adjust, " (corrected)"))

# Just leave empty, as ch already indicates change in file name
dataframe_name_comp <- ""


# For lipid class
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, p-value sorted cross section/class"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_class, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}


# For lipid composition within lipid class
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, p-value sorted cross section/composition"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_composition, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}

# For lipid composition and lipid class combined
# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/cross section/plot, p-value sorted cross section/class and composition"

for (i in 1:nrow(plot_nonadj_vs_adj)) {
  generate_barplot_crossSection(correlation_results_crossSection_class_and_comp, plot_nonadj_vs_adj$original[i], plot_nonadj_vs_adj$corrected[i], output_base_path, dataframe_name_comp)
}
```

# Pre-post analysis

## Mixed models

Insulin sensitivity. Original data was analyzed by one-way ANOVA. So this would be to double check results mixed model for pre-post changes for every lipid composition within all lipid classes and for every lipid class.

```{r}
# Set the max number of observations that the emmeans package will handle. Lower number shorter computation times, larger number, more precise CI and p-value estimates
emm_options(pbkrtest.limit = 6000) # change to 5000 after code works

mixedmodel_pre_post <- function(dataset, response_var, lipidclass, lipidcomposition = NULL) {
  # Filter dataset based on lipidclass and optionally lipidcomposition
  if (!is.null(lipidcomposition)) {
    data_to_model <- filter(dataset, lipidClass == lipidclass & lipidComposition == lipidcomposition)
  } else {
    data_to_model <- filter(dataset, lipidClass == lipidclass)
  }

  
  # Check number of non-zero rows
  non_zero_rows <- data_to_model %>% 
    filter(pmol_mg > 0) %>% 
    nrow()
  
  # only proceed if number of non zero rows is above cutoff
  if (non_zero_rows < analysis_cutoff){
    return(list(estimates = NA, pvals = NA))
  } else {
    
  # Prepare factors
  data_to_model$group <- factor(data_to_model$group, levels = c("HED", "DIWL", "WLEX"))
  data_to_model$time <- factor(data_to_model$time, levels = c("Pre", "Post"))

#  # Remove Na rows
#  data_to_model <- data_to_model[!is.na(data_to_model$pmol_mg), ]
#
#
#  # Remove lipidcomposition with only 0
#  data_to_model <- data_to_model %>%
#    group_by(lipidComposition) %>%
#    filter(any(pmol_mg != 0)) %>%
#    ungroup()


  # Determine if lipidComposition can be a random effect
  if (!is.null(lipidcomposition) || length(unique(data_to_model$lipidComposition)) <= 1) {
    model_formula <- as.formula(paste(response_var, "~ time * group + (1 | id)"))
  } else {
    model_formula <- as.formula(paste(response_var, "~ time * group +
                                      (1 | id) + (1 + time | lipidComposition)"))
  }

  # Try-catch block for model fitting
  tryCatch(
    {
      model <- lmer(model_formula,
                    data = data_to_model,
                    na.action = na.exclude)
      # Estimated marginal of means to get out slope and between groups statistics
      emm <- emmeans(model, ~ time * group)

      # Contrasts for differences in slopes between groups
      model.slope.contrasts <- contrast(emm, method = "revpairwise", interaction = "pairwise", adjust = "none")

      model.slope.contrasts.results <- summary(model.slope.contrasts)

      # Add the new 'contrast' column and remove the original "time_pairwise" and "group_pairwise" columns
      model.slope.contrasts.results <- model.slope.contrasts.results %>%
        mutate(contrast = paste(time_pairwise, group_pairwise, sep = " : ")) %>%
        select(contrast, estimate, SE, df, t.ratio, p.value)

      # Pre, Post between group comparisons
      prepost.contrasts <- pairs(emm, adjust = "none")

      # Get results
      prepost.contrasts.results <- summary(prepost.contrasts)

      return(list(lipidClass = as.character(lipidclass), lipidComposition = as.character(lipidcomposition), slope_results = model.slope.contrasts.results, prepost_results = prepost.contrasts.results))
    },
    error = function(e) {
      return(list(estimates = NA, pvals = NA))
    }
  )
}
  }

# Run function for lipid composition within lipid class
result.lipid.pre_post.class_comp <- pmap(
  list(lipidClass = unique_combinations$lipidClass, lipidComposition = unique_combinations$lipidComposition),
  ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", ..1, ..2)
)
# Naming the results list elements
names(result.lipid.pre_post.class_comp) <- paste(unique_combinations$lipidClass, unique_combinations$lipidComposition, sep = "_")

# Use map to iterate over lipid classes
result.lipid.pre_post.class <- map(unique_lipid_classes, ~ mixedmodel_pre_post(lipidomicsDF, "pmol_mg", .x))

# Naming the results list
names(result.lipid.pre_post.class) <- unique_lipid_classes
```

## Prepare data

Sort, adjust by Benjamini-Hochberg for lipid composition within lipid class

```{r}
prepare_lipid_data_for_plotting <- function(result_data) {
  pvals_df <- data.frame()
  est_df <- data.frame()

  contrasts_prepost <- c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX")
  contrasts_slope <- c("Pre - Post : HED - DIWL", "Pre - Post : HED - WLEX", "Pre - Post : DIWL - WLEX")

  for (test_name in names(result_data)) {
    # Check if prepost_results and slope_results are not NULL
    if (!is.null(result_data[[test_name]]$prepost_results)) {
      prepost_results <- result_data[[test_name]]$prepost_results
    } else {
      prepost_results <- data.frame(contrast = character(), p.value = numeric())
    }

    if (!is.null(result_data[[test_name]]$slope_results)) {
      slope_results <- result_data[[test_name]]$slope_results
    } else {
      slope_results <- data.frame(contrast = character(), p.value = numeric())
    }

    # Proceed with extraction using the ensured data frames
    prepost_pvals <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)

    slope_pvals <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$p.value[1] else NA
    }, USE.NAMES = TRUE)

        prepost_est <- sapply(contrasts_prepost, function(c) {
      filtered <- prepost_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    slope_est <- sapply(contrasts_slope, function(c) {
      filtered <- slope_results %>%
        filter(contrast == c)
      if (nrow(filtered) > 0) filtered$estimate[1] else NA
    }, USE.NAMES = TRUE)
    
    
    # Combine values into single data
    # p-values
    combined_pvals <- c(prepost_pvals, slope_pvals)
    combined_pvals <- setNames(combined_pvals, c(contrasts_prepost, contrasts_slope))
    pvals_df <- rbind(pvals_df, cbind(lipid = test_name, t(as.data.frame(list(combined_pvals)))))
    
    # Estimates
    combined_est <- c(prepost_est, slope_est)
    combined_est <- setNames(combined_est, c(contrasts_prepost, contrasts_slope))
    est_df <- rbind(est_df, cbind(lipid = test_name, t(as.data.frame(list(combined_est)))))
    
  }

  # Select all columns after the first one to exclude lipid column
  corrected_cols <- names(pvals_df)[-1]

     # Remove rows where every column from the second column onwards contains NA
   pvals_df <- pvals_df[rowSums(is.na(pvals_df[, -1])) < (ncol(pvals_df) - 1), ]
  
  # Apply Benjamini-Hochberg correction and create new columns with the suffix "_BH_corrected"
  for (col in corrected_cols) {
    pvals_df[[paste0(col, " (corrected)")]] <- p.adjust(pvals_df[[col]], method = "BH")
  }

  # Reset row names to simple sequential numbers
  rownames(pvals_df) <- NULL
  rownames(est_df) <- NULL

   # Only keep rows in est_df where the lipid values match those in pvals_df
est_df <- est_df[est_df$lipid %in% pvals_df$lipid, ]
  
  # Convert the columns to numeric
 # p-vals
   for (i in 2:ncol(pvals_df)) {
    if (!is.numeric(pvals_df[[i]])) {
      pvals_df[[i]] <- as.numeric(pvals_df[[i]])
    }
  }
  # estimates 
   for (i in 2:ncol(est_df)) {
    if (!is.numeric(est_df[[i]])) {
      est_df[[i]] <- as.numeric(est_df[[i]])
    }
  }

  # Combine the est and pvals dataframes into a list to be returned
  est_and_pvals <- list(p.vals = pvals_df, estimates = est_df)
  return(est_and_pvals)
}

# Run for class and composition combined
# Combine lists
result.lipid.pre_post.class_and_comp <- c(result.lipid.pre_post.class_comp, result.lipid.pre_post.class)
# Run prepare data function on combined list
est_and_p_lipid_class_and_comp <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_and_comp)

# Prepare data for plotting lipid composition within each lipid class
est_and_p_lipid_comp <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class_comp)

# Prepare data for plotting lipid classes
est_and_p_pvals_lipid_class <- prepare_lipid_data_for_plotting(result.lipid.pre_post.class)
```

## Heatmap & vulcano plot

### Prepare data

```{r}
# Assuming your list is named list_df
pvals_df <- est_and_p_lipid_class_and_comp$p.vals
estimates_df <- est_and_p_lipid_class_and_comp$estimates


# Select the specified columns for hm_data.p-vals matrix
pvals_df <- pvals_df[ , c("lipid", "Pre HED - Post HED (corrected)", "Pre DIWL - Post DIWL (corrected)", 
                               "Pre WLEX - Post WLEX (corrected)", "Pre - Post : HED - DIWL (corrected)",
                               "Pre - Post : HED - WLEX (corrected)", "Pre - Post : DIWL - WLEX (corrected)")]


### Calculate log2 change
# Composition
log2fold_ch_comp <- lipidomicsDF %>%
  group_by(lipidClass, lipidComposition, group) %>%
  summarize(
    log2fCh = log2(mean(pmol_mg[time == "Post"], na.rm = TRUE) / 
                          mean(pmol_mg[time == "Pre"], na.rm = TRUE)),
    .groups = "drop"
  )

# Class
log2fold_ch_class <- lipidomicsDF %>%
  group_by(lipidClass, group) %>%
  summarize(
    log2fCh = log2(mean(pmol_mg[time == "Post"], na.rm = TRUE) / 
                          mean(pmol_mg[time == "Pre"], na.rm = TRUE)),
    .groups = "drop"
  )

# Make names to match lipid
# Composition
log2fold_ch_comp <- log2fold_ch_comp %>%
  mutate(lipid = paste(lipidClass, lipidComposition, sep = "_")) %>%
  select(-lipidComposition, -lipidClass)

# Class
log2fold_ch_class <- log2fold_ch_class %>%
  rename(lipid = lipidClass)

# Combine lipid composition and lipid class data
log2fold_ch <- rbind(log2fold_ch_class, log2fold_ch_comp)

# Rename col names to match the ones on the DF
log2fold_ch <- log2fold_ch %>%
  mutate(group = case_when(
    group == "HED"  ~ "Pre HED - Post HED",
    group == "DIWL" ~ "Pre DIWL - Post DIWL",
    group == "WLEX" ~ "Pre WLEX - Post WLEX",
    TRUE ~ group  # Keeps the original value if none of the above conditions are met
  ))

### Replace the model change values with the log2change
# Reshape estimates_df from wide to long format to make replacement
estimates_long <- estimates_df %>%
  pivot_longer(
    cols = c("Pre HED - Post HED", "Pre DIWL - Post DIWL", "Pre WLEX - Post WLEX"),
    names_to = "group",
    values_to = "value"
  )
# perform replacement based on lipid and group
estimates_long_log2ch <- estimates_long %>%
  left_join(log2fold_ch, by = c("lipid", "group")) %>%
  mutate(value = if_else(!is.na(log2fCh), log2fCh, value)) %>%
  select(-log2fCh)

# pivot back to wide format
estimates_df_log2ch <- estimates_long_log2ch %>%
  pivot_wider(
    names_from = group,
    values_from = value
  )

### Slope: Relative changes
# Calculate the mean at time Pre for every lipidComposition within lipidClass and for lipidClass across all groups to use for normalization
lipidomicsDF <- lipidomicsDF %>%
  # First, add the mean for composition + class
  group_by(lipidComposition, lipidClass) %>%
  mutate(pmol_mg_pre_mean_comp = ifelse(time == "Pre", mean(pmol_mg[time == "Pre"], na.rm = TRUE), NA)) %>%
  ungroup() %>%
  # Then, add the mean for class only
  group_by(lipidClass) %>%
  mutate(pmol_mg_pre_mean_class = ifelse(time == "Pre", mean(pmol_mg[time == "Pre"], na.rm = TRUE), NA)) %>%
  ungroup()

# Calculate absolute pre-post changes
# Composition
slope_norm_ch_comp <- lipidomicsDF %>%
  group_by(lipidClass, lipidComposition, group) %>%
  summarize(
    norm_ch = (mean(pmol_mg[time == "Post"], na.rm = TRUE) - 
      mean(pmol_mg[time == "Pre"], na.rm = TRUE)) /
      mean(pmol_mg_pre_mean_comp[time == "Pre"], na.rm = TRUE),
    .groups = "drop"
  )

# Class
slope_norm_ch_class <- lipidomicsDF %>%
  group_by(lipidClass, group) %>%
  summarize(
    norm_ch = (mean(pmol_mg[time == "Post"], na.rm = TRUE) - 
      mean(pmol_mg[time == "Pre"], na.rm = TRUE)) / 
      mean(pmol_mg_pre_mean_class[time == "Pre"], na.rm = TRUE),
    .groups = "drop"
  )


# Make single lipid name for later matching
# Composition
slope_norm_ch_comp <- slope_norm_ch_comp %>%
  mutate(lipid = paste(lipidClass, lipidComposition, sep = "_")) %>%
  select(-lipidComposition, -lipidClass)

# Class
slope_norm_ch_class <- slope_norm_ch_class %>%
  rename(lipid = lipidClass)

# Combine lipid composition and lipid class data
slope_norm_ch <- rbind(slope_norm_ch_class, slope_norm_ch_comp)

# Spread the data for each group to be a separate column
slope_norm_ch_wide <- slope_norm_ch %>%
  pivot_wider(names_from = group, values_from = norm_ch)

# Calculate the difference between slope changes and make pct.
# This makes the values differences in "percentage points"
slope_ch_pp <- slope_norm_ch_wide %>%
  mutate(`Pre - Post : HED - WLEX` = (WLEX - HED)*100,
         `Pre - Post : HED - DIWL` = (DIWL - HED)*100,
         `Pre - Post : DIWL - WLEX` = (WLEX - DIWL)*100)

# Remove the cols with differences between pre and post
slope_ch_pp <- slope_ch_pp %>%
  select(-WLEX, -HED, -DIWL)

# Replace slope values in the estimates data frame
# Join the dataframes based on 'lipid' to align rows
joined_df <- estimates_df_log2ch %>%
  left_join(slope_ch_pp, by = "lipid", suffix = c("", ".normch"))

# Replace values in the original columns with values from the joined columns
estimates_df_plotData <- joined_df %>%
  mutate(`Pre - Post : HED - DIWL` = `Pre - Post : HED - DIWL.normch`,
         `Pre - Post : HED - WLEX` = `Pre - Post : HED - WLEX.normch`,
         `Pre - Post : DIWL - WLEX` = `Pre - Post : DIWL - WLEX.normch`) %>%
  select(-ends_with(".normch"))


# Convert tibble to dataframe for later naming
estimates_df_plotData <- as.data.frame(estimates_df_plotData)
```

### Vulcano

```{r}
# Turn into two dataframes:
# First: Slope, test_against
# Selecting the relevant columns for transformation
estimates_df_slope <- estimates_df_plotData %>%
  select(lipid, `Pre - Post : HED - DIWL`, `Pre - Post : HED - WLEX`, `Pre - Post : DIWL - WLEX`)

# Transforming into long format
vulc_slope <- estimates_df_slope %>%
  pivot_longer(
    cols = -lipid, # Exclude the 'lipid' column from the reshaping process
    names_to = "test_against", # New column for the original column names
    values_to = "ch_pp" # New column for the values from the reshaped columns
  )

# Second: Pre/post, test_against, p_value
# Selecting the relevant columns for transformation
estimates_df_prePost <- estimates_df_plotData %>%
  select(lipid, `Pre HED - Post HED`, `Pre DIWL - Post DIWL`, `Pre WLEX - Post WLEX`)

# Transforming into long format
vulc_prePost <- estimates_df_prePost %>%
  pivot_longer(
    cols = -lipid, # Exclude the 'lipid' column from the reshaping process
    names_to = "test_against", # New column for the original column names
    values_to = "log2foldch" # New column for the values from the reshaped columns
  )

## Add p-values
# Adjust the names in pvals_df to match those in vulc_slope and vulc_prePost
# First copy pvals_df to not alter
pvals_df_mod <- pvals_df
# then change names
names(pvals_df_mod) <- sub(" \\(corrected\\)", "", names(pvals_df))

# Transform pvals_df into long format
pvals_long <- pvals_df_mod %>%
  pivot_longer(
    cols = -lipid, # Exclude 'lipid'
    names_to = "test_against", # New column for the original column names
    values_to = "p_value" # New column for the p-values
  )

# Join p-values to the dataframes to plot
# Joining p-values to vulc_prePost
vulc_prePost <- left_join(vulc_prePost, pvals_long, by = c("lipid", "test_against"))

# Joining p-values to vulc_slope
vulc_slope <- left_join(vulc_slope, pvals_long, by = c("lipid", "test_against"))

### Make identifier columns based on lipid name and test_against 
# Adding 'identifier' column to vulc_prePost
vulc_prePost <- vulc_prePost %>%
  mutate(identifier = paste(lipid, test_against, sep = " ~ "))

# Adding 'identifier' column to vulc_slope
vulc_slope <- vulc_slope %>%
  mutate(identifier = paste(lipid, test_against, sep = " ~ "))
```

#### Slope

```{r}
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_slope$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)


### Create plot
vulc_plot <- ggplot(vulc_slope, aes(x = ch_pp, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", size = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) + # TRUE for significant, FALSE for not; 1 not translucent; 0.12 very translucent
  geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(ch_pp) > threshold_rho, lipid, "")),
                  box.padding = 0.35, point.padding = 0.5,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  labs(title = "Differences in pre-to-post slopes between groups", x = "Delta slope (pp)", y = "-log10 P-value") +
  xlim(-200,200)+
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) # Hide the alpha legend and fix the color legend

## Display the plot
print(vulc_plot)

# Save the plot
ggsave("/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/vulcano/slope_volcano.jpg", plot = vulc_plot, width = 8, height = 10, dpi = 400)
```

#### Pre-post

```{r}
# Set threshold for when to plot label
threshold_rho <- 0.2

# Assuming unique_tests has been defined as before
unique_tests <- sort(unique(vulc_prePost$test_against))


# Generate a palette of evenly spaced colors across the HCL (Hue, Chroma, Luminance) color space
base_colors <- grDevices::hcl(h = seq(15, 375, length = length(unique_tests) + 1),
                              c = 100, 
                              l = 65)[1:length(unique_tests)]

# Assign each test to a color
colors_for_tests <- setNames(base_colors, unique_tests)


### Create plot
vulc_plot <- ggplot(vulc_prePost, aes(x = log2foldch, y = -log10(p_value))) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black", size = 0.2) +
  geom_point(aes(color = test_against, alpha = p_value < 0.05)) +
  scale_color_manual(values = colors_for_tests) +
  scale_alpha_manual(values = c(`TRUE` = 1, `FALSE` = 0.12)) + # TRUE for significant, FALSE for not; 1 not translucent; 0.12 very translucent
  geom_text_repel(aes(label = ifelse(p_value < 0.05 & abs(log2foldch) > threshold_rho, lipid, "")),
                  box.padding = 0.35, point.padding = 0.5,
                  size = 3, segment.color = 'grey50') +
  theme_minimal() +
  labs(title = "Differences in pre-to-post", x = "log2fc", y = "-log10 P-value") +
  #xlim(-2,2)+
  guides(alpha = "none", color = guide_legend(override.aes = list(alpha = 1))) # Hide the alpha legend and fix the color legend

## Display the plot
print(vulc_plot)

# Save the plot
ggsave("/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/vulcano/prePost_volcano.jpg", plot = vulc_plot, width = 8, height = 10, dpi = 300)
```

### Heatmap

```{r}
# Set 'lipid' as row names
rownames(pvals_df) <- pvals_df$lipid
rownames(estimates_df_plotData) <- estimates_df_plotData$lipid

# Remove the 'lipid' column
pvals_df <- pvals_df[ , !(names(pvals_df) %in% c("lipid"))]
estimates_df_plotData <- estimates_df_plotData[ , !(names(estimates_df_plotData) %in% c("lipid"))]

# Rename columns by removing " (corrected)" from all column names in pvals_df
colnames(pvals_df) <- gsub(" \\(corrected\\)", "", colnames(pvals_df))

# Sort column names
common_cols <- intersect(colnames(estimates_df_plotData), colnames(pvals_df))
estimates_df_plotData <- estimates_df_plotData[, common_cols, drop = FALSE]
pvals_df <- pvals_df[, common_cols, drop = FALSE]

### Devide dataframe based on lipid groups
# Define lipid groups
lipids_groups <- list(
  gr_tag = c("TAG"),  # Triacylglycerols
  gr_dg_ac = c("1,2-DG", "1,3-DG", "AC"),  # Diglycerides and Acyl carnitines
  gr_pc = c("PC", "PE_PC ratio"),  # Phosphatidylcholines and ratio
  gr_pe = c("PE"),  # Phosphatidylethanolamines
  gr_sphingolipids = c("SPM", "SPH", "Cer", "dhCer", "GluCer", "LacCer", "GalCer"),  # Sphingolipids: Sphingomyelins, Sphingosines, Ceramides and derivatives
  gr_lyso = c("LPC", "LPE", "LPG", "LPI", "LPS"),  # Lysophospholipids
  gr_pa_ps = c("PA", "PS"),  # Group combining Phosphatidic acids and Phosphatidylserines
  gr_pg_pi = c("PG", "PI")  # Group combining Phosphatidylglycerols and Phosphatidylinositols
)

### Divide dataframe based on lipid groups with lipid as row name
filter_lipid_group_row <- function(data_frame, lipid_group) {
 
   # Create the pattern for matching lipid groups
  pattern <- paste0("^(", paste(lipid_group, collapse = "|"), ")")
  
  # Convert row names to a temporary column for sorting and filtering
  data_frame_with_lipid <- tibble::rownames_to_column(data_frame, var = "lipid")
  
  # Sort the dataframe by the temporary lipid column
  sorted_data_frame_with_lipid <- data_frame_with_lipid[order(data_frame_with_lipid$lipid), ]
  
  # Filter based on the pattern
  sorted_filtered_data_frame_with_lipid <- sorted_data_frame_with_lipid[grepl(pattern, sorted_data_frame_with_lipid$lipid), ]
  
  # Drop the temporary lipid column and return to original format
  rownames(sorted_filtered_data_frame_with_lipid) <- sorted_filtered_data_frame_with_lipid$lipid
  sorted_filtered_data_frame <- sorted_filtered_data_frame_with_lipid[ , !colnames(sorted_filtered_data_frame_with_lipid) %in% 'lipid', drop = FALSE]
  return(sorted_filtered_data_frame)
}


# Apply the filter function to each group and store the results in a lists
# p-values
pvals_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = pvals_df)

# estimates
estimates_gr_list <- lapply(lipids_groups, filter_lipid_group_row, data_frame = estimates_df_plotData)

# Convert all dataframes to matrices
matrices_pvals <- lapply(pvals_gr_list, function(x) as.matrix(x))
matrices_estimates <- lapply(estimates_gr_list, function(x) as.matrix(x))


generate_heatmap <- function(hm_matrix, p_val_matrix, colorMap, pLims, hm_title, hm_unit) {
  # Assumes pLims is a list with named elements corresponding to each threshold, e.g., list(p1 = 0.001, p2 = 0.01, p3 = 0.05)
  
# Extract test_against by removing the first part (treatment group) and the first underscore
# This joins back the remaining parts to form the full 'test_against' label
colTitles <- c("Slope", "Pre vs Post")

  Heatmap(hm_matrix,
          name = hm_unit, # Sets the name of the color scale
          
          col = colorMap, # Use provided color map
          rect_gp = gpar(col = "white", lwd = 0.5), # Make space between each square
          row_names_side = "left", # Position of row labels
          row_names_gp = gpar(fontsize = 7.5 ), # Change font size of row labels
          
          #column_split = rep(1:(ncol(hm_matrix) / 3), each = 3), # Splits the columns and names them
          column_title = hm_title,
          column_names_rot = 45, # Rotate column names for better readability
          column_names_gp = gpar(fontsize = 8, fontface = "bold"),
          column_title_side = "top", # Placement of the column titles
          column_title_gp = gpar(fontsize = 10, fontface = "bold"),
          #column_title = NULL, # Removes titles for split (could be adjusted to represent test)
      
          border = TRUE, # Set border around the splits
          cluster_rows = FALSE, # Don't make clusters
          cluster_columns = FALSE, # Don't make clusters
          
          cell_fun = function(j, i, x, y, width, height, fill) {
              if (!is.na(p_val_matrix[i, j])) {
                  if (p_val_matrix[i, j] < pLims$p1) {
                      grid.text("+++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p2) {
                      grid.text("++", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  } else if (p_val_matrix[i, j] < pLims$p3) {
                      grid.text("+", x, y, gp = gpar(col = "black", fontsize = 7, fontface = "bold"), just = "center")
                  }
              }
          })
}

# Define color map for heatmap
color_mapping_slope <- colorRamp2(c(-300, 0, 300), c("blue", "white", "red"))
color_mapping_pre_post <- colorRamp2(c(-3, 0, 3), c("darkgreen", "white", "orange"))

# Set p-value limits
p_value_limits <- list(p1 = 0.001, p2 = 0.01, p3 = 0.05)

# Create a list for the heatmaps
hm <- list()

# Assuming 'matrices_rho$gr1' is your correlation matrix and 'matrices_p_adj_non$gr1' is your p-value matrix
for (i in 1:length(lipids_groups)) {
  # Generate slope and pre/post hm
  
  hm_slope <- generate_heatmap(matrices_estimates[[i]][,1:3], matrices_pvals[[i]][,1:3], color_mapping_slope, p_value_limits, hm_title = "Slope ", hm_unit = "pp")
  hm_pre_post <- generate_heatmap(matrices_estimates[[i]][,4:6], matrices_pvals[[i]][,4:6], color_mapping_pre_post, p_value_limits, hm_title = "Pre vs Post", hm_unit = "log2foldch")
  
  # Combine heat maps and store in list
  hm[[i]] <- hm_slope + hm_pre_post
  # Generate heatmap and store it in the list
}

# Define the path and name of your PDF file
pdf_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/heatmap/heatmap.pdf"

# Open a PDF device
pdf(pdf_path, width = 8, height = 10)

# Draw your heatmaps. Each call to draw() will create a new page in the PDF for each heatmap
for (i in 1:length (hm)){
  draw(hm[[i]])
}

# Don't forget to close the device
dev.off()

```

## p-value plots

Make plots of p-values sorted highest to lowest for lipid classes and lipid compositions within each lipid class

```{r}
generate_barplot <- function(data, col_index_non_corrected, col_index_corrected, output_base_path, data_name) {
  # Extract test names based on indices
  test_name_non_corrected <- names(data)[col_index_non_corrected]
  test_name_corrected <- names(data)[col_index_corrected]

  # Use output_base_path directly, no sub-folders created
  output_path <- output_base_path

  # Prepare and sort data for plotting
  data$lipid <- factor(data$lipid, levels = unique(data$lipid))

  # Define common sizes for axis titles and plot title
  axis_title_size <- 13
  plot_title_size <- 10

  # Dynamic adjustment of the label size based on the number of bars (lipids)
  num_bars <- length(unique(data$lipid))
  label_size <- max(2, min(11, 50 / sqrt(num_bars))) # Adjusted dynamically

  # Generate plot for non-corrected p-values
  p1 <- ggplot(data, aes(x = reorder(lipid, .data[[test_name_non_corrected]]), y = .data[[test_name_non_corrected]])) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
    labs(y = "P-value", x = "lipid", title = test_name_non_corrected) +
    theme_minimal() +
    theme(
      axis.title.y = element_text(size = axis_title_size, face = "bold"),
      axis.title.x = element_text(size = axis_title_size, face = "bold"),
      plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = label_size)
    )

  # Generate plot for corrected p-values
  p2 <- ggplot(data, aes(x = reorder(lipid, .data[[test_name_corrected]]), y = .data[[test_name_corrected]])) +
    geom_bar(stat = "identity", fill = "darkgreen") +
    coord_flip() +
    geom_hline(yintercept = 0.05, color = "red", linetype = "solid") +
    labs(y = "Corrected P-value", x = "lipid", title = test_name_corrected) +
    theme_minimal() +
    theme(
      axis.title.y = element_text(size = axis_title_size, face = "bold"),
      axis.title.x = element_text(size = axis_title_size, face = "bold"),
      plot.title = element_text(size = plot_title_size, hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = label_size)
    )

  # Combine the two plots
  subplot <- p1 + p2

  # Construct the plot filename
  plot_filename <- paste0(data_name, " ", gsub("[ :()]", " ", test_name_non_corrected), ".jpeg")

  # Save the subplot
  ggsave(file.path(output_path, plot_filename), plot = subplot, device = "jpeg", width = 10, height = 13, dpi = 400)
}

# Define output path
output_base_path <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/plot, p-value sorted pre-post"

# Column indices to plot against one another; non-corrected vs corrected p-values
cols_to_plot <- matrix(c(2, 8, 3, 9, 4, 10, 5, 11, 6, 12, 7, 13), ncol = 2, byrow = TRUE)

# Loop through each pair of columns and generate the plots
# Lipid class
dataframe_name <- "lipid class"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_pvals_lipid_class$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/class"), dataframe_name)
}

# Lipid class and composition
dataframe_name_comp <- "lipid comp"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_lipid_comp$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/composition"), dataframe_name_comp)
}

# Lipid class and composition
dataframe_name_comp_and_class <- "lipid class and comp"

for (i in 1:nrow(cols_to_plot)) {
  generate_barplot(est_and_p_lipid_class_and_comp$p.vals, cols_to_plot[i, 1], cols_to_plot[i, 2], paste0(output_base_path, "/comp_and_class"), dataframe_name_comp)
}

```

## Scatter plots
### Lipid composition
Composition scatter plot Data points above ULOQ and below LLOQ are marked with triangles for.

```{r}
# Create a named vector mapping IDs to continuous values for coloring
# color_map <- setNames(mirage_data$gender, mirage_data$id)

plot_lipid <- function(lipidomicsDF, lipid_composition, lipid_class, detection_limits, p_val_df) {
  filtered_data <- filter(lipidomicsDF, lipidClass == lipid_class & lipidComposition == lipid_composition & !is.na(time))

  # Find the min and max of the y-axis data and add a buffer
  y_min <- min(filtered_data$pmol_mg, na.rm = TRUE) * 0.95 # 5% buffer reduced
  y_max <- max(filtered_data$pmol_mg, na.rm = TRUE) * 1.05 # 5% buffer increased

  # Find correct p-values
  search_key <- paste(lipid_class, lipid_composition, sep = "_")
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]

  
    # Calculate means for each group and time point
mean_data_comp <- filtered_data %>%
  group_by(group, time) %>%
  summarise(mean_pmol_mg = mean(pmol_mg, na.rm = TRUE),
            .groups = 'drop')
  

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )
  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )

  # Make the plot
  plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = pmol_mg, group = interaction(id, group)
  )) +
    geom_line(aes(group = interaction(id, group), color = id), position = position_nudge(x = 0.03)) +
    
      geom_point(aes(color = id), alpha = 0.5, position = position_nudge(x = 0.03)) +
    geom_boxplot(aes(group = interaction(group, time)), color = "black",
      width = 0.3, alpha = 0.2, outlier.shape = NA,
      position = position_dodge(width = 0.75)
    ) +
    geom_point(
      data = subset(filtered_data, within_threshold == 2), aes(y = pmol_mg, color = id), size = 3, shape = 24,
      alpha = 0.3, position = position_nudge(x = 0.03), show.legend = FALSE # Up triangle for values above ULOQ
    ) +
    geom_point(
      data = subset(filtered_data, within_threshold == 1), aes(y = pmol_mg),color = "darkgrey", size = 3, shape = 25,
      alpha = 0.3, position = position_nudge(x = 0.03), show.legend = FALSE # Down triangle for values below LLOQ
    ) +
    geom_point(
          data = subset(filtered_data, within_threshold == 3), aes(y = pmol_mg), color = "black", size = 7, shape = 4,
      alpha = 0.5, position = position_nudge(x = 0.03), show.legend = FALSE # cross to signal outlier
    ) +
    
      geom_line(data = mean_data_comp, aes(x = interaction(group, time, sep = " "), y = mean_pmol_mg, group = group), color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
    
      
    # scale_color_manual(values = c("M" = "blue", "F" = "red"), name = "Gender") +
    labs(
      title = paste(lipid_class, lipid_composition),
      subtitle = annotation_pvals_slope,
      y = expression("Lipid concentration" ~ "(pmol " ~ mg^-1 * ")"),
      x = ""
    ) +

    # Insert P-values pre post
    annotate("text",
      x = c(1.5, 3.5, 5.5), y = max(filtered_data$pmol_mg) * 1.05,
      label = annotation_pvals_pre_post, size = 2
    ) +
    theme_minimal() +
    theme(
      axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
      legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
      legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), ,
      plot.subtitle = element_text(size = 5, hjust = 0.5)
    )


  # Define the filename and save the plot
  filename <- paste0(
    "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/plot, scatter composition/",
    gsub("/", "_", gsub(":", ",", paste(lipid_class, lipid_composition, sep = " "))), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each combination of lipid_class and lipid_composition
unique_lipid_classes <- unique(lipidomicsDF$lipidClass)
for (lipid_class in unique_lipid_classes) {
  lipid_compositions_in_class <- unique(lipidomicsDF$lipidComposition[lipidomicsDF$lipidClass == lipid_class])
  for (lipid_composition in lipid_compositions_in_class) {
    plot_lipid(lipidomicsDF, lipid_composition, lipid_class, detection_limits, est_and_p_lipid_comp$p.vals)
  }
}
```

### Lipid class
Scatter plot for each lipid class based on absolute lipid class concentration

```{r}
plot_lipid_class <- function(lipidomicsDF, lipid_class, detection_limits, p_val_df) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))

# MAKE SUM FOR EACH ID
pmol_mg_class_sum <- filtered_data %>%
  group_by(lipidClass, group, id, time) %>%
  summarize(
    sum_pmol_mg = sum(pmol_mg, na.rm = TRUE),
    .groups = "drop"  # Drop the grouping
  )
  
  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )

  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
mean_data_class <- pmol_mg_class_sum %>%
  group_by(group, time) %>%
  summarise(mean_pmol_mg_sum = mean(sum_pmol_mg, na.rm = TRUE), .groups = 'drop')
  
# Check if "PE:PC ratio" is one of the lipid classes
y_label <- if("PE/PC ratio" %in% filtered_data$lipidClass) {
  "PE/PC ratio"
} else {
  expression("Lipid concentration" ~ "(pmol " ~ mg^-1 * ")")
}

# Create the plot
plot <- ggplot(pmol_mg_class_sum, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = sum_pmol_mg, group = interaction(id, group)
  )) +
  geom_line(aes(group = interaction(id, group), color = id), alpha = 0.9, linewidth = 0.1, position = position_nudge(x = 0.03)) +
  geom_point(aes(color = id), alpha = 0.5, position = position_nudge(x = 0.03)) +

    geom_boxplot(aes(group = interaction(group, time)),
      width = 0.3, alpha = 0.2, outlier.shape = NA,
      position = position_dodge(width = 0.75), color = "black"
    ) +
  geom_line(data = mean_data_class, aes(x = interaction(group, time, sep = " "), y = mean_pmol_mg_sum, group = group),color = "black", linewidth = 1, position = position_nudge(x = 0.03)) +
  scale_color_manual(values = rainbow(length(unique(pmol_mg_class_sum$id)))) +
  labs(title = lipid_class, 
       subtitle = annotation_pvals_slope, 
       y = y_label,
       x = "") +
  annotate("text", x = c(1.5, 3.5, 5.5), y = 3.0, label = annotation_pvals_pre_post, size = 2) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
        legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
        legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
        plot.subtitle = element_text(size = 5, hjust = 0.5))

  # Filter the LLOQ and ULOQ for the current lipid_class and set y-axis limits
  #y_min <- min(pmol_mg_class_sum$sum_pmol_mg, na.rm = TRUE) * 0.95 # Adjusted
  #y_max <- max(pmol_mg_class_sum$pmol_mg_znorm, na.rm = TRUE) * 1.05 # Adjusted
  # plot <- plot + coord_cartesian(ylim = c(y_min, y_max))

  # Define the filename and save the plot
  filename <- paste0(
    "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/plot, scatter class/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each lipid class
for (lipid_class in unique_lipid_classes) {
  plot_lipid_class(lipidomicsDF, lipid_class, detection_limits, est_and_p_pvals_lipid_class$p.vals)
}
```

### Z-score lipidClass
Scatter plots of Z-score for each lipid class with lipid classes shown in different colors

```{r}
plot_lipid_class_z_score <- function(lipidomicsDF, lipid_class, detection_limits, p_val_df) {
  # Filter data based on lipid class and available time
  filtered_data <- lipidomicsDF %>%
    filter(lipidClass == lipid_class & !is.na(time))

  # Find correct p-values
  search_key <- lipid_class
  pvalues_to_annotate <- p_val_df[p_val_df[, 1] == search_key, ]

  # Generate labels with original and corrected p-values
  annotation_pvals_pre_post <- paste0(
    "pre vs post, p = ", formatC(unlist(pvalues_to_annotate[1, 2:4]), format = "f", digits = 3),
    "\nBenjamini-Hochberg, p = ", formatC(unlist(pvalues_to_annotate[1, 8:10]), format = "f", digits = 3)
  )

  annotation_pvals_slope <- paste0(
    "Slope p-values: HED vs DIWL, p = ", formatC(unlist(pvalues_to_annotate[1, 5]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 11]), format = "f", digits = 3),
    "       |    HED vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 6]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 12]), format = "f", digits = 3),
    "       |    DIWL vs WLEX, p = ", formatC(unlist(pvalues_to_annotate[1, 7]), format = "f", digits = 3),
    ", BH corrected, p = ", formatC(unlist(pvalues_to_annotate[1, 13]), format = "f", digits = 3)
  )
  
  # Calculate means for each group and time point
mean_data_class_zscore <- filtered_data %>%
  group_by(group, time) %>%
  summarise(mean_pmol_mg_znorm = mean(pmol_mg_znorm, na.rm = TRUE), .groups = 'drop')
  
# Create the plot
plot <- ggplot(filtered_data, aes(
    x = factor(interaction(group, time, sep = " "),
      levels = c("HED Pre", "HED Post", "DIWL Pre", "DIWL Post", "WLEX Pre", "WLEX Post")
    ),
    y = pmol_mg_znorm, group = interaction(id, group)
  )) +
  geom_line(aes(group = interaction(id, group, lipidComposition), color = lipidComposition), alpha = 0.9, size = 0.1, position = position_nudge(x = 0.03)) +
  geom_point(aes(color = lipidComposition), alpha = 0.5, position = position_nudge(x = 0.03)) +
  geom_line(data = mean_data_class_zscore, aes(x = interaction(group, time, sep = " "), y = mean_pmol_mg_znorm, group = group),color = "black", size = 1, position = position_nudge(x = 0.03)) +
  scale_color_manual(values = rainbow(length(unique(filtered_data$lipidComposition)))) +
  labs(title = lipid_class, subtitle = annotation_pvals_slope, y = "Lipid concentration, Z norm [comp within group]", x = "") +
  annotate("text", x = c(1.5, 3.5, 5.5), y = 3.0, label = annotation_pvals_pre_post, size = 2) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "right",
        legend.title.align = 0.5, plot.title = element_text(hjust = 0.5), legend.text = element_text(size = 6),
        legend.title = element_text(size = 6), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
        plot.subtitle = element_text(size = 5, hjust = 0.5))


  # Filter the LLOQ and ULOQ for the current lipid_class and set y-axis limits
  y_min <- min(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 0.95 # Adjusted
  y_max <- max(filtered_data$pmol_mg_znorm, na.rm = TRUE) * 1.05 # Adjusted
  plot <- plot + coord_cartesian(ylim = c(y_min, y_max))

  # Define the filename and save the plot
  filename <- paste0(
    "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/lipids, pre-post/plot, scatter class, z_score/",
    gsub(" ", "_", lipid_class), ".jpg"
  )
  ggsave(filename, plot = plot, device = "jpeg", width = 8, height = 6, dpi = 300)

  cat("Plot saved as:", filename, "\n")
}

# Loop to call the plotting function for each lipid class
for (lipid_class in unique_lipid_classes) {
  plot_lipid_class_z_score(lipidomicsDF, lipid_class, detection_limits, est_and_p_pvals_lipid_class$p.vals)
}
```

## QQ plots

QQ-plots for faw, normalized lipidomics data

```{r}
output_dir <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/plot, qq-plots"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

groups <- c("HED", "DIWL", "WLEX")
times <- c("Pre", "Post")

for (i in seq_len(nrow(unique_combinations))) {
  current_combination <- unique_combinations[i, ]

  sanitized_lipidClass <- gsub("[/:]", "_", current_combination$lipidClass)
  sanitized_lipidComposition <- gsub("[/:]", "_", current_combination$lipidComposition)
  file_name <- paste(sanitized_lipidClass, sanitized_lipidComposition, "qqplots.jpeg", sep = " ")
  file_path <- file.path(output_dir, file_name)

  # Open JPEG device
  jpeg(file_path, width = 800, height = 600)

  # Setup plot layout
  par(mfrow = c(3, 2), mar = c(4, 4, 2, 1))

  for (group in groups) {
    for (time in times) {
      data_to_plot <- lipidomicsDF %>%
        filter(
          lipidClass == current_combination$lipidClass,
          lipidComposition == current_combination$lipidComposition,
          group == !!group,
          time == !!time
        )

      # Plot only if there's data
      if (nrow(data_to_plot) > 0 && !all(is.na(data_to_plot$pmol_mg))) {
        qqnorm(data_to_plot$pmol_mg, main = paste(current_combination$lipidClass, current_combination$lipidComposition, group, time))
        qqline(data_to_plot$pmol_mg, col = "red")
      } else {
        plot.new()
        title(main = paste("No data for", current_combination$lipidClass, current_combination$lipidComposition, group, time))
      }
    }
  }

  # Close the plotting device
  dev.off()
}

cat("All plots have been saved to", output_dir, "\n")
```

QQ-plots for log transformed lipidomics data

```{r}
output_dir <- "/Users/au309166/Library/CloudStorage/OneDrive-Aarhusuniversitet/Forskning/Projects/LipidomicsMIRAGE/outputs/qq-plots/log transformed"
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

unique_combinations <- lipidomicsDF %>%
  distinct(lipidClass, lipidComposition) %>%
  arrange(lipidClass, lipidComposition)

groups <- c("HED", "DIWL", "WLEX")
times <- c("Pre", "Post")

for (i in seq_len(nrow(unique_combinations))) {
  current_combination <- unique_combinations[i, ]

  sanitized_lipidClass <- gsub("[/:]", "_", current_combination$lipidClass)
  sanitized_lipidComposition <- gsub("[/:]", "_", current_combination$lipidComposition)
  file_name <- paste(sanitized_lipidClass, sanitized_lipidComposition, "Log qqplots.jpeg", sep = " ")
  file_path <- file.path(output_dir, file_name)

  # Open JPEG device
  jpeg(file_path, width = 800, height = 600)

  # Setup plot layout
  par(mfrow = c(3, 2), mar = c(4, 4, 2, 1))

  for (group in groups) {
    for (time in times) {
      data_to_plot <- lipidomicsDF %>%
        filter(
          lipidClass == current_combination$lipidClass,
          lipidComposition == current_combination$lipidComposition,
          group == !!group,
          time == !!time
        )

      # Plot only if there's data
      if (nrow(data_to_plot) > 0 && !all(is.na(data_to_plot$pmol_mg))) {
        qqnorm(data_to_plot$pmol_mg_log, main = paste(current_combination$lipidClass, current_combination$lipidComposition, group, time))
        qqline(data_to_plot$pmol_mg_log, col = "red")
      } else {
        plot.new()
        title(main = paste("No data for", current_combination$lipidClass, current_combination$lipidComposition, group, time))
      }
    }
  }

  # Close the plotting device
  dev.off()
}

cat("All plots have been saved to", output_dir, "\n")
```
